2020-06-15T16:13:05.005Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma parvar q1
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = []; var q1 = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-15T16:23:07.602Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma parvar q1
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = []; var q1 = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-15T16:25:09.246Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma parvar q1
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = []; var q1 = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-15T16:27:41.232Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 4;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma parvar q1
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = []; var q1 = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-15T16:29:39.092Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 1;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma parvar q1
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = []; var q1 = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-15T16:32:17.952Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 1;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma parvar q1
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = []; var q1 = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-15T16:39:26.004Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 1;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma parvar q1
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = []; var q1 = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-15T16:49:39.148Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 1;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma parvar q1
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = []; var q1 = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-15T17:19:58.838Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 1;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma parvar q1
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = []; var q1 = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-15T17:25:06.003Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 1;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma parvar q1
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = []; var q1 = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-15T17:31:20.306Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 1;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma parvar q1
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = []; var q1 = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-15T17:36:00.267Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 1;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma parvar q1
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = []; var q1 = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-15T17:45:48.860Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 1;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma parvar q1
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = []; var q1 = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-15T18:07:14.702Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 1;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma parvar q1
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = []; var q1 = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-17T12:22:24.905Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma parvar q1
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = []; var q1 = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-17T12:24:27.033Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma parvar q1
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = []; var q1 = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-17T12:29:19.938Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma parvar q1
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = []; var q1 = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-17T12:34:20.896Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 8;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma parvar q1
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = []; var q1 = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-17T12:39:30.010Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 8;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-17T12:41:44.343Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 8;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-17T12:44:50.190Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 8;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 1400;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-17T12:45:58.773Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 1400;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-17T13:09:46.188Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 1400;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-17T13:10:42.463Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 8;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 1400;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-17T13:11:29.395Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 8;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-17T13:11:59.226Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 8;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-17T13:17:50.316Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 8;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-17T13:31:16.596Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 8;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-17T13:48:49.061Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 8;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-17T13:51:15.651Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 8;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-17T13:53:37.940Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-17T13:54:41.020Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-17T14:02:48.566Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-18T11:22:27.410Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 8;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-18T11:23:09.842Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 8;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-18T11:29:18.545Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 8;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-18T11:30:08.739Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 8;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-18T11:32:30.616Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 2;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-18T11:35:52.022Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-18T11:37:32.413Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-18T11:45:46.968Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 8;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 1400;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-18T11:46:55.140Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 8;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 1400;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-18T11:47:52.538Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 1400;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-18T11:48:35.934Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 1400;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-18T15:08:56.100Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-18T15:14:46.061Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 8;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-18T15:23:12.424Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-18T15:33:30.595Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-18T15:40:21.765Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 6;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-18T16:59:58.110Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 6;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-19T07:17:38.516Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//for (i = 0; i < n; i++) q[i] = 0.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
////#pragma parvar p
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
//console.log("got x");
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
//    __set_Par_Var_Value('p', p, __job, true);
    __set_Par_Var_Value('z', z, __job, true);
//    console.log("loop1");

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

    apos = 0;
	var smatvec_time = new Date().getTime();
//	console.log("loop2");
	// q = A*p
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar p
	//#pragma parvar q
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
//     console.log("opu#"+opu+" started");
       var chunk_len = Math.floor(n / OPUS);
        var slice_start = (opu-1) * chunk_len;
        var slice_end = slice_start + chunk_len - 1;
        if (slice_end >= n) slice_end = n - 1;
	    var q = [];
        var p = __get_Par_Var_Value('p', false, __job);
//     console.log("opu#"+opu+" after __get");
        var k = 0;
	    apos = 0;
	    for (i = 0; i <= slice_end; i++) {
	        if (i >= slice_start) {
	            q[k] = 0;
	            for (j = apos; j <= apos + arow[i] - 1; j++) {
		            q[k] += a[j] * p[aidx[j]];
		            }
		        k++;
	            }
	        apos += arow[i];
	        }
//    console.log("opu#"+opu+" __set");
//    q1 = __get_Par_Var_Value('q', true, __job);
        __set_Par_Var_Value('q', q, __job, true, slice_start);
//    console.log("opu#"+opu+" finished");
	    }
    //#pragma sequential
    //#pragma parvar p
    //#pragma parvar q
    //#pragma parvar r
    //#pragma parvar z
    //#pragma parvar x
    //#pragma noautoparvar
    //#pragma wait
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//    console.log("loop21");
//    var p=[];
    p = __get_Par_Var_Value('p', false, __job);
//    var q=[];
    q = __get_Par_Var_Value('q', false, __job);
//    var r=[];
    r = __get_Par_Var_Value('r', false, __job);
//    var z=[];
    z = __get_Par_Var_Value('z', false, __job);
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
//    console.log("loop21");

//	var fmatvec_time = new Date().getTime();
//	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
//	console.log(matvec_time);
    __set_Par_Var_Value('z', z, __job, true);
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('p', p, __job, true);

// __set_Par_Var_Value();   // generate an error to force exit
//    console.log("loop22");
	itcg++;
//	console.log("itcg="+itcg);
	}
iter=iter;
//console.log("break");
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-19T21:19:50.726Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('z', z, __job, true);

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

        apos = 0;
	    var smatvec_time = new Date().getTime();
	    // q = A*p
	    //#pragma parallel
	    //#pragma noautoparvar
	    //#pragma parvar p
	    //#pragma parvar q
	    //#pragma wait
	    for (opu = 1; opu <= OPUS; opu++) {
            var chunk_len = Math.floor(n / OPUS);
            var slice_start = (opu-1) * chunk_len;
            var slice_end = slice_start + chunk_len - 1;
            if (slice_end >= n) slice_end = n - 1;
	        var q = [];
            var p = __get_Par_Var_Value('p', false, __job);
            var k = 0;
	        apos = 0;
	        for (i = 0; i <= slice_end; i++) {
	            if (i >= slice_start) {
	                q[k] = 0;
	                for (j = apos; j <= apos + arow[i] - 1; j++) {
		                q[k] += a[j] * p[aidx[j]];
		                }
		            k++;
	                }
	            apos += arow[i];
	            }
            __set_Par_Var_Value('q', q, __job, true, slice_start);
	        }
        //#pragma sequential
        //#pragma parvar p
        //#pragma parvar q
        //#pragma parvar r
        //#pragma parvar z
        //#pragma parvar x
        //#pragma noautoparvar
        //#pragma wait
	    var fmatvec_time = new Date().getTime();
	    var matvec_time = (fmatvec_time - smatvec_time) / 1000;
        p = __get_Par_Var_Value('p', false, __job);
        q = __get_Par_Var_Value('q', false, __job);
        r = __get_Par_Var_Value('r', false, __job);
        z = __get_Par_Var_Value('z', false, __job);
	    alpha = rho / dotp(p, q);
	    for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	    rho0 = rho;
	    for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	    rho = dotp(r, r);
	    beta = rho / rho0;
	    for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
        __set_Par_Var_Value('z', z, __job, true);
        __set_Par_Var_Value('r', r, __job, true);
        __set_Par_Var_Value('p', p, __job, true);

	    itcg++;
    	}
    iter=iter;
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 4000) {
    timchk = 4.00;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-19T21:27:07.100Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('z', z, __job, true);

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

        apos = 0;
	    var smatvec_time = new Date().getTime();
	    // q = A*p
	    //#pragma parallel
	    //#pragma noautoparvar
	    //#pragma parvar p
	    //#pragma parvar q
	    //#pragma wait
	    for (opu = 1; opu <= OPUS; opu++) {
            var chunk_len = Math.floor(n / OPUS);
            var slice_start = (opu-1) * chunk_len;
            var slice_end = slice_start + chunk_len - 1;
            if (slice_end >= n) slice_end = n - 1;
	        var q = [];
            var p = __get_Par_Var_Value('p', false, __job);
            var k = 0;
	        apos = 0;
	        for (i = 0; i <= slice_end; i++) {
	            if (i >= slice_start) {
	                q[k] = 0;
	                for (j = apos; j <= apos + arow[i] - 1; j++) {
		                q[k] += a[j] * p[aidx[j]];
		                }
		            k++;
	                }
	            apos += arow[i];
	            }
            __set_Par_Var_Value('q', q, __job, true, slice_start);
	        }
        //#pragma sequential
        //#pragma parvar p
        //#pragma parvar q
        //#pragma parvar r
        //#pragma parvar z
        //#pragma parvar x
        //#pragma noautoparvar
        //#pragma wait
	    var fmatvec_time = new Date().getTime();
	    var matvec_time = (fmatvec_time - smatvec_time) / 1000;
        p = __get_Par_Var_Value('p', false, __job);
        q = __get_Par_Var_Value('q', false, __job);
        r = __get_Par_Var_Value('r', false, __job);
        z = __get_Par_Var_Value('z', false, __job);
	    alpha = rho / dotp(p, q);
	    for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	    rho0 = rho;
	    for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	    rho = dotp(r, r);
	    beta = rho / rho0;
	    for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
        __set_Par_Var_Value('z', z, __job, true);
        __set_Par_Var_Value('r', r, __job, true);
        __set_Par_Var_Value('p', p, __job, true);

	    itcg++;
    	}
    iter=iter;
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 4000) {
    timchk = 4.00;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-19T21:28:10.768Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('z', z, __job, true);

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

        apos = 0;
	    var smatvec_time = new Date().getTime();
	    // q = A*p
	    //#pragma parallel
	    //#pragma noautoparvar
	    //#pragma parvar p
	    //#pragma parvar q
	    //#pragma wait
	    for (opu = 1; opu <= OPUS; opu++) {
            var chunk_len = Math.floor(n / OPUS);
            var slice_start = (opu-1) * chunk_len;
            var slice_end = slice_start + chunk_len - 1;
            if (slice_end >= n) slice_end = n - 1;
	        var q = [];
            var p = __get_Par_Var_Value('p', false, __job);
            var k = 0;
	        apos = 0;
	        for (i = 0; i <= slice_end; i++) {
	            if (i >= slice_start) {
	                q[k] = 0;
	                for (j = apos; j <= apos + arow[i] - 1; j++) {
		                q[k] += a[j] * p[aidx[j]];
		                }
		            k++;
	                }
	            apos += arow[i];
	            }
            __set_Par_Var_Value('q', q, __job, true, slice_start);
	        }
        //#pragma sequential
        //#pragma parvar p
        //#pragma parvar q
        //#pragma parvar r
        //#pragma parvar z
        //#pragma parvar x
        //#pragma noautoparvar
        //#pragma wait
	    var fmatvec_time = new Date().getTime();
	    var matvec_time = (fmatvec_time - smatvec_time) / 1000;
        p = __get_Par_Var_Value('p', false, __job);
        q = __get_Par_Var_Value('q', false, __job);
        r = __get_Par_Var_Value('r', false, __job);
        z = __get_Par_Var_Value('z', false, __job);
	    alpha = rho / dotp(p, q);
	    for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	    rho0 = rho;
	    for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	    rho = dotp(r, r);
	    beta = rho / rho0;
	    for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
        __set_Par_Var_Value('z', z, __job, true);
        __set_Par_Var_Value('r', r, __job, true);
        __set_Par_Var_Value('p', p, __job, true);

	    itcg++;
    	}
    iter=iter;
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 4000) {
    timchk = 4.00;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-19T21:29:17.195Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 6;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('z', z, __job, true);

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

        apos = 0;
	    var smatvec_time = new Date().getTime();
	    // q = A*p
	    //#pragma parallel
	    //#pragma noautoparvar
	    //#pragma parvar p
	    //#pragma parvar q
	    //#pragma wait
	    for (opu = 1; opu <= OPUS; opu++) {
            var chunk_len = Math.floor(n / OPUS);
            var slice_start = (opu-1) * chunk_len;
            var slice_end = slice_start + chunk_len - 1;
            if (slice_end >= n) slice_end = n - 1;
	        var q = [];
            var p = __get_Par_Var_Value('p', false, __job);
            var k = 0;
	        apos = 0;
	        for (i = 0; i <= slice_end; i++) {
	            if (i >= slice_start) {
	                q[k] = 0;
	                for (j = apos; j <= apos + arow[i] - 1; j++) {
		                q[k] += a[j] * p[aidx[j]];
		                }
		            k++;
	                }
	            apos += arow[i];
	            }
            __set_Par_Var_Value('q', q, __job, true, slice_start);
	        }
        //#pragma sequential
        //#pragma parvar p
        //#pragma parvar q
        //#pragma parvar r
        //#pragma parvar z
        //#pragma parvar x
        //#pragma noautoparvar
        //#pragma wait
	    var fmatvec_time = new Date().getTime();
	    var matvec_time = (fmatvec_time - smatvec_time) / 1000;
        p = __get_Par_Var_Value('p', false, __job);
        q = __get_Par_Var_Value('q', false, __job);
        r = __get_Par_Var_Value('r', false, __job);
        z = __get_Par_Var_Value('z', false, __job);
	    alpha = rho / dotp(p, q);
	    for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	    rho0 = rho;
	    for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	    rho = dotp(r, r);
	    beta = rho / rho0;
	    for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
        __set_Par_Var_Value('z', z, __job, true);
        __set_Par_Var_Value('r', r, __job, true);
        __set_Par_Var_Value('p', p, __job, true);

	    itcg++;
    	}
    iter=iter;
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 4000) {
    timchk = 4.00;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-19T21:30:28.986Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 8;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('z', z, __job, true);

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

        apos = 0;
	    var smatvec_time = new Date().getTime();
	    // q = A*p
	    //#pragma parallel
	    //#pragma noautoparvar
	    //#pragma parvar p
	    //#pragma parvar q
	    //#pragma wait
	    for (opu = 1; opu <= OPUS; opu++) {
            var chunk_len = Math.floor(n / OPUS);
            var slice_start = (opu-1) * chunk_len;
            var slice_end = slice_start + chunk_len - 1;
            if (slice_end >= n) slice_end = n - 1;
	        var q = [];
            var p = __get_Par_Var_Value('p', false, __job);
            var k = 0;
	        apos = 0;
	        for (i = 0; i <= slice_end; i++) {
	            if (i >= slice_start) {
	                q[k] = 0;
	                for (j = apos; j <= apos + arow[i] - 1; j++) {
		                q[k] += a[j] * p[aidx[j]];
		                }
		            k++;
	                }
	            apos += arow[i];
	            }
            __set_Par_Var_Value('q', q, __job, true, slice_start);
	        }
        //#pragma sequential
        //#pragma parvar p
        //#pragma parvar q
        //#pragma parvar r
        //#pragma parvar z
        //#pragma parvar x
        //#pragma noautoparvar
        //#pragma wait
	    var fmatvec_time = new Date().getTime();
	    var matvec_time = (fmatvec_time - smatvec_time) / 1000;
        p = __get_Par_Var_Value('p', false, __job);
        q = __get_Par_Var_Value('q', false, __job);
        r = __get_Par_Var_Value('r', false, __job);
        z = __get_Par_Var_Value('z', false, __job);
	    alpha = rho / dotp(p, q);
	    for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	    rho0 = rho;
	    for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	    rho = dotp(r, r);
	    beta = rho / rho0;
	    for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
        __set_Par_Var_Value('z', z, __job, true);
        __set_Par_Var_Value('r', r, __job, true);
        __set_Par_Var_Value('p', p, __job, true);

	    itcg++;
    	}
    iter=iter;
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 4000) {
    timchk = 4.00;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-19T21:30:59.393Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 8;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('z', z, __job, true);

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

        apos = 0;
	    var smatvec_time = new Date().getTime();
	    // q = A*p
	    //#pragma parallel
	    //#pragma noautoparvar
	    //#pragma parvar p
	    //#pragma parvar q
	    //#pragma wait
	    for (opu = 1; opu <= OPUS; opu++) {
            var chunk_len = Math.floor(n / OPUS);
            var slice_start = (opu-1) * chunk_len;
            var slice_end = slice_start + chunk_len - 1;
            if (slice_end >= n) slice_end = n - 1;
	        var q = [];
            var p = __get_Par_Var_Value('p', false, __job);
            var k = 0;
	        apos = 0;
	        for (i = 0; i <= slice_end; i++) {
	            if (i >= slice_start) {
	                q[k] = 0;
	                for (j = apos; j <= apos + arow[i] - 1; j++) {
		                q[k] += a[j] * p[aidx[j]];
		                }
		            k++;
	                }
	            apos += arow[i];
	            }
            __set_Par_Var_Value('q', q, __job, true, slice_start);
	        }
        //#pragma sequential
        //#pragma parvar p
        //#pragma parvar q
        //#pragma parvar r
        //#pragma parvar z
        //#pragma parvar x
        //#pragma noautoparvar
        //#pragma wait
	    var fmatvec_time = new Date().getTime();
	    var matvec_time = (fmatvec_time - smatvec_time) / 1000;
        p = __get_Par_Var_Value('p', false, __job);
        q = __get_Par_Var_Value('q', false, __job);
        r = __get_Par_Var_Value('r', false, __job);
        z = __get_Par_Var_Value('z', false, __job);
	    alpha = rho / dotp(p, q);
	    for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	    rho0 = rho;
	    for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	    rho = dotp(r, r);
	    beta = rho / rho0;
	    for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
        __set_Par_Var_Value('z', z, __job, true);
        __set_Par_Var_Value('r', r, __job, true);
        __set_Par_Var_Value('p', p, __job, true);

	    itcg++;
    	}
    iter=iter;
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 4000) {
    timchk = 4.00;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-19T21:32:05.725Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 8;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('z', z, __job, true);

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

        apos = 0;
	    var smatvec_time = new Date().getTime();
	    // q = A*p
	    //#pragma parallel
	    //#pragma noautoparvar
	    //#pragma parvar p
	    //#pragma parvar q
	    //#pragma wait
	    for (opu = 1; opu <= OPUS; opu++) {
            var chunk_len = Math.floor(n / OPUS);
            var slice_start = (opu-1) * chunk_len;
            var slice_end = slice_start + chunk_len - 1;
            if (slice_end >= n) slice_end = n - 1;
	        var q = [];
            var p = __get_Par_Var_Value('p', false, __job);
            var k = 0;
	        apos = 0;
	        for (i = 0; i <= slice_end; i++) {
	            if (i >= slice_start) {
	                q[k] = 0;
	                for (j = apos; j <= apos + arow[i] - 1; j++) {
		                q[k] += a[j] * p[aidx[j]];
		                }
		            k++;
	                }
	            apos += arow[i];
	            }
            __set_Par_Var_Value('q', q, __job, true, slice_start);
	        }
        //#pragma sequential
        //#pragma parvar p
        //#pragma parvar q
        //#pragma parvar r
        //#pragma parvar z
        //#pragma parvar x
        //#pragma noautoparvar
        //#pragma wait
	    var fmatvec_time = new Date().getTime();
	    var matvec_time = (fmatvec_time - smatvec_time) / 1000;
        p = __get_Par_Var_Value('p', false, __job);
        q = __get_Par_Var_Value('q', false, __job);
        r = __get_Par_Var_Value('r', false, __job);
        z = __get_Par_Var_Value('z', false, __job);
	    alpha = rho / dotp(p, q);
	    for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	    rho0 = rho;
	    for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	    rho = dotp(r, r);
	    beta = rho / rho0;
	    for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
        __set_Par_Var_Value('z', z, __job, true);
        __set_Par_Var_Value('r', r, __job, true);
        __set_Par_Var_Value('p', p, __job, true);

	    itcg++;
    	}
    iter=iter;
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 4000) {
    timchk = 4.00;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-19T21:33:03.235Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 8;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('z', z, __job, true);

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

        apos = 0;
	    var smatvec_time = new Date().getTime();
	    // q = A*p
	    //#pragma parallel
	    //#pragma noautoparvar
	    //#pragma parvar p
	    //#pragma parvar q
	    //#pragma wait
	    for (opu = 1; opu <= OPUS; opu++) {
            var chunk_len = Math.floor(n / OPUS);
            var slice_start = (opu-1) * chunk_len;
            var slice_end = slice_start + chunk_len - 1;
            if (slice_end >= n) slice_end = n - 1;
	        var q = [];
            var p = __get_Par_Var_Value('p', false, __job);
            var k = 0;
	        apos = 0;
	        for (i = 0; i <= slice_end; i++) {
	            if (i >= slice_start) {
	                q[k] = 0;
	                for (j = apos; j <= apos + arow[i] - 1; j++) {
		                q[k] += a[j] * p[aidx[j]];
		                }
		            k++;
	                }
	            apos += arow[i];
	            }
            __set_Par_Var_Value('q', q, __job, true, slice_start);
	        }
        //#pragma sequential
        //#pragma parvar p
        //#pragma parvar q
        //#pragma parvar r
        //#pragma parvar z
        //#pragma parvar x
        //#pragma noautoparvar
        //#pragma wait
	    var fmatvec_time = new Date().getTime();
	    var matvec_time = (fmatvec_time - smatvec_time) / 1000;
        p = __get_Par_Var_Value('p', false, __job);
        q = __get_Par_Var_Value('q', false, __job);
        r = __get_Par_Var_Value('r', false, __job);
        z = __get_Par_Var_Value('z', false, __job);
	    alpha = rho / dotp(p, q);
	    for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	    rho0 = rho;
	    for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	    rho = dotp(r, r);
	    beta = rho / rho0;
	    for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
        __set_Par_Var_Value('z', z, __job, true);
        __set_Par_Var_Value('r', r, __job, true);
        __set_Par_Var_Value('p', p, __job, true);

	    itcg++;
    	}
    iter=iter;
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 4000) {
    timchk = 4.00;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-19T21:33:37.223Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 8;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('z', z, __job, true);

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

        apos = 0;
	    var smatvec_time = new Date().getTime();
	    // q = A*p
	    //#pragma parallel
	    //#pragma noautoparvar
	    //#pragma parvar p
	    //#pragma parvar q
	    //#pragma wait
	    for (opu = 1; opu <= OPUS; opu++) {
            var chunk_len = Math.floor(n / OPUS);
            var slice_start = (opu-1) * chunk_len;
            var slice_end = slice_start + chunk_len - 1;
            if (slice_end >= n) slice_end = n - 1;
	        var q = [];
            var p = __get_Par_Var_Value('p', false, __job);
            var k = 0;
	        apos = 0;
	        for (i = 0; i <= slice_end; i++) {
	            if (i >= slice_start) {
	                q[k] = 0;
	                for (j = apos; j <= apos + arow[i] - 1; j++) {
		                q[k] += a[j] * p[aidx[j]];
		                }
		            k++;
	                }
	            apos += arow[i];
	            }
            __set_Par_Var_Value('q', q, __job, true, slice_start);
	        }
        //#pragma sequential
        //#pragma parvar p
        //#pragma parvar q
        //#pragma parvar r
        //#pragma parvar z
        //#pragma parvar x
        //#pragma noautoparvar
        //#pragma wait
	    var fmatvec_time = new Date().getTime();
	    var matvec_time = (fmatvec_time - smatvec_time) / 1000;
        p = __get_Par_Var_Value('p', false, __job);
        q = __get_Par_Var_Value('q', false, __job);
        r = __get_Par_Var_Value('r', false, __job);
        z = __get_Par_Var_Value('z', false, __job);
	    alpha = rho / dotp(p, q);
	    for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	    rho0 = rho;
	    for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	    rho = dotp(r, r);
	    beta = rho / rho0;
	    for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
        __set_Par_Var_Value('z', z, __job, true);
        __set_Par_Var_Value('r', r, __job, true);
        __set_Par_Var_Value('p', p, __job, true);

	    itcg++;
    	}
    iter=iter;
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 4000) {
    timchk = 4.00;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-19T21:34:40.390Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 8;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('z', z, __job, true);

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

        apos = 0;
	    var smatvec_time = new Date().getTime();
	    // q = A*p
	    //#pragma parallel
	    //#pragma noautoparvar
	    //#pragma parvar p
	    //#pragma parvar q
	    //#pragma wait
	    for (opu = 1; opu <= OPUS; opu++) {
            var chunk_len = Math.floor(n / OPUS);
            var slice_start = (opu-1) * chunk_len;
            var slice_end = slice_start + chunk_len - 1;
            if (slice_end >= n) slice_end = n - 1;
	        var q = [];
            var p = __get_Par_Var_Value('p', false, __job);
            var k = 0;
	        apos = 0;
	        for (i = 0; i <= slice_end; i++) {
	            if (i >= slice_start) {
	                q[k] = 0;
	                for (j = apos; j <= apos + arow[i] - 1; j++) {
		                q[k] += a[j] * p[aidx[j]];
		                }
		            k++;
	                }
	            apos += arow[i];
	            }
            __set_Par_Var_Value('q', q, __job, true, slice_start);
	        }
        //#pragma sequential
        //#pragma parvar p
        //#pragma parvar q
        //#pragma parvar r
        //#pragma parvar z
        //#pragma parvar x
        //#pragma noautoparvar
        //#pragma wait
	    var fmatvec_time = new Date().getTime();
	    var matvec_time = (fmatvec_time - smatvec_time) / 1000;
        p = __get_Par_Var_Value('p', false, __job);
        q = __get_Par_Var_Value('q', false, __job);
        r = __get_Par_Var_Value('r', false, __job);
        z = __get_Par_Var_Value('z', false, __job);
	    alpha = rho / dotp(p, q);
	    for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	    rho0 = rho;
	    for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	    rho = dotp(r, r);
	    beta = rho / rho0;
	    for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
        __set_Par_Var_Value('z', z, __job, true);
        __set_Par_Var_Value('r', r, __job, true);
        __set_Par_Var_Value('p', p, __job, true);

	    itcg++;
    	}
    iter=iter;
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 4000) {
    timchk = 4.00;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-19T21:35:13.200Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 8;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('z', z, __job, true);

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

        apos = 0;
	    var smatvec_time = new Date().getTime();
	    // q = A*p
	    //#pragma parallel
	    //#pragma noautoparvar
	    //#pragma parvar p
	    //#pragma parvar q
	    //#pragma wait
	    for (opu = 1; opu <= OPUS; opu++) {
            var chunk_len = Math.floor(n / OPUS);
            var slice_start = (opu-1) * chunk_len;
            var slice_end = slice_start + chunk_len - 1;
            if (slice_end >= n) slice_end = n - 1;
	        var q = [];
            var p = __get_Par_Var_Value('p', false, __job);
            var k = 0;
	        apos = 0;
	        for (i = 0; i <= slice_end; i++) {
	            if (i >= slice_start) {
	                q[k] = 0;
	                for (j = apos; j <= apos + arow[i] - 1; j++) {
		                q[k] += a[j] * p[aidx[j]];
		                }
		            k++;
	                }
	            apos += arow[i];
	            }
            __set_Par_Var_Value('q', q, __job, true, slice_start);
	        }
        //#pragma sequential
        //#pragma parvar p
        //#pragma parvar q
        //#pragma parvar r
        //#pragma parvar z
        //#pragma parvar x
        //#pragma noautoparvar
        //#pragma wait
	    var fmatvec_time = new Date().getTime();
	    var matvec_time = (fmatvec_time - smatvec_time) / 1000;
        p = __get_Par_Var_Value('p', false, __job);
        q = __get_Par_Var_Value('q', false, __job);
        r = __get_Par_Var_Value('r', false, __job);
        z = __get_Par_Var_Value('z', false, __job);
	    alpha = rho / dotp(p, q);
	    for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	    rho0 = rho;
	    for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	    rho = dotp(r, r);
	    beta = rho / rho0;
	    for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
        __set_Par_Var_Value('z', z, __job, true);
        __set_Par_Var_Value('r', r, __job, true);
        __set_Par_Var_Value('p', p, __job, true);

	    itcg++;
    	}
    iter=iter;
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 4000) {
    timchk = 4.00;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-19T21:35:42.846Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 8;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('z', z, __job, true);

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

        apos = 0;
	    var smatvec_time = new Date().getTime();
	    // q = A*p
	    //#pragma parallel
	    //#pragma noautoparvar
	    //#pragma parvar p
	    //#pragma parvar q
	    //#pragma wait
	    for (opu = 1; opu <= OPUS; opu++) {
            var chunk_len = Math.floor(n / OPUS);
            var slice_start = (opu-1) * chunk_len;
            var slice_end = slice_start + chunk_len - 1;
            if (slice_end >= n) slice_end = n - 1;
	        var q = [];
            var p = __get_Par_Var_Value('p', false, __job);
            var k = 0;
	        apos = 0;
	        for (i = 0; i <= slice_end; i++) {
	            if (i >= slice_start) {
	                q[k] = 0;
	                for (j = apos; j <= apos + arow[i] - 1; j++) {
		                q[k] += a[j] * p[aidx[j]];
		                }
		            k++;
	                }
	            apos += arow[i];
	            }
            __set_Par_Var_Value('q', q, __job, true, slice_start);
	        }
        //#pragma sequential
        //#pragma parvar p
        //#pragma parvar q
        //#pragma parvar r
        //#pragma parvar z
        //#pragma parvar x
        //#pragma noautoparvar
        //#pragma wait
	    var fmatvec_time = new Date().getTime();
	    var matvec_time = (fmatvec_time - smatvec_time) / 1000;
        p = __get_Par_Var_Value('p', false, __job);
        q = __get_Par_Var_Value('q', false, __job);
        r = __get_Par_Var_Value('r', false, __job);
        z = __get_Par_Var_Value('z', false, __job);
	    alpha = rho / dotp(p, q);
	    for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	    rho0 = rho;
	    for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	    rho = dotp(r, r);
	    beta = rho / rho0;
	    for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
        __set_Par_Var_Value('z', z, __job, true);
        __set_Par_Var_Value('r', r, __job, true);
        __set_Par_Var_Value('p', p, __job, true);

	    itcg++;
    	}
    iter=iter;
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 4000) {
    timchk = 4.00;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-19T21:38:04.654Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= OPUS; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('z', z, __job, true);

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

        apos = 0;
	    var smatvec_time = new Date().getTime();
	    // q = A*p
	    //#pragma parallel
	    //#pragma noautoparvar
	    //#pragma parvar p
	    //#pragma parvar q
	    //#pragma wait
	    for (opu = 1; opu <= OPUS; opu++) {
            var chunk_len = Math.floor(n / OPUS);
            var slice_start = (opu-1) * chunk_len;
            var slice_end = slice_start + chunk_len - 1;
            if (slice_end >= n) slice_end = n - 1;
	        var q = [];
            var p = __get_Par_Var_Value('p', false, __job);
            var k = 0;
	        apos = 0;
	        for (i = 0; i <= slice_end; i++) {
	            if (i >= slice_start) {
	                q[k] = 0;
	                for (j = apos; j <= apos + arow[i] - 1; j++) {
		                q[k] += a[j] * p[aidx[j]];
		                }
		            k++;
	                }
	            apos += arow[i];
	            }
            __set_Par_Var_Value('q', q, __job, true, slice_start);
	        }
        //#pragma sequential
        //#pragma parvar p
        //#pragma parvar q
        //#pragma parvar r
        //#pragma parvar z
        //#pragma parvar x
        //#pragma noautoparvar
        //#pragma wait
	    var fmatvec_time = new Date().getTime();
	    var matvec_time = (fmatvec_time - smatvec_time) / 1000;
        p = __get_Par_Var_Value('p', false, __job);
        q = __get_Par_Var_Value('q', false, __job);
        r = __get_Par_Var_Value('r', false, __job);
        z = __get_Par_Var_Value('z', false, __job);
	    alpha = rho / dotp(p, q);
	    for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	    rho0 = rho;
	    for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	    rho = dotp(r, r);
	    beta = rho / rho0;
	    for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
        __set_Par_Var_Value('z', z, __job, true);
        __set_Par_Var_Value('r', r, __job, true);
        __set_Par_Var_Value('p', p, __job, true);

	    itcg++;
    	}
    iter=iter;
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 4000) {
    timchk = 4.00;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-19T21:41:26.574Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

//#pragma parvar a    // to avoid transferring 'a' to the server
//#pragma parvar aidx  //  --//--
//#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;

makea();

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;

for (i = 0; i < n; i++) x[i] = 1.;
// main loop
iter = 1;
////#pragma dive
while (iter <= niter) {

    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];

    itcg = 1;
    ////#pragma dive
    while (itcg <= nitcg) {
    
	for (i = 0; i < n; i++) q[i] = 0.;

	// q = A*p
	////#pragma parvar q
	//////#pragma parvar p   ?
	////#pragma noautoparvar
	////#pragma parallel
//	for (ch = 0; ch < OPUS; ch++) {
	var smatvec_time = new Date().getTime();
	apos = 0;
	for (i = 0; i < n; i++) {
	    q[i] = 0;
	    for (var j = apos; j <= apos + arow[i] - 1; j++) {
		q[i] += a[j] * p[aidx[j]];
		}
	    apos += arow[i];
	    }
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
	////#pragma wait
	////#pragma sequential
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
	
	itcg++;
//	console.log("itcg="+itcg);
	}

    // r = A*z
    ////#pragma parvar r
    ////#pragma parvar z   ?
    ////#pragma noautoparvar
    ////#pragma parallel
//    for (ch = 0; ch < OPUS; ch++) {
    apos = 0;
    for (i = 0; i < n; i++) {
	r[i] = 0;
	for (var j = apos; j <= apos + arow[i] - 1; j++) {
	    r[i] = r[i] + a[j] * z[aidx[j]];
	    }
	apos += arow[i];
	}
    ////#pragma wait
    ////#pragma sequential

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;

    iter++;
//    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(sa[i][j]);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-19T21:43:06.956Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

//#pragma parvar a    // to avoid transferring 'a' to the server
//#pragma parvar aidx  //  --//--
//#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;

makea();

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;

for (i = 0; i < n; i++) x[i] = 1.;
// main loop
iter = 1;
////#pragma dive
while (iter <= niter) {

    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];

    itcg = 1;
    ////#pragma dive
    while (itcg <= nitcg) {
    
	for (i = 0; i < n; i++) q[i] = 0.;

	// q = A*p
	////#pragma parvar q
	//////#pragma parvar p   ?
	////#pragma noautoparvar
	////#pragma parallel
//	for (ch = 0; ch < OPUS; ch++) {
	var smatvec_time = new Date().getTime();
	apos = 0;
	for (i = 0; i < n; i++) {
	    q[i] = 0;
	    for (var j = apos; j <= apos + arow[i] - 1; j++) {
		q[i] += a[j] * p[aidx[j]];
		}
	    apos += arow[i];
	    }
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
	////#pragma wait
	////#pragma sequential
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
	
	itcg++;
//	console.log("itcg="+itcg);
	}

    // r = A*z
    ////#pragma parvar r
    ////#pragma parvar z   ?
    ////#pragma noautoparvar
    ////#pragma parallel
//    for (ch = 0; ch < OPUS; ch++) {
    apos = 0;
    for (i = 0; i < n; i++) {
	r[i] = 0;
	for (var j = apos; j <= apos + arow[i] - 1; j++) {
	    r[i] = r[i] + a[j] * z[aidx[j]];
	    }
	apos += arow[i];
	}
    ////#pragma wait
    ////#pragma sequential

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 4000) {
    timchk = 4.00;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(sa[i][j]);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-19T21:45:00.611Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

//#pragma parvar a    // to avoid transferring 'a' to the server
//#pragma parvar aidx  //  --//--
//#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;

makea();

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;

for (i = 0; i < n; i++) x[i] = 1.;
// main loop
iter = 1;
while (iter <= niter) {

    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];

    itcg = 1;
    while (itcg <= nitcg) {
    
	for (i = 0; i < n; i++) q[i] = 0.;

	// q = A*p
	var smatvec_time = new Date().getTime();
	apos = 0;
	for (i = 0; i < n; i++) {
	    q[i] = 0;
	    for (var j = apos; j <= apos + arow[i] - 1; j++) {
		q[i] += a[j] * p[aidx[j]];
		}
	    apos += arow[i];
	    }
	var fmatvec_time = new Date().getTime();
	var matvec_time = (fmatvec_time - smatvec_time) / 1000;
	alpha = rho / dotp(p, q);
	for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	rho0 = rho;
	for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	rho = dotp(r, r);
	beta = rho / rho0;
	for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
	
	itcg++;
//	console.log("itcg="+itcg);
	}

    // r = A*z
    apos = 0;
    for (i = 0; i < n; i++) {
	r[i] = 0;
	for (var j = apos; j <= apos + arow[i] - 1; j++) {
	    r[i] = r[i] + a[j] * z[aidx[j]];
	    }
	apos += arow[i];
	}
    
    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 4000) {
    timchk = 4.00;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(sa[i][j]);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-06-19T21:46:41.278Z: user: vladas
//#pragma sequential

dfltParams = {
    NORM : 1,
    IDEF : 1,
    MXMN : -1,
    DEL : 1.e-5,
    NIU : 0.1,
    EPS : 0.001,
    DZV : 0.2
    };

var NORM, // these must be explicitly defined to receive further values.
    IDEF,
    MXMN,
    DEL,
    NIU,
    EPS,
    DZV,
    NP1,
    MP1;

var rp = true;
params = {};
var dz = [0.,0.,0.];
var g = [], g_save = [];
var g5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]]; // prevent array from a jam by JSON.stringify
var h = [];
var hm = [];
var hm1 = [];
var sm = [], sn = [];
var sn5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var sp = [];
var x = [];
var x5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]]; 
var y = [];
var y5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var m = [];
var z = [];
var b = [];
var h1 = [];
var xg, fg;
var xg5 = [0,0,0,0,0,0,0,0,0];
var fg5 = [0,0,0,0,0,0,0,0,0];
var iter;
var kbh;
var pstr;
var effDEL;
var funcalls = 0, funcallsp;

var res = fs.readFileSync("linit.prm.json");
try {params = JSON.parse(res.toString(), null);}
catch(err){console.log(err.message);}

for (var p in dfltParams) {
    if (!params[p]) params[p] = dfltParams[p];
}

for (var p in params) {
    eval(p +'= params["'+p+'"]');  // I know it's ugly
}

var np1 = NP1;
var mp1 = MP1;
var np11 = np1+1, mp11 = mp1+1 ,i;
var kbh=0;

for (i=1; i<=mp1; i++) g[i]=0.;
g[1]=1.;

readex(true);

pstr = "NORM="+NORM+" IDEF="+IDEF+" MXMN="+MXMN+" DEL="+DEL+" NIU="+NIU+"\n EPS="+EPS+" DZV="+DZV+" MP1="+MP1+" NP1="+NP1;
console.log(pstr);
if (rp) fs.writeFileSync('linit.rpt.jsc', pstr+'\n');

var alfa, alf1;
var lamnor, niuf;
var xgnorm, xgnorm_min;
var xgnorm5 = [0,0,0,0,0,,0,0,0];
var  xg_min;
var ind=0, ind5=[0,0,0,0,0,0,0,0,0];
var i, j, k, k_max, k_min, n, ind_gt_3;
var i_n, i_n5 = [0,0,0,0,0,0,0,0,0];
var it_entr;
var DELsave, DELs;
var coef=[];

var start_time = new Date().getTime();
console.log(start_time);
if (rp) fs.appendFileSync('linit.rpt.jsc', start_time + "\n");
var finish_time;
var elapse_time;

var n=np1-1;
for (i=1;i<=n;i++) hm[1][i] = -1.*MXMN*hm[1][i];

if (NORM == 0) lamnor = Hnorm();
if (EPS == 0) Epsdef();

//#pragma wait
//#pragma cache hm
//#pragma cache sp
//#pragma cache sm
////#pragma cachefuncs
//#pragma sequential
//\\g = g;
//\\g_save = g_save;

iter = 1;
ind=0;
DELsave = DEL;
var EPS5=[EPS,EPS,EPS,EPS,EPS,EPS,EPS,EPS,EPS];
var xgnorm5 = [0,0,0,0,0,0,0,0,0];
var g5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var sn5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var eps = [];
h = [[0],[0],[0]];

cpvec(g, g_save);

if (rp)
    fs.appendFileSync('linit.rpt.jsc', "\nIter(k)      F(g)     (X,g)    //X//g   Ind Nr.       Eps      Alfa  It_entry\n");
console.log("\nIter(k)      F(g)     (X,g)    //X//g   Ind Nr.       Eps      Alfa  It_entry\n");

//#pragma dive
//#pragma sequential
while (iter<=5000 && ind != 3) {

//\\    EPS5 = EPS5; // for lexical analyzer to find EPS5 variable
//\\    eps = eps;
    cpvec(EPS5, eps);

    DEL = DELsave;
    ind=2;

    if (iter == 1) k_max = 1;
    else k_max = 5;

//#pragma wait
//#pragma parallel
//#pragma noautoparvar
//#pragma parvar g5
//#pragma parvar sn5
//#pragma parvar x5
//#pragma parvar y5
//#pragma parvar xg5
//#pragma parvar fg5
//#pragma parvar ind5
//#pragma parvar i_n5
//#pragma parvar xgnorm5
//#pragma parvar EPS5
    for (k=1;k<=k_max;k++) {

        if (!k_min) k_min = 1;
        EPS = eps[k_min]; 

	    effDEL = DEL;
	    it_entr = 0;

//\\        iter = iter;
//\\	    sn = sn;
//\\	    sm = sm;
//\\	    sp = sp;
//\\	    g_save = g_save;
//\\	    DZV = DZV;
//\\	    coef = coef;
	    m = [];
	    x = [];
	    fg=0.;

	    cpvec(g_save, g);

	    while (ind == 2) {

   	        i_n = Minxg(k, sm, sp);

	        for (var ii=1;ii<=n;ii++) {
		        for (j=1;j<=mp1;j++) hm1[j] = hm[j][ii];
		        h[2][ii] = Skabg(x,hm1,1,mp1);
		        }

	        ind=1;
	        DELs = DEL;

	        while (ind == 1) {

                ind = Analys(Mnxgco(), DZV);
		        xgnorm = Skabg(x,x,2,mp1);
		
		        it_entr = it_entr + 1;
		        if (it_entr%500 == 0) {
		            DEL = DEL * 2.0;
		            if (DEL > 0.3) DEL = 0.3;
		            effDEL = DEL;
	    
//		            if (rp)
//			        fs.appendFileSync('linit.rpt.jsc',""+it_entr + "  " + DEL + "\n");
		            console.log(""+it_entr + "  " + DEL);
		            }
		        } // while (ind == 1)
	    
    		DEL=DELs;
	        }  // while (ind == 2)

	        __set_Par_Var_Value('xgnorm5['+k+']', xgnorm, __job, true);

	        if (ind == 3) {
    
		        __set_Par_Var_Value('ind5['+k+']', ind, __job, true);
		        __set_Par_Var_Value('sn5['+k+']', sn, __job, true);
		        }

	        for (i=1; i<=mp1; i++) hm1[i] = hm[i][np1];

	        dz[1] = Hb(hm1,g,mp1);
	        dz[2] = Skabg(hm1,y,1,mp1);
	        alfa = Mxmnxg();
	        if (alfa != 0.) {
		        alf1 = 1.-alfa*y[1];
		        for (i=1; i<=mp1 ; i++) g[i] = alf1*g[i] + alfa*y[i];

	            __set_Par_Var_Value('g5['+k+']', g, __job, true);

	            xg = Hb(x,g,mp1);
	            if (rp)
    		        fs.appendFileSync('linit.rpt.jsc',strf(iter,4)+"("+k+") "+strf(fg,10)+" "+strf(xg,10)+" "+strf(xgnorm,10)+" "+strf(i_n,10)+" "+strf(EPS,10)+" "+strf(alfa,10)+" "+strf(it_entr,6)+"\n");
    	        console.log(strf(iter,4)+"("+k+") "+strf(fg,10)+" "+strf(xg,10)+" "+strf(xgnorm,10)+" "+strf(i_n,10)+" "+strf(EPS,10)+" "+strf(alfa,10)+" "+strf(it_entr,6));

	            niuf = 2.* Math.abs(fg-xg)/ Math.abs(fg+xg);
	            if (niuf < NIU / 2. ) {
		        EPS = EPS*1.25;
		        }

	        __set_Par_Var_Value('EPS5['+k+']', EPS, __job, true);
	        }
	    else {
	        console.log("Problem has no solution");
	        exit(1);
	        }
	    ind = 2;
	    } // end for

//#pragma wait
//#pragma sequential
//\\    eps = eps;
    var xgnorm_min = xgnorm5[1];
    cpvec(EPS5, eps);

    k_min = 1;
    var ki=1;
    for (ki=1; ki<=k_max; ki++) {
	    if (xgnorm5[ki] < xgnorm_min) {
	        xgnorm_min = xgnorm5[ki];
	        k_min = ki;
	        }
	    if (ind5[ki] == 3) {ind=3; k_min=ki; break;}
	    }

	g_save = __get_Par_Var_Value('g5['+k_min+']', false, __job);
	var jitter = (iter % 2 == 0)? 0.99995 : 1.00005;
	for (var ii=1;ii<=np1;ii++) { g_save[ii] = g_save[ii] * jitter; }
    xgnorm = xgnorm5[k_min];
    EPS = EPS5[k_min];    

    fs.appendFileSync('linit.rpt.jsc',"\nk_min="+k_min+"\n");
    console.log("\nk_min="+k_min+"\n");

    if (ind != 3) ind = ind5[k_min];
	else sn = __get_Par_Var_Value('sn5['+k_min+']', false, __job);

    iter=iter+1;
    }

//#pragma sequential
//#wait
if (ind != 3 ) {
    if (rp) fs.appendFileSync('linit.rpt.jsc'," No solution after more than 200 iterations !\n");
    console.log (" No solution after more than 500 iterations !\n");
    }

for (var i=1; i<=np1; i++) hm[1][i] = -1*MXMN*hm[1][i];

finish_time = new Date().getTime();
console.log(finish_time);
if (rp) fs.appendFileSync('linit.rpt.jsc', finish_time + "\n");
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec");
if (rp) fs.appendFileSync('linit.rpt.jsc', "Elapse time: " + elapse_time + " sec\n");

for (i=1;i<=np1-1;i++) {
    if (rp) fs.appendFileSync('linit.rpt.jsc',sn[i]+ "  ");
    if (i%3 == 0) {
        if (rp) fs.appendFileSync('linit.rpt.jsc', "\n");
        }
   }
if (rp) {
    fs.appendFileSync('linit.rpt.jsc', "\nXG="+xg+"   "+"FG="+fg+"\n");
    console.log("\nXG="+xg+"   "+"FG="+fg+"\n");
   }
console.log(" End of solution \n");

// Functions

function max(a,b) {
    return a > b ? a : b; 
}

function min(a,b) {
    return a < b ? a : b; 
}

function readex(fromfile) {

    var i, j;
    var data = {};
    var mp1 = MP1, np1 = NP1;

    if (fromfile) {
	    var res = fs.readFileSync("linit.data.json");
	    data = JSON.parse(res, null);
	    hm = data.hm;
	    sm = data.sm;
	    sp = data.sp;
	    }
}

function cpvec(av, bv) {

    if (!av) return;
    for (var ii=0; ii<av.length; ii++ ) bv[ii] = av[ii];

}

function strf(num, len) {

    var bl = "";
    for (var i=1; i<=len; i++) bl+=" ";
    var ns = num.toString() + bl;
    return ns.substr(0,len);
}


function Minxg(k, sm, sp) {

    var hmg;
    var i, j, i_n;
    coef = [0, 1.18, -1.18, 1.18, -1.18, 1.18, -1.18, 1.18, -1.18, 1.18];

    for (i=1; i<=n ;i++) {
	    for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
	    h[1][i] = Hb(hm1,g,mp1);
	    hmg = Skabg(hm1,hm1,2,mp1);

	    if ( h[1][i] > coef[k]*EPS*hmg ) sn[i] = sm[i];
	    else sn[i] = sp[i];
        }

    for (i=1; i<=mp1; i++) {
	    x[i] = hm[i][np1];
	    for (j=1; j<=n; j++) x[i] = x[i] + hm[i][j]*sn[j];
	    }

    fg = Hb(x,g,mp1);

    i_n=0;

    for (i=1; i<=n; i++) {
	    for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
	    hmg = Skabg(hm1,hm1,2,mp1);
	    m[i]=0;
	    if (Math.abs(h[1][i]) <= (1.04+k*0.2)*EPS*hmg) { // was 0.8+k*0.2
    	    m[i] = 1;
    	    i_n++;
    	    }
	    }

    return(i_n);

}

function Analys(ind1, DZV) {

    var d=0., niuf=0., s=0., xgnorm=0.;
    var i, j, kt, ind = 0;

    xg = Hb(x,g,mp1);
    if (fg + xg != 0. ) {
	    niuf = 2.* Math.abs((fg-xg))/ Math.abs((fg+xg));
	    if (niuf > NIU ) {
    	    ind = 2;
    	    EPS = EPS*0.75;
    	    }
	    }

    if (ind != 2) {
	    kt = 0;
	    if (Math.abs((x[1]-xg)) > DEL ) kt = 1;
	    for (i=2; i<=mp1; i++) {
    	    if (Math.abs(x[i]) > DEL ) kt = 1;
    	    }
	    if ( kt == 0) ind = 3;
	    if ( ind != 3) {
    	    xgnorm = Skabg(x,x,2,mp1);
    	    y[1] = (x[1]-xg)/xgnorm;
    	    for (i=2; i<=mp1; i++) y[i] = x[i]/xgnorm;
    	    for (i=1; i<=n; i++) {
		        for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
		        h[2][i] = Skabg(hm1,y,1,mp1);
		        }
    	    d = 0.;
    	    for (i=1; i<=n; i++) {
		        if ( m[i] != 0 ) {
		            if (h[2][i] > 0.) s = sn[i] - sm[i];
		            else s = sn[i] - sp[i];
		            d = d + h[2][i]*s;
		            }
		        }
    	    d = d/xgnorm;
    	    if (d >= DZV) ind = 1;
    	    }
	    }

    if (ind1 == 0) return(0);
    return(ind);

}

function Mnxgco() {


    var dels = 0., del = 0., temp = 0.;
    var fdels = 0., fdels_old = 0., fdels_diff = 0.;

    var dz1, dz2, i, j;
    var iter_out = 0, iter_in = 0;

    do {
	    dz1 = 0;
	    dz2 = 0;

	    for (i=1; i<=n; i++) if (m[i]>0) m[i] = 2;

	    iter_in = 0;

	    do {

    	    if (dz1 == 0 && dz2 == 1 ) dz1 = 1;
    	    dz2 = 0;
    	    for (i=1; i<=n; i++) {
		        if ( m[i] == 2) {
		            for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
		            temp = Skabg(hm1,hm1,2,mp1);
		            del = Skabg(x,hm1,1,mp1)/(-temp*temp);
		            if (del < 0. ) dels=max(del,(sm[i]-sn[i]));
		            else dels=min(del,(sp[i]-sn[i]));
		            for (j=1; j<=mp1; j++) x[j] += dels*hm1[j];
		            sn[i] += dels;
		            if (sn[i]==sp[i] || sn[i]==sm[i]) {
			            m[i] = 1;
			            dz2 = 1;
			            }
		            }
		        }
    	    iter_in = iter_in + 1;
    	    fdels = Math.abs(dels);
    	    if (fdels < effDEL*effDEL) {
    		    return(1);
    		    }
    	    fdels_diff = (fdels_old == 0.) ? 1000. : Math.abs(fdels - fdels_old);
    	    fdels_old = fdels;
    	    } while (dz2 == 1);

	    iter_out=iter_out+1;
	    if (fdels_diff < effDEL*effDEL || iter_out%3000 == 0) {
	        effDEL = effDEL * 2.0;
	        }
	    } while(dz1==1 && dz2 == 0 && iter_out <= 7000);

    for (i=1; i<=n; i++)
        if (m[i] !=0 && sn[i]<sp[i] && sn[i] > sm[i]) m[i] = 2;

    return(1);
}


function Mxmnxg() {

    var bm = [0.,0.,1.], bp=[0.,1.,0.];
    var b = [0.,0.,1.]; 
    var z=[0.,0.,0.]; 
    h1=[0.,0.,0.];
    var i, j, itr = 0;

    Zdef(b, z);

    if (z[2] > 0.) {
	    return 0.;
	    }

    while(itr<=20) {

	    b[1] = (bp[1]+bm[1])/2.;
	    b[2] = (bp[2]+bm[2])/2.;
	    itr = itr + 1;
	    Zdef(b, z);

	    if (z[2] <= 0.) {
    	    bm[1] = b[1];
    	    bm[2] = b[2];
    	    }
	    else {
    	    bp[1] = b[1];
    	    bp[2] = b[2];
    	    }
	    }

    return(b[2]/b[1]);

}

function Zdef(b, z) {

    var sn1 = 0.;
    var i, j;

    for (i=1; i<=2; i++) {
	    z[i]=dz[i];
	    for (j=1; j<=n; j++) {
    	    h1[1]=h[1][j];
    	    h1[2]=h[2][j];
    	    if ( Hb(h1,b,2) > 0. ) sn1 = sm[j];
    	    else sn1 = sp[j];
    	    z[i] = z[i] + sn1*h[i][j];
    	    }
	    }

}

function Hnorm() {

    var lam = 0., xnor = 0.;
    var i, j;

    for (i=1; i<=n; i++) hm1[i] = hm[1][i];
    lam = Hb(hm1,hm1,n);
    lam = Math.sqrt(lam);
    for (i=1; i<=n; i++) hm[1][i]= hm[1][i]/lam;

    for (j=2; j<=mp1; j++) {
	    for (i=1; i<=n; i++) hm1[i] = hm[j][i];
	    xnor = Hb(hm1,hm1,n);
	    xnor = Math.sqrt(xnor);
	    for (i=1; i<=n; i++) hm[j][i]= hm[j][i]/xnor;
	    }

    return (lam);
}


function Epsdef () {

    var deps = [];
    var hmg = 0., ruf = 0.;
    var i, j, ip1;

    for (i=1;i<=n;i++) {
	    for (j=1;j<=mp1;j++) hm1[j] = hm[j][i];
	    hmg = Skabg(hm1,hm1,2,mp1);
	    deps[i] = Math.abs(h[1][i])/hmg;
	    }

    for (i=1;i<=n;i++) {
	    ip1=i+1;
	    for(j=ip1;j<=n;j++) {
    	    if (deps[i]<deps[j]) {
		        ruf = deps[j];
		        deps[j] = deps[i];
		        deps[i] = ruf;
		        }
    	    }
	    }

    EPS = (deps[IDEF] + deps[IDEF+1]) / 2.;

}

function Hb(hh, bb, nn) {

    var hb = 0.;
    var i;

    for (i=1; i<=nn; i++) hb += hh[i]*bb[i];

    return(hb);

}

function Skabg(a, b, i_nn, nn) {

    var ag = 0., skbg = 0.;
    var i;

    for (i=1; i<=nn; i++) ag = ag + a[i]*g[i];

    if (i_nn==1) {
	    skbg = (a[1]-ag)*b[1];
	    for (i=2;i<=nn;i++) {
    	    skbg = skbg + a[i]*b[i];
    	    }
	    return(skbg);
	    }
    else {
	    skbg = (a[1]-ag)*(a[1]-ag);
	    for (i=2;i<=nn;i++) {
    	    skbg = skbg + a[i]*a[i];
    	    }
	    }

    return(Math.sqrt(skbg));

}

-------------------------------------

2020-06-19T21:48:18.835Z: user: vladas
//#pragma sequential

dfltParams = {
    NORM : 1,
    IDEF : 1,
    MXMN : -1,
    DEL : 1.e-5,
    NIU : 0.1,
    EPS : 0.001,
    DZV : 0.2
    };

var NORM, // these must be explicitly defined to receive further values.
    IDEF,
    MXMN,
    DEL,
    NIU,
    EPS,
    DZV,
    NP1,
    MP1;

var rp = true;
params = {};
var dz = [0.,0.,0.];
var g = [], g_save = [];
var g5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]]; // prevent array from a jam by JSON.stringify
var h = [];
var hm = [];
var hm1 = [];
var sm = [], sn = [];
var sn5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var sp = [];
var x = [];
var x5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]]; 
var y = [];
var y5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var m = [];
var z = [];
var b = [];
var h1 = [];
var xg, fg;
var xg5 = [0,0,0,0,0,0,0,0,0];
var fg5 = [0,0,0,0,0,0,0,0,0];
var iter;
var kbh;
var pstr;
var effDEL;
var funcalls = 0, funcallsp;

var res = fs.readFileSync("linit.prm.json");
try {params = JSON.parse(res.toString(), null);}
catch(err){console.log(err.message);}

for (var p in dfltParams) {
    if (!params[p]) params[p] = dfltParams[p];
}

for (var p in params) {
    eval(p +'= params["'+p+'"]');  // I know it's ugly
}

var np1 = NP1;
var mp1 = MP1;
var np11 = np1+1, mp11 = mp1+1 ,i;
var kbh=0;

for (i=1; i<=mp1; i++) g[i]=0.;
g[1]=1.;

readex(true);

pstr = "NORM="+NORM+" IDEF="+IDEF+" MXMN="+MXMN+" DEL="+DEL+" NIU="+NIU+"\n EPS="+EPS+" DZV="+DZV+" MP1="+MP1+" NP1="+NP1;
console.log(pstr);
if (rp) fs.writeFileSync('linit.rpt.jsc', pstr+'\n');

var alfa, alf1;
var lamnor, niuf;
var xgnorm, xgnorm_min;
var xgnorm5 = [0,0,0,0,0,,0,0,0];
var  xg_min;
var ind=0, ind5=[0,0,0,0,0,0,0,0,0];
var i, j, k, k_max, k_min, n, ind_gt_3;
var i_n, i_n5 = [0,0,0,0,0,0,0,0,0];
var it_entr;
var DELsave, DELs;
var coef=[];

var start_time = new Date().getTime();
console.log(start_time);
if (rp) fs.appendFileSync('linit.rpt.jsc', start_time + "\n");
var finish_time;
var elapse_time;

var n=np1-1;
for (i=1;i<=n;i++) hm[1][i] = -1.*MXMN*hm[1][i];

if (NORM == 0) lamnor = Hnorm();
if (EPS == 0) Epsdef();

//#pragma wait
//#pragma cache hm
//#pragma cache sp
//#pragma cache sm
////#pragma cachefuncs
//#pragma sequential
//\\g = g;
//\\g_save = g_save;

iter = 1;
ind=0;
DELsave = DEL;
var EPS5=[EPS,EPS,EPS,EPS,EPS,EPS,EPS,EPS,EPS];
var xgnorm5 = [0,0,0,0,0,0,0,0,0];
var g5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var sn5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var eps = [];
h = [[0],[0],[0]];

cpvec(g, g_save);

if (rp)
    fs.appendFileSync('linit.rpt.jsc', "\nIter(k)      F(g)     (X,g)    //X//g   Ind Nr.       Eps      Alfa  It_entry\n");
console.log("\nIter(k)      F(g)     (X,g)    //X//g   Ind Nr.       Eps      Alfa  It_entry\n");

//#pragma dive
//#pragma sequential
while (iter<=5000 && ind != 3) {

//\\    EPS5 = EPS5; // for lexical analyzer to find EPS5 variable
//\\    eps = eps;
    cpvec(EPS5, eps);

    DEL = DELsave;
    ind=2;

    if (iter == 1) k_max = 1;
    else k_max = 5;

//#pragma wait
//#pragma parallel
//#pragma noautoparvar
//#pragma parvar g5
//#pragma parvar sn5
//#pragma parvar x5
//#pragma parvar y5
//#pragma parvar xg5
//#pragma parvar fg5
//#pragma parvar ind5
//#pragma parvar i_n5
//#pragma parvar xgnorm5
//#pragma parvar EPS5
    for (k=1;k<=k_max;k++) {

        if (!k_min) k_min = 1;
        EPS = eps[k_min]; 

	    effDEL = DEL;
	    it_entr = 0;

//\\        iter = iter;
//\\	    sn = sn;
//\\	    sm = sm;
//\\	    sp = sp;
//\\	    g_save = g_save;
//\\	    DZV = DZV;
//\\	    coef = coef;
	    m = [];
	    x = [];
	    fg=0.;

	    cpvec(g_save, g);

	    while (ind == 2) {

   	        i_n = Minxg(k, sm, sp);

	        for (var ii=1;ii<=n;ii++) {
		        for (j=1;j<=mp1;j++) hm1[j] = hm[j][ii];
		        h[2][ii] = Skabg(x,hm1,1,mp1);
		        }

	        ind=1;
	        DELs = DEL;

	        while (ind == 1) {

                ind = Analys(Mnxgco(), DZV);
		        xgnorm = Skabg(x,x,2,mp1);
		
		        it_entr = it_entr + 1;
		        if (it_entr%500 == 0) {
		            DEL = DEL * 2.0;
		            if (DEL > 0.3) DEL = 0.3;
		            effDEL = DEL;
	    
//		            if (rp)
//			        fs.appendFileSync('linit.rpt.jsc',""+it_entr + "  " + DEL + "\n");
		            console.log(""+it_entr + "  " + DEL);
		            }
		        } // while (ind == 1)
	    
    		DEL=DELs;
	        }  // while (ind == 2)

	        __set_Par_Var_Value('xgnorm5['+k+']', xgnorm, __job, true);

	        if (ind == 3) {
    
		        __set_Par_Var_Value('ind5['+k+']', ind, __job, true);
		        __set_Par_Var_Value('sn5['+k+']', sn, __job, true);
		        }

	        for (i=1; i<=mp1; i++) hm1[i] = hm[i][np1];

	        dz[1] = Hb(hm1,g,mp1);
	        dz[2] = Skabg(hm1,y,1,mp1);
	        alfa = Mxmnxg();
	        if (alfa != 0.) {
		        alf1 = 1.-alfa*y[1];
		        for (i=1; i<=mp1 ; i++) g[i] = alf1*g[i] + alfa*y[i];

	            __set_Par_Var_Value('g5['+k+']', g, __job, true);

	            xg = Hb(x,g,mp1);
	            if (rp)
    		        fs.appendFileSync('linit.rpt.jsc',strf(iter,4)+"("+k+") "+strf(fg,10)+" "+strf(xg,10)+" "+strf(xgnorm,10)+" "+strf(i_n,10)+" "+strf(EPS,10)+" "+strf(alfa,10)+" "+strf(it_entr,6)+"\n");
    	        console.log(strf(iter,4)+"("+k+") "+strf(fg,10)+" "+strf(xg,10)+" "+strf(xgnorm,10)+" "+strf(i_n,10)+" "+strf(EPS,10)+" "+strf(alfa,10)+" "+strf(it_entr,6));

	            niuf = 2.* Math.abs(fg-xg)/ Math.abs(fg+xg);
	            if (niuf < NIU / 2. ) {
		        EPS = EPS*1.25;
		        }

	        __set_Par_Var_Value('EPS5['+k+']', EPS, __job, true);
	        }
	    else {
	        console.log("Problem has no solution");
	        exit(1);
	        }
	    ind = 2;
	    } // end for

//#pragma wait
//#pragma sequential
//\\    eps = eps;
    var xgnorm_min = xgnorm5[1];
    cpvec(EPS5, eps);

    k_min = 1;
    var ki=1;
    for (ki=1; ki<=k_max; ki++) {
	    if (xgnorm5[ki] < xgnorm_min) {
	        xgnorm_min = xgnorm5[ki];
	        k_min = ki;
	        }
	    if (ind5[ki] == 3) {ind=3; k_min=ki; break;}
	    }

	g_save = __get_Par_Var_Value('g5['+k_min+']', false, __job);
	var jitter = (iter % 2 == 0)? 0.99995 : 1.00005;
	for (var ii=1;ii<=np1;ii++) { g_save[ii] = g_save[ii] * jitter; }
    xgnorm = xgnorm5[k_min];
    EPS = EPS5[k_min];    

    fs.appendFileSync('linit.rpt.jsc',"\nk_min="+k_min+"\n");
    console.log("\nk_min="+k_min+"\n");

    if (ind != 3) ind = ind5[k_min];
	else sn = __get_Par_Var_Value('sn5['+k_min+']', false, __job);

    iter=iter+1;
    }

//#pragma sequential
//#wait
if (ind != 3 ) {
    if (rp) fs.appendFileSync('linit.rpt.jsc'," No solution after more than 200 iterations !\n");
    console.log (" No solution after more than 500 iterations !\n");
    }

for (var i=1; i<=np1; i++) hm[1][i] = -1*MXMN*hm[1][i];

finish_time = new Date().getTime();
console.log(finish_time);
if (rp) fs.appendFileSync('linit.rpt.jsc', finish_time + "\n");
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec");
if (rp) fs.appendFileSync('linit.rpt.jsc', "Elapse time: " + elapse_time + " sec\n");

for (i=1;i<=np1-1;i++) {
    if (rp) fs.appendFileSync('linit.rpt.jsc',sn[i]+ "  ");
    if (i%3 == 0) {
        if (rp) fs.appendFileSync('linit.rpt.jsc', "\n");
        }
   }
if (rp) {
    fs.appendFileSync('linit.rpt.jsc', "\nXG="+xg+"   "+"FG="+fg+"\n");
    console.log("\nXG="+xg+"   "+"FG="+fg+"\n");
   }
console.log(" End of solution \n");

// Functions

function max(a,b) {
    return a > b ? a : b; 
}

function min(a,b) {
    return a < b ? a : b; 
}

function readex(fromfile) {

    var i, j;
    var data = {};
    var mp1 = MP1, np1 = NP1;

    if (fromfile) {
	    var res = fs.readFileSync("linit.data.json");
	    data = JSON.parse(res, null);
	    hm = data.hm;
	    sm = data.sm;
	    sp = data.sp;
	    }
}

function cpvec(av, bv) {

    if (!av) return;
    for (var ii=0; ii<av.length; ii++ ) bv[ii] = av[ii];

}

function strf(num, len) {

    var bl = "";
    for (var i=1; i<=len; i++) bl+=" ";
    var ns = num.toString() + bl;
    return ns.substr(0,len);
}


function Minxg(k, sm, sp) {

    var hmg;
    var i, j, i_n;
    coef = [0, 1.18, -1.18, 1.18, -1.18, 1.18, -1.18, 1.18, -1.18, 1.18];

    for (i=1; i<=n ;i++) {
	    for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
	    h[1][i] = Hb(hm1,g,mp1);
	    hmg = Skabg(hm1,hm1,2,mp1);

	    if ( h[1][i] > coef[k]*EPS*hmg ) sn[i] = sm[i];
	    else sn[i] = sp[i];
        }

    for (i=1; i<=mp1; i++) {
	    x[i] = hm[i][np1];
	    for (j=1; j<=n; j++) x[i] = x[i] + hm[i][j]*sn[j];
	    }

    fg = Hb(x,g,mp1);

    i_n=0;

    for (i=1; i<=n; i++) {
	    for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
	    hmg = Skabg(hm1,hm1,2,mp1);
	    m[i]=0;
	    if (Math.abs(h[1][i]) <= (1.04+k*0.2)*EPS*hmg) { // was 0.8+k*0.2
    	    m[i] = 1;
    	    i_n++;
    	    }
	    }

    return(i_n);

}

function Analys(ind1, DZV) {

    var d=0., niuf=0., s=0., xgnorm=0.;
    var i, j, kt, ind = 0;

    xg = Hb(x,g,mp1);
    if (fg + xg != 0. ) {
	    niuf = 2.* Math.abs((fg-xg))/ Math.abs((fg+xg));
	    if (niuf > NIU ) {
    	    ind = 2;
    	    EPS = EPS*0.75;
    	    }
	    }

    if (ind != 2) {
	    kt = 0;
	    if (Math.abs((x[1]-xg)) > DEL ) kt = 1;
	    for (i=2; i<=mp1; i++) {
    	    if (Math.abs(x[i]) > DEL ) kt = 1;
    	    }
	    if ( kt == 0) ind = 3;
	    if ( ind != 3) {
    	    xgnorm = Skabg(x,x,2,mp1);
    	    y[1] = (x[1]-xg)/xgnorm;
    	    for (i=2; i<=mp1; i++) y[i] = x[i]/xgnorm;
    	    for (i=1; i<=n; i++) {
		        for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
		        h[2][i] = Skabg(hm1,y,1,mp1);
		        }
    	    d = 0.;
    	    for (i=1; i<=n; i++) {
		        if ( m[i] != 0 ) {
		            if (h[2][i] > 0.) s = sn[i] - sm[i];
		            else s = sn[i] - sp[i];
		            d = d + h[2][i]*s;
		            }
		        }
    	    d = d/xgnorm;
    	    if (d >= DZV) ind = 1;
    	    }
	    }

    if (ind1 == 0) return(0);
    return(ind);

}

function Mnxgco() {


    var dels = 0., del = 0., temp = 0.;
    var fdels = 0., fdels_old = 0., fdels_diff = 0.;

    var dz1, dz2, i, j;
    var iter_out = 0, iter_in = 0;

    do {
	    dz1 = 0;
	    dz2 = 0;

	    for (i=1; i<=n; i++) if (m[i]>0) m[i] = 2;

	    iter_in = 0;

	    do {

    	    if (dz1 == 0 && dz2 == 1 ) dz1 = 1;
    	    dz2 = 0;
    	    for (i=1; i<=n; i++) {
		        if ( m[i] == 2) {
		            for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
		            temp = Skabg(hm1,hm1,2,mp1);
		            del = Skabg(x,hm1,1,mp1)/(-temp*temp);
		            if (del < 0. ) dels=max(del,(sm[i]-sn[i]));
		            else dels=min(del,(sp[i]-sn[i]));
		            for (j=1; j<=mp1; j++) x[j] += dels*hm1[j];
		            sn[i] += dels;
		            if (sn[i]==sp[i] || sn[i]==sm[i]) {
			            m[i] = 1;
			            dz2 = 1;
			            }
		            }
		        }
    	    iter_in = iter_in + 1;
    	    fdels = Math.abs(dels);
    	    if (fdels < effDEL*effDEL) {
    		    return(1);
    		    }
    	    fdels_diff = (fdels_old == 0.) ? 1000. : Math.abs(fdels - fdels_old);
    	    fdels_old = fdels;
    	    } while (dz2 == 1);

	    iter_out=iter_out+1;
	    if (fdels_diff < effDEL*effDEL || iter_out%3000 == 0) {
	        effDEL = effDEL * 2.0;
	        }
	    } while(dz1==1 && dz2 == 0 && iter_out <= 7000);

    for (i=1; i<=n; i++)
        if (m[i] !=0 && sn[i]<sp[i] && sn[i] > sm[i]) m[i] = 2;

    return(1);
}


function Mxmnxg() {

    var bm = [0.,0.,1.], bp=[0.,1.,0.];
    var b = [0.,0.,1.]; 
    var z=[0.,0.,0.]; 
    h1=[0.,0.,0.];
    var i, j, itr = 0;

    Zdef(b, z);

    if (z[2] > 0.) {
	    return 0.;
	    }

    while(itr<=20) {

	    b[1] = (bp[1]+bm[1])/2.;
	    b[2] = (bp[2]+bm[2])/2.;
	    itr = itr + 1;
	    Zdef(b, z);

	    if (z[2] <= 0.) {
    	    bm[1] = b[1];
    	    bm[2] = b[2];
    	    }
	    else {
    	    bp[1] = b[1];
    	    bp[2] = b[2];
    	    }
	    }

    return(b[2]/b[1]);

}

function Zdef(b, z) {

    var sn1 = 0.;
    var i, j;

    for (i=1; i<=2; i++) {
	    z[i]=dz[i];
	    for (j=1; j<=n; j++) {
    	    h1[1]=h[1][j];
    	    h1[2]=h[2][j];
    	    if ( Hb(h1,b,2) > 0. ) sn1 = sm[j];
    	    else sn1 = sp[j];
    	    z[i] = z[i] + sn1*h[i][j];
    	    }
	    }

}

function Hnorm() {

    var lam = 0., xnor = 0.;
    var i, j;

    for (i=1; i<=n; i++) hm1[i] = hm[1][i];
    lam = Hb(hm1,hm1,n);
    lam = Math.sqrt(lam);
    for (i=1; i<=n; i++) hm[1][i]= hm[1][i]/lam;

    for (j=2; j<=mp1; j++) {
	    for (i=1; i<=n; i++) hm1[i] = hm[j][i];
	    xnor = Hb(hm1,hm1,n);
	    xnor = Math.sqrt(xnor);
	    for (i=1; i<=n; i++) hm[j][i]= hm[j][i]/xnor;
	    }

    return (lam);
}


function Epsdef () {

    var deps = [];
    var hmg = 0., ruf = 0.;
    var i, j, ip1;

    for (i=1;i<=n;i++) {
	    for (j=1;j<=mp1;j++) hm1[j] = hm[j][i];
	    hmg = Skabg(hm1,hm1,2,mp1);
	    deps[i] = Math.abs(h[1][i])/hmg;
	    }

    for (i=1;i<=n;i++) {
	    ip1=i+1;
	    for(j=ip1;j<=n;j++) {
    	    if (deps[i]<deps[j]) {
		        ruf = deps[j];
		        deps[j] = deps[i];
		        deps[i] = ruf;
		        }
    	    }
	    }

    EPS = (deps[IDEF] + deps[IDEF+1]) / 2.;

}

function Hb(hh, bb, nn) {

    var hb = 0.;
    var i;

    for (i=1; i<=nn; i++) hb += hh[i]*bb[i];

    return(hb);

}

function Skabg(a, b, i_nn, nn) {

    var ag = 0., skbg = 0.;
    var i;

    for (i=1; i<=nn; i++) ag = ag + a[i]*g[i];

    if (i_nn==1) {
	    skbg = (a[1]-ag)*b[1];
	    for (i=2;i<=nn;i++) {
    	    skbg = skbg + a[i]*b[i];
    	    }
	    return(skbg);
	    }
    else {
	    skbg = (a[1]-ag)*(a[1]-ag);
	    for (i=2;i<=nn;i++) {
    	    skbg = skbg + a[i]*a[i];
    	    }
	    }

    return(Math.sqrt(skbg));

}

-------------------------------------

2020-06-19T21:52:20.958Z: user: vladas
//#pragma sequential

dfltParams = {
    NORM : 1,
    IDEF : 1,
    MXMN : -1,
    DEL : 1.e-5,
    NIU : 0.1,
    EPS : 0.001,
    DZV : 0.2
    };

var NORM, // these must be explicitly defined to receive further values.
    IDEF,
    MXMN,
    DEL,
    NIU,
    EPS,
    DZV,
    NP1,
    MP1;

var rp = true;
params = {};
var dz = [0.,0.,0.];
var g = [], g_save = [];
var g5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]]; // prevent array from a jam by JSON.stringify
var h = [];
var hm = [];
var hm1 = [];
var sm = [], sn = [];
var sn5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var sp = [];
var x = [];
var x5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]]; 
var y = [];
var y5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var m = [];
var z = [];
var b = [];
var h1 = [];
var xg, fg;
var xg5 = [0,0,0,0,0,0,0,0,0];
var fg5 = [0,0,0,0,0,0,0,0,0];
var iter;
var kbh;
var pstr;
var effDEL;
var funcalls = 0, funcallsp;

var res = fs.readFileSync("linit.prm.json");
try {params = JSON.parse(res.toString(), null);}
catch(err){console.log(err.message);}

for (var p in dfltParams) {
    if (!params[p]) params[p] = dfltParams[p];
}

for (var p in params) {
    eval(p +'= params["'+p+'"]');  // I know it's ugly
}

var np1 = NP1;
var mp1 = MP1;
var np11 = np1+1, mp11 = mp1+1 ,i;
var kbh=0;

for (i=1; i<=mp1; i++) g[i]=0.;
g[1]=1.;

readex(true);

pstr = "NORM="+NORM+" IDEF="+IDEF+" MXMN="+MXMN+" DEL="+DEL+" NIU="+NIU+"\n EPS="+EPS+" DZV="+DZV+" MP1="+MP1+" NP1="+NP1;
console.log(pstr);
if (rp) fs.writeFileSync('linit.rpt.jsc', pstr+'\n');

var alfa, alf1;
var lamnor, niuf;
var xgnorm, xgnorm_min;
var xgnorm5 = [0,0,0,0,0,,0,0,0];
var  xg_min;
var ind=0, ind5=[0,0,0,0,0,0,0,0,0];
var i, j, k, k_max, k_min, n, ind_gt_3;
var i_n, i_n5 = [0,0,0,0,0,0,0,0,0];
var it_entr;
var DELsave, DELs;
var coef=[];

var start_time = new Date().getTime();
console.log(start_time);
if (rp) fs.appendFileSync('linit.rpt.jsc', start_time + "\n");
var finish_time;
var elapse_time;

var n=np1-1;
for (i=1;i<=n;i++) hm[1][i] = -1.*MXMN*hm[1][i];

if (NORM == 0) lamnor = Hnorm();
if (EPS == 0) Epsdef();

//#pragma wait
//#pragma cache hm
//#pragma cache sp
//#pragma cache sm
////#pragma cachefuncs
//#pragma sequential
//\\g = g;
//\\g_save = g_save;

iter = 1;
ind=0;
DELsave = DEL;
var EPS5=[EPS,EPS,EPS,EPS,EPS,EPS,EPS,EPS,EPS];
var xgnorm5 = [0,0,0,0,0,0,0,0,0];
var g5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var sn5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var eps = [];
h = [[0],[0],[0]];

cpvec(g, g_save);

if (rp)
    fs.appendFileSync('linit.rpt.jsc', "\nIter(k)      F(g)     (X,g)    //X//g   Ind Nr.       Eps      Alfa  It_entry\n");
console.log("\nIter(k)      F(g)     (X,g)    //X//g   Ind Nr.       Eps      Alfa  It_entry\n");

//#pragma dive
//#pragma sequential
while (iter<=5000 && ind != 3) {

//\\    EPS5 = EPS5; // for lexical analyzer to find EPS5 variable
//\\    eps = eps;
    cpvec(EPS5, eps);

    DEL = DELsave;
    ind=2;

    if (iter == 1) k_max = 1;
    else k_max = 5;

//#pragma wait
//#pragma parallel
//#pragma noautoparvar
//#pragma parvar g5
//#pragma parvar sn5
//#pragma parvar x5
//#pragma parvar y5
//#pragma parvar xg5
//#pragma parvar fg5
//#pragma parvar ind5
//#pragma parvar i_n5
//#pragma parvar xgnorm5
//#pragma parvar EPS5
    for (k=1;k<=k_max;k++) {

        if (!k_min) k_min = 1;
        EPS = eps[k_min]; 

	    effDEL = DEL;
	    it_entr = 0;

//\\        iter = iter;
//\\	    sn = sn;
//\\	    sm = sm;
//\\	    sp = sp;
//\\	    g_save = g_save;
//\\	    DZV = DZV;
//\\	    coef = coef;
	    m = [];
	    x = [];
	    fg=0.;

	    cpvec(g_save, g);

	    while (ind == 2) {

   	        i_n = Minxg(k, sm, sp);

	        for (var ii=1;ii<=n;ii++) {
		        for (j=1;j<=mp1;j++) hm1[j] = hm[j][ii];
		        h[2][ii] = Skabg(x,hm1,1,mp1);
		        }

	        ind=1;
	        DELs = DEL;

	        while (ind == 1) {

                ind = Analys(Mnxgco(), DZV);
		        xgnorm = Skabg(x,x,2,mp1);
		
		        it_entr = it_entr + 1;
		        if (it_entr%500 == 0) {
		            DEL = DEL * 2.0;
		            if (DEL > 0.3) DEL = 0.3;
		            effDEL = DEL;
	    
//		            if (rp)
//			        fs.appendFileSync('linit.rpt.jsc',""+it_entr + "  " + DEL + "\n");
		            console.log(""+it_entr + "  " + DEL);
		            }
		        } // while (ind == 1)
	    
    		DEL=DELs;
	        }  // while (ind == 2)

	        __set_Par_Var_Value('xgnorm5['+k+']', xgnorm, __job, true);

	        if (ind == 3) {
    
		        __set_Par_Var_Value('ind5['+k+']', ind, __job, true);
		        __set_Par_Var_Value('sn5['+k+']', sn, __job, true);
		        }

	        for (i=1; i<=mp1; i++) hm1[i] = hm[i][np1];

	        dz[1] = Hb(hm1,g,mp1);
	        dz[2] = Skabg(hm1,y,1,mp1);
	        alfa = Mxmnxg();
	        if (alfa != 0.) {
		        alf1 = 1.-alfa*y[1];
		        for (i=1; i<=mp1 ; i++) g[i] = alf1*g[i] + alfa*y[i];

	            __set_Par_Var_Value('g5['+k+']', g, __job, true);

	            xg = Hb(x,g,mp1);
	            if (rp)
    		        fs.appendFileSync('linit.rpt.jsc',strf(iter,4)+"("+k+") "+strf(fg,10)+" "+strf(xg,10)+" "+strf(xgnorm,10)+" "+strf(i_n,10)+" "+strf(EPS,10)+" "+strf(alfa,10)+" "+strf(it_entr,6)+"\n");
    	        console.log(strf(iter,4)+"("+k+") "+strf(fg,10)+" "+strf(xg,10)+" "+strf(xgnorm,10)+" "+strf(i_n,10)+" "+strf(EPS,10)+" "+strf(alfa,10)+" "+strf(it_entr,6));

	            niuf = 2.* Math.abs(fg-xg)/ Math.abs(fg+xg);
	            if (niuf < NIU / 2. ) {
		        EPS = EPS*1.25;
		        }

	        __set_Par_Var_Value('EPS5['+k+']', EPS, __job, true);
	        }
	    else {
	        console.log("Problem has no solution");
	        exit(1);
	        }
	    ind = 2;
	    } // end for

//#pragma wait
//#pragma sequential
//\\    eps = eps;
    var xgnorm_min = xgnorm5[1];
    cpvec(EPS5, eps);

    k_min = 1;
    var ki=1;
    for (ki=1; ki<=k_max; ki++) {
	    if (xgnorm5[ki] < xgnorm_min) {
	        xgnorm_min = xgnorm5[ki];
	        k_min = ki;
	        }
	    if (ind5[ki] == 3) {ind=3; k_min=ki; break;}
	    }

	g_save = __get_Par_Var_Value('g5['+k_min+']', false, __job);
	var jitter = (iter % 2 == 0)? 0.99995 : 1.00005;
	for (var ii=1;ii<=np1;ii++) { g_save[ii] = g_save[ii] * jitter; }
    xgnorm = xgnorm5[k_min];
    EPS = EPS5[k_min];    

    fs.appendFileSync('linit.rpt.jsc',"\nk_min="+k_min+"\n");
    console.log("\nk_min="+k_min+"\n");

    if (ind != 3) ind = ind5[k_min];
	else sn = __get_Par_Var_Value('sn5['+k_min+']', false, __job);

    iter=iter+1;
    }

//#pragma sequential
//#wait
if (ind != 3 ) {
    if (rp) fs.appendFileSync('linit.rpt.jsc'," No solution after more than 200 iterations !\n");
    console.log (" No solution after more than 500 iterations !\n");
    }

for (var i=1; i<=np1; i++) hm[1][i] = -1*MXMN*hm[1][i];

finish_time = new Date().getTime();
console.log(finish_time);
if (rp) fs.appendFileSync('linit.rpt.jsc', finish_time + "\n");
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec");
if (rp) fs.appendFileSync('linit.rpt.jsc', "Elapse time: " + elapse_time + " sec\n");

for (i=1;i<=np1-1;i++) {
    if (rp) fs.appendFileSync('linit.rpt.jsc',sn[i]+ "  ");
    if (i%3 == 0) {
        if (rp) fs.appendFileSync('linit.rpt.jsc', "\n");
        }
   }
if (rp) {
    fs.appendFileSync('linit.rpt.jsc', "\nXG="+xg+"   "+"FG="+fg+"\n");
    console.log("\nXG="+xg+"   "+"FG="+fg+"\n");
   }
console.log(" End of solution \n");

// Functions

function max(a,b) {
    return a > b ? a : b; 
}

function min(a,b) {
    return a < b ? a : b; 
}

function readex(fromfile) {

    var i, j;
    var data = {};
    var mp1 = MP1, np1 = NP1;

    if (fromfile) {
	    var res = fs.readFileSync("linit.data.json");
	    data = JSON.parse(res, null);
	    hm = data.hm;
	    sm = data.sm;
	    sp = data.sp;
	    }
}

function cpvec(av, bv) {

    if (!av) return;
    for (var ii=0; ii<av.length; ii++ ) bv[ii] = av[ii];

}

function strf(num, len) {

    var bl = "";
    for (var i=1; i<=len; i++) bl+=" ";
    var ns = num.toString() + bl;
    return ns.substr(0,len);
}


function Minxg(k, sm, sp) {

    var hmg;
    var i, j, i_n;
    coef = [0, 1.18, -1.18, 1.18, -1.18, 1.18, -1.18, 1.18, -1.18, 1.18];

    for (i=1; i<=n ;i++) {
	    for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
	    h[1][i] = Hb(hm1,g,mp1);
	    hmg = Skabg(hm1,hm1,2,mp1);

	    if ( h[1][i] > coef[k]*EPS*hmg ) sn[i] = sm[i];
	    else sn[i] = sp[i];
        }

    for (i=1; i<=mp1; i++) {
	    x[i] = hm[i][np1];
	    for (j=1; j<=n; j++) x[i] = x[i] + hm[i][j]*sn[j];
	    }

    fg = Hb(x,g,mp1);

    i_n=0;

    for (i=1; i<=n; i++) {
	    for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
	    hmg = Skabg(hm1,hm1,2,mp1);
	    m[i]=0;
	    if (Math.abs(h[1][i]) <= (1.04+k*0.2)*EPS*hmg) { // was 0.8+k*0.2
    	    m[i] = 1;
    	    i_n++;
    	    }
	    }

    return(i_n);

}

function Analys(ind1, DZV) {

    var d=0., niuf=0., s=0., xgnorm=0.;
    var i, j, kt, ind = 0;

    xg = Hb(x,g,mp1);
    if (fg + xg != 0. ) {
	    niuf = 2.* Math.abs((fg-xg))/ Math.abs((fg+xg));
	    if (niuf > NIU ) {
    	    ind = 2;
    	    EPS = EPS*0.75;
    	    }
	    }

    if (ind != 2) {
	    kt = 0;
	    if (Math.abs((x[1]-xg)) > DEL ) kt = 1;
	    for (i=2; i<=mp1; i++) {
    	    if (Math.abs(x[i]) > DEL ) kt = 1;
    	    }
	    if ( kt == 0) ind = 3;
	    if ( ind != 3) {
    	    xgnorm = Skabg(x,x,2,mp1);
    	    y[1] = (x[1]-xg)/xgnorm;
    	    for (i=2; i<=mp1; i++) y[i] = x[i]/xgnorm;
    	    for (i=1; i<=n; i++) {
		        for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
		        h[2][i] = Skabg(hm1,y,1,mp1);
		        }
    	    d = 0.;
    	    for (i=1; i<=n; i++) {
		        if ( m[i] != 0 ) {
		            if (h[2][i] > 0.) s = sn[i] - sm[i];
		            else s = sn[i] - sp[i];
		            d = d + h[2][i]*s;
		            }
		        }
    	    d = d/xgnorm;
    	    if (d >= DZV) ind = 1;
    	    }
	    }

    if (ind1 == 0) return(0);
    return(ind);

}

function Mnxgco() {


    var dels = 0., del = 0., temp = 0.;
    var fdels = 0., fdels_old = 0., fdels_diff = 0.;

    var dz1, dz2, i, j;
    var iter_out = 0, iter_in = 0;

    do {
	    dz1 = 0;
	    dz2 = 0;

	    for (i=1; i<=n; i++) if (m[i]>0) m[i] = 2;

	    iter_in = 0;

	    do {

    	    if (dz1 == 0 && dz2 == 1 ) dz1 = 1;
    	    dz2 = 0;
    	    for (i=1; i<=n; i++) {
		        if ( m[i] == 2) {
		            for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
		            temp = Skabg(hm1,hm1,2,mp1);
		            del = Skabg(x,hm1,1,mp1)/(-temp*temp);
		            if (del < 0. ) dels=max(del,(sm[i]-sn[i]));
		            else dels=min(del,(sp[i]-sn[i]));
		            for (j=1; j<=mp1; j++) x[j] += dels*hm1[j];
		            sn[i] += dels;
		            if (sn[i]==sp[i] || sn[i]==sm[i]) {
			            m[i] = 1;
			            dz2 = 1;
			            }
		            }
		        }
    	    iter_in = iter_in + 1;
    	    fdels = Math.abs(dels);
    	    if (fdels < effDEL*effDEL) {
    		    return(1);
    		    }
    	    fdels_diff = (fdels_old == 0.) ? 1000. : Math.abs(fdels - fdels_old);
    	    fdels_old = fdels;
    	    } while (dz2 == 1);

	    iter_out=iter_out+1;
	    if (fdels_diff < effDEL*effDEL || iter_out%3000 == 0) {
	        effDEL = effDEL * 2.0;
	        }
	    } while(dz1==1 && dz2 == 0 && iter_out <= 7000);

    for (i=1; i<=n; i++)
        if (m[i] !=0 && sn[i]<sp[i] && sn[i] > sm[i]) m[i] = 2;

    return(1);
}


function Mxmnxg() {

    var bm = [0.,0.,1.], bp=[0.,1.,0.];
    var b = [0.,0.,1.]; 
    var z=[0.,0.,0.]; 
    h1=[0.,0.,0.];
    var i, j, itr = 0;

    Zdef(b, z);

    if (z[2] > 0.) {
	    return 0.;
	    }

    while(itr<=20) {

	    b[1] = (bp[1]+bm[1])/2.;
	    b[2] = (bp[2]+bm[2])/2.;
	    itr = itr + 1;
	    Zdef(b, z);

	    if (z[2] <= 0.) {
    	    bm[1] = b[1];
    	    bm[2] = b[2];
    	    }
	    else {
    	    bp[1] = b[1];
    	    bp[2] = b[2];
    	    }
	    }

    return(b[2]/b[1]);

}

function Zdef(b, z) {

    var sn1 = 0.;
    var i, j;

    for (i=1; i<=2; i++) {
	    z[i]=dz[i];
	    for (j=1; j<=n; j++) {
    	    h1[1]=h[1][j];
    	    h1[2]=h[2][j];
    	    if ( Hb(h1,b,2) > 0. ) sn1 = sm[j];
    	    else sn1 = sp[j];
    	    z[i] = z[i] + sn1*h[i][j];
    	    }
	    }

}

function Hnorm() {

    var lam = 0., xnor = 0.;
    var i, j;

    for (i=1; i<=n; i++) hm1[i] = hm[1][i];
    lam = Hb(hm1,hm1,n);
    lam = Math.sqrt(lam);
    for (i=1; i<=n; i++) hm[1][i]= hm[1][i]/lam;

    for (j=2; j<=mp1; j++) {
	    for (i=1; i<=n; i++) hm1[i] = hm[j][i];
	    xnor = Hb(hm1,hm1,n);
	    xnor = Math.sqrt(xnor);
	    for (i=1; i<=n; i++) hm[j][i]= hm[j][i]/xnor;
	    }

    return (lam);
}


function Epsdef () {

    var deps = [];
    var hmg = 0., ruf = 0.;
    var i, j, ip1;

    for (i=1;i<=n;i++) {
	    for (j=1;j<=mp1;j++) hm1[j] = hm[j][i];
	    hmg = Skabg(hm1,hm1,2,mp1);
	    deps[i] = Math.abs(h[1][i])/hmg;
	    }

    for (i=1;i<=n;i++) {
	    ip1=i+1;
	    for(j=ip1;j<=n;j++) {
    	    if (deps[i]<deps[j]) {
		        ruf = deps[j];
		        deps[j] = deps[i];
		        deps[i] = ruf;
		        }
    	    }
	    }

    EPS = (deps[IDEF] + deps[IDEF+1]) / 2.;

}

function Hb(hh, bb, nn) {

    var hb = 0.;
    var i;

    for (i=1; i<=nn; i++) hb += hh[i]*bb[i];

    return(hb);

}

function Skabg(a, b, i_nn, nn) {

    var ag = 0., skbg = 0.;
    var i;

    for (i=1; i<=nn; i++) ag = ag + a[i]*g[i];

    if (i_nn==1) {
	    skbg = (a[1]-ag)*b[1];
	    for (i=2;i<=nn;i++) {
    	    skbg = skbg + a[i]*b[i];
    	    }
	    return(skbg);
	    }
    else {
	    skbg = (a[1]-ag)*(a[1]-ag);
	    for (i=2;i<=nn;i++) {
    	    skbg = skbg + a[i]*a[i];
    	    }
	    }

    return(Math.sqrt(skbg));

}

-------------------------------------

2020-06-19T22:21:37.199Z: user: vladas
//#pragma sequential

dfltParams = {
    NORM : 1,
    IDEF : 1,
    MXMN : -1,
    DEL : 1.e-5,
    NIU : 0.1,
    EPS : 0.001,
    DZV : 0.2
    };

var NORM, // these must be explicitly defined to receive further values.
    IDEF,
    MXMN,
    DEL,
    NIU,
    EPS,
    DZV,
    NP1,
    MP1;

var rp = true;
params = {};
var dz = [0.,0.,0.];
var g = [], g_save = [];
var g5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]]; // prevent array from a jam by JSON.stringify
var h = [];
var hm = [];
var hm1 = [];
var sm = [], sn = [];
var sn5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var sp = [];
var x = [];
var x5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]]; 
var y = [];
var y5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var m = [];
var z = [];
var b = [];
var h1 = [];
var xg, fg;
var xg5 = [0,0,0,0,0,0,0,0,0];
var fg5 = [0,0,0,0,0,0,0,0,0];
var iter;
var kbh;
var pstr;
var effDEL;
var funcalls = 0, funcallsp;

var res = fs.readFileSync("linit.prm.json");
try {params = JSON.parse(res.toString(), null);}
catch(err){console.log(err.message);}

for (var p in dfltParams) {
    if (!params[p]) params[p] = dfltParams[p];
}

for (var p in params) {
    eval(p +'= params["'+p+'"]');  // I know it's ugly
}

var np1 = NP1;
var mp1 = MP1;
var np11 = np1+1, mp11 = mp1+1 ,i;
var kbh=0;

for (i=1; i<=mp1; i++) g[i]=0.;
g[1]=1.;

readex(true);

pstr = "NORM="+NORM+" IDEF="+IDEF+" MXMN="+MXMN+" DEL="+DEL+" NIU="+NIU+"\n EPS="+EPS+" DZV="+DZV+" MP1="+MP1+" NP1="+NP1;
console.log(pstr);
if (rp) fs.writeFileSync('linit.rpt.jsc', pstr+'\n');

var alfa, alf1;
var lamnor, niuf;
var xgnorm, xgnorm_min;
var xgnorm5 = [0,0,0,0,0,,0,0,0];
var  xg_min;
var ind=0, ind5=[0,0,0,0,0,0,0,0,0];
var i, j, k, k_max, k_min, n, ind_gt_3;
var i_n, i_n5 = [0,0,0,0,0,0,0,0,0];
var it_entr;
var DELsave, DELs;
var coef=[];

var start_time = new Date().getTime();
console.log(start_time);
if (rp) fs.appendFileSync('linit.rpt.jsc', start_time + "\n");
var finish_time;
var elapse_time;

var n=np1-1;
for (i=1;i<=n;i++) hm[1][i] = -1.*MXMN*hm[1][i];

if (NORM == 0) lamnor = Hnorm();
if (EPS == 0) Epsdef();

//#pragma wait
//#pragma cache hm
//#pragma cache sp
//#pragma cache sm
////#pragma cachefuncs
//#pragma sequential
iter = 1;
ind=0;
DELsave = DEL;
var EPS5=[EPS,EPS,EPS,EPS,EPS,EPS,EPS,EPS,EPS];
var xgnorm5 = [0,0,0,0,0,0,0,0,0];
var g5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var sn5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var eps = [];
h = [[0],[0],[0]];

cpvec(g, g_save);

if (rp)
    fs.appendFileSync('linit.rpt.jsc', "\nIter(k)      F(g)     (X,g)    //X//g   Ind Nr.       Eps      Alfa  It_entry\n");
console.log("\nIter(k)      F(g)     (X,g)    //X//g   Ind Nr.       Eps      Alfa  It_entry\n");

//#pragma dive
//#pragma sequential
while (iter<=5000 && ind != 3) {

    cpvec(EPS5, eps);

    DEL = DELsave;
    ind=2;

    if (iter == 1) k_max = 1;
    else k_max = 5;

//#pragma wait
//#pragma parallel
//#pragma noautoparvar
//#pragma parvar g5
//#pragma parvar sn5
//#pragma parvar x5
//#pragma parvar y5
//#pragma parvar xg5
//#pragma parvar fg5
//#pragma parvar ind5
//#pragma parvar i_n5
//#pragma parvar xgnorm5
//#pragma parvar EPS5
    for (k=1;k<=k_max;k++) {

        if (!k_min) k_min = 1;
        EPS = eps[k_min]; 

	    effDEL = DEL;
	    it_entr = 0;

	    m = [];
	    x = [];
	    fg=0.;

	    cpvec(g_save, g);

	    while (ind == 2) {

   	        i_n = Minxg(k, sm, sp);

	        for (var ii=1;ii<=n;ii++) {
		        for (j=1;j<=mp1;j++) hm1[j] = hm[j][ii];
		        h[2][ii] = Skabg(x,hm1,1,mp1);
		        }

	        ind=1;
	        DELs = DEL;

	        while (ind == 1) {

                ind = Analys(Mnxgco(), DZV);
		        xgnorm = Skabg(x,x,2,mp1);
		
		        it_entr = it_entr + 1;
		        if (it_entr%500 == 0) {
		            DEL = DEL * 2.0;
		            if (DEL > 0.3) DEL = 0.3;
		            effDEL = DEL;
	    
//		            if (rp)
//			        fs.appendFileSync('linit.rpt.jsc',""+it_entr + "  " + DEL + "\n");
		            console.log(""+it_entr + "  " + DEL);
		            }
		        } // while (ind == 1)
	    
    		DEL=DELs;
	        }  // while (ind == 2)

	        __set_Par_Var_Value('xgnorm5['+k+']', xgnorm, __job, true);

	        if (ind == 3) {
    
		        __set_Par_Var_Value('ind5['+k+']', ind, __job, true);
		        __set_Par_Var_Value('sn5['+k+']', sn, __job, true);
		        }

	        for (i=1; i<=mp1; i++) hm1[i] = hm[i][np1];

	        dz[1] = Hb(hm1,g,mp1);
	        dz[2] = Skabg(hm1,y,1,mp1);
	        alfa = Mxmnxg();
	        if (alfa != 0.) {
		        alf1 = 1.-alfa*y[1];
		        for (i=1; i<=mp1 ; i++) g[i] = alf1*g[i] + alfa*y[i];

	            __set_Par_Var_Value('g5['+k+']', g, __job, true);

	            xg = Hb(x,g,mp1);
	            if (rp)
    		        fs.appendFileSync('linit.rpt.jsc',strf(iter,4)+"("+k+") "+strf(fg,10)+" "+strf(xg,10)+" "+strf(xgnorm,10)+" "+strf(i_n,10)+" "+strf(EPS,10)+" "+strf(alfa,10)+" "+strf(it_entr,6)+"\n");
    	        console.log(strf(iter,4)+"("+k+") "+strf(fg,10)+" "+strf(xg,10)+" "+strf(xgnorm,10)+" "+strf(i_n,10)+" "+strf(EPS,10)+" "+strf(alfa,10)+" "+strf(it_entr,6));

	            niuf = 2.* Math.abs(fg-xg)/ Math.abs(fg+xg);
	            if (niuf < NIU / 2. ) {
		        EPS = EPS*1.25;
		        }

	        __set_Par_Var_Value('EPS5['+k+']', EPS, __job, true);
	        }
	    else {
	        console.log("Problem has no solution");
	        exit(1);
	        }
	    ind = 2;
	    } // end for

//#pragma wait
//#pragma sequential
    var xgnorm_min = xgnorm5[1];
    cpvec(EPS5, eps);

    k_min = 1;
    var ki=1;
    for (ki=1; ki<=k_max; ki++) {
	    if (xgnorm5[ki] < xgnorm_min) {
	        xgnorm_min = xgnorm5[ki];
	        k_min = ki;
	        }
	    if (ind5[ki] == 3) {ind=3; k_min=ki; break;}
	    }

	g_save = __get_Par_Var_Value('g5['+k_min+']', false, __job);
    xgnorm = xgnorm5[k_min];
    EPS = EPS5[k_min];    

    fs.appendFileSync('linit.rpt.jsc',"\nk_min="+k_min+"\n");
    console.log("\nk_min="+k_min+"\n");

    if (ind != 3) ind = ind5[k_min];
	else sn = __get_Par_Var_Value('sn5['+k_min+']', false, __job);

    iter=iter+1;
    }

//#pragma sequential
//#wait
if (ind != 3 ) {
    if (rp) fs.appendFileSync('linit.rpt.jsc'," No solution after more than 200 iterations !\n");
    console.log (" No solution after more than 500 iterations !\n");
    }

for (var i=1; i<=np1; i++) hm[1][i] = -1*MXMN*hm[1][i];

finish_time = new Date().getTime();
console.log(finish_time);
if (rp) fs.appendFileSync('linit.rpt.jsc', finish_time + "\n");
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec");
if (rp) fs.appendFileSync('linit.rpt.jsc', "Elapse time: " + elapse_time + " sec\n");

for (i=1;i<=np1-1;i++) {
    if (rp) fs.appendFileSync('linit.rpt.jsc',sn[i]+ "  ");
    if (i%3 == 0) {
        if (rp) fs.appendFileSync('linit.rpt.jsc', "\n");
        }
   }
if (rp) {
    fs.appendFileSync('linit.rpt.jsc', "\nXG="+xg+"   "+"FG="+fg+"\n");
    console.log("\nXG="+xg+"   "+"FG="+fg+"\n");
   }
console.log(" End of solution \n");

// Functions

function max(a,b) {
    return a > b ? a : b; 
}

function min(a,b) {
    return a < b ? a : b; 
}

function readex(fromfile) {

    var i, j;
    var data = {};
    var mp1 = MP1, np1 = NP1;

    if (fromfile) {
	    var res = fs.readFileSync("linit.data.json");
	    data = JSON.parse(res, null);
	    hm = data.hm;
	    sm = data.sm;
	    sp = data.sp;
	    }
}

function cpvec(av, bv) {

    if (!av) return;
    for (var ii=0; ii<av.length; ii++ ) bv[ii] = av[ii];

}

function strf(num, len) {

    var bl = "";
    for (var i=1; i<=len; i++) bl+=" ";
    var ns = num.toString() + bl;
    return ns.substr(0,len);
}


function Minxg(k, sm, sp) {

    var hmg;
    var i, j, i_n;
    coef = [0, 1.12, -1.18, 1.18, -1.18, 1.18, -1.18, 1.18, -1.18, 1.18];

    for (i=1; i<=n ;i++) {
	    for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
	    h[1][i] = Hb(hm1,g,mp1);
	    hmg = Skabg(hm1,hm1,2,mp1);

	    if ( h[1][i] > coef[k]*EPS*hmg ) sn[i] = sm[i];
	    else sn[i] = sp[i];
        }

    for (i=1; i<=mp1; i++) {
	    x[i] = hm[i][np1];
	    for (j=1; j<=n; j++) x[i] = x[i] + hm[i][j]*sn[j];
	    }

    fg = Hb(x,g,mp1);

    i_n=0;

    for (i=1; i<=n; i++) {
	    for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
	    hmg = Skabg(hm1,hm1,2,mp1);
	    m[i]=0;
	    if (Math.abs(h[1][i]) <= (1.04+k*0.18)*EPS*hmg) { // was 0.8+k*0.2
    	    m[i] = 1;
    	    i_n++;
    	    }
	    }

    return(i_n);

}

function Analys(ind1, DZV) {

    var d=0., niuf=0., s=0., xgnorm=0.;
    var i, j, kt, ind = 0;

    xg = Hb(x,g,mp1);
    if (fg + xg != 0. ) {
	    niuf = 2.* Math.abs((fg-xg))/ Math.abs((fg+xg));
	    if (niuf > NIU ) {
    	    ind = 2;
    	    EPS = EPS*0.75;
    	    }
	    }

    if (ind != 2) {
	    kt = 0;
	    if (Math.abs((x[1]-xg)) > DEL ) kt = 1;
	    for (i=2; i<=mp1; i++) {
    	    if (Math.abs(x[i]) > DEL ) kt = 1;
    	    }
	    if ( kt == 0) ind = 3;
	    if ( ind != 3) {
    	    xgnorm = Skabg(x,x,2,mp1);
    	    y[1] = (x[1]-xg)/xgnorm;
    	    for (i=2; i<=mp1; i++) y[i] = x[i]/xgnorm;
    	    for (i=1; i<=n; i++) {
		        for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
		        h[2][i] = Skabg(hm1,y,1,mp1);
		        }
    	    d = 0.;
    	    for (i=1; i<=n; i++) {
		        if ( m[i] != 0 ) {
		            if (h[2][i] > 0.) s = sn[i] - sm[i];
		            else s = sn[i] - sp[i];
		            d = d + h[2][i]*s;
		            }
		        }
    	    d = d/xgnorm;
    	    if (d >= DZV) ind = 1;
    	    }
	    }

    if (ind1 == 0) return(0);
    return(ind);

}

function Mnxgco() {


    var dels = 0., del = 0., temp = 0.;
    var fdels = 0., fdels_old = 0., fdels_diff = 0.;

    var dz1, dz2, i, j;
    var iter_out = 0, iter_in = 0;

    do {
	    dz1 = 0;
	    dz2 = 0;

	    for (i=1; i<=n; i++) if (m[i]>0) m[i] = 2;

	    iter_in = 0;

	    do {

    	    if (dz1 == 0 && dz2 == 1 ) dz1 = 1;
    	    dz2 = 0;
    	    for (i=1; i<=n; i++) {
		        if ( m[i] == 2) {
		            for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
		            temp = Skabg(hm1,hm1,2,mp1);
		            del = Skabg(x,hm1,1,mp1)/(-temp*temp);
		            if (del < 0. ) dels=max(del,(sm[i]-sn[i]));
		            else dels=min(del,(sp[i]-sn[i]));
		            for (j=1; j<=mp1; j++) x[j] += dels*hm1[j];
		            sn[i] += dels;
		            if (sn[i]==sp[i] || sn[i]==sm[i]) {
			            m[i] = 1;
			            dz2 = 1;
			            }
		            }
		        }
    	    iter_in = iter_in + 1;
    	    fdels = Math.abs(dels);
    	    if (fdels < effDEL*effDEL) {
    		    return(1);
    		    }
    	    fdels_diff = (fdels_old == 0.) ? 1000. : Math.abs(fdels - fdels_old);
    	    fdels_old = fdels;
    	    } while (dz2 == 1);

	    iter_out=iter_out+1;
	    if (fdels_diff < effDEL*effDEL || iter_out%3000 == 0) {
	        effDEL = effDEL * 2.0;
	        }
	    } while(dz1==1 && dz2 == 0 && iter_out <= 7000);

    for (i=1; i<=n; i++)
        if (m[i] !=0 && sn[i]<sp[i] && sn[i] > sm[i]) m[i] = 2;

    return(1);
}


function Mxmnxg() {

    var bm = [0.,0.,1.], bp=[0.,1.,0.];
    var b = [0.,0.,1.]; 
    var z=[0.,0.,0.]; 
    h1=[0.,0.,0.];
    var i, j, itr = 0;

    Zdef(b, z);

    if (z[2] > 0.) {
	    return 0.;
	    }

    while(itr<=20) {

	    b[1] = (bp[1]+bm[1])/2.;
	    b[2] = (bp[2]+bm[2])/2.;
	    itr = itr + 1;
	    Zdef(b, z);

	    if (z[2] <= 0.) {
    	    bm[1] = b[1];
    	    bm[2] = b[2];
    	    }
	    else {
    	    bp[1] = b[1];
    	    bp[2] = b[2];
    	    }
	    }

    return(b[2]/b[1]);

}

function Zdef(b, z) {

    var sn1 = 0.;
    var i, j;

    for (i=1; i<=2; i++) {
	    z[i]=dz[i];
	    for (j=1; j<=n; j++) {
    	    h1[1]=h[1][j];
    	    h1[2]=h[2][j];
    	    if ( Hb(h1,b,2) > 0. ) sn1 = sm[j];
    	    else sn1 = sp[j];
    	    z[i] = z[i] + sn1*h[i][j];
    	    }
	    }

}

function Hnorm() {

    var lam = 0., xnor = 0.;
    var i, j;

    for (i=1; i<=n; i++) hm1[i] = hm[1][i];
    lam = Hb(hm1,hm1,n);
    lam = Math.sqrt(lam);
    for (i=1; i<=n; i++) hm[1][i]= hm[1][i]/lam;

    for (j=2; j<=mp1; j++) {
	    for (i=1; i<=n; i++) hm1[i] = hm[j][i];
	    xnor = Hb(hm1,hm1,n);
	    xnor = Math.sqrt(xnor);
	    for (i=1; i<=n; i++) hm[j][i]= hm[j][i]/xnor;
	    }

    return (lam);
}


function Epsdef () {

    var deps = [];
    var hmg = 0., ruf = 0.;
    var i, j, ip1;

    for (i=1;i<=n;i++) {
	    for (j=1;j<=mp1;j++) hm1[j] = hm[j][i];
	    hmg = Skabg(hm1,hm1,2,mp1);
	    deps[i] = Math.abs(h[1][i])/hmg;
	    }

    for (i=1;i<=n;i++) {
	    ip1=i+1;
	    for(j=ip1;j<=n;j++) {
    	    if (deps[i]<deps[j]) {
		        ruf = deps[j];
		        deps[j] = deps[i];
		        deps[i] = ruf;
		        }
    	    }
	    }

    EPS = (deps[IDEF] + deps[IDEF+1]) / 2.;

}

function Hb(hh, bb, nn) {

    var hb = 0.;
    var i;

    for (i=1; i<=nn; i++) hb += hh[i]*bb[i];

    return(hb);

}

function Skabg(a, b, i_nn, nn) {

    var ag = 0., skbg = 0.;
    var i;

    for (i=1; i<=nn; i++) ag = ag + a[i]*g[i];

    if (i_nn==1) {
	    skbg = (a[1]-ag)*b[1];
	    for (i=2;i<=nn;i++) {
    	    skbg = skbg + a[i]*b[i];
    	    }
	    return(skbg);
	    }
    else {
	    skbg = (a[1]-ag)*(a[1]-ag);
	    for (i=2;i<=nn;i++) {
    	    skbg = skbg + a[i]*a[i];
    	    }
	    }

    return(Math.sqrt(skbg));

}

-------------------------------------

2020-06-20T00:27:37.140Z: user: vladas
//#pragma sequential

dfltParams = {
    NORM : 1,
    IDEF : 1,
    MXMN : -1,
    DEL : 1.e-5,
    NIU : 0.1,
    EPS : 0.001,
    DZV : 0.2
    };

var NORM, // these must be explicitly defined to receive further values.
    IDEF,
    MXMN,
    DEL,
    NIU,
    EPS,
    DZV,
    NP1,
    MP1;

var rp = true;
params = {};
var dz = [0.,0.,0.];
var g = [], g_save = [];
var g5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]]; // prevent array from a jam by JSON.stringify
var h = [];
var hm = [];
var hm1 = [];
var sm = [], sn = [];
var sn5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var sp = [];
var x = [];
var x5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]]; 
var y = [];
var y5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var m = [];
var z = [];
var b = [];
var h1 = [];
var xg, fg;
var xg5 = [0,0,0,0,0,0,0,0,0];
var fg5 = [0,0,0,0,0,0,0,0,0];
var iter;
var kbh;
var pstr;
var effDEL;
var funcalls = 0, funcallsp;

var res = fs.readFileSync("linit.prm.json");
try {params = JSON.parse(res.toString(), null);}
catch(err){console.log(err.message);}

for (var p in dfltParams) {
    if (!params[p]) params[p] = dfltParams[p];
}

for (var p in params) {
    eval(p +'= params["'+p+'"]');  // I know it's ugly
}

var np1 = NP1;
var mp1 = MP1;
var np11 = np1+1, mp11 = mp1+1 ,i;
var kbh=0;

for (i=1; i<=mp1; i++) g[i]=0.;
g[1]=1.;

readex(true);

pstr = "NORM="+NORM+" IDEF="+IDEF+" MXMN="+MXMN+" DEL="+DEL+" NIU="+NIU+"\n EPS="+EPS+" DZV="+DZV+" MP1="+MP1+" NP1="+NP1;
console.log(pstr);
if (rp) fs.writeFileSync('linit.rpt.jsc', pstr+'\n');

var alfa, alf1;
var lamnor, niuf;
var xgnorm, xgnorm_min;
var xgnorm5 = [0,0,0,0,0,,0,0,0];
var  xg_min;
var ind=0, ind5=[0,0,0,0,0,0,0,0,0];
var i, j, k, k_max, k_min, n, ind_gt_3;
var i_n, i_n5 = [0,0,0,0,0,0,0,0,0];
var it_entr;
var DELsave, DELs;
var coef=[];

var start_time = new Date().getTime();
console.log(start_time);
if (rp) fs.appendFileSync('linit.rpt.jsc', start_time + "\n");
var finish_time;
var elapse_time;

var n=np1-1;
for (i=1;i<=n;i++) hm[1][i] = -1.*MXMN*hm[1][i];

if (NORM == 0) lamnor = Hnorm();
if (EPS == 0) Epsdef();

//#pragma wait
//#pragma cache hm
//#pragma cache sp
//#pragma cache sm
////#pragma cachefuncs
//#pragma sequential
iter = 1;
ind=0;
DELsave = DEL;
var EPS5=[EPS,EPS,EPS,EPS,EPS,EPS,EPS,EPS,EPS];
var xgnorm5 = [0,0,0,0,0,0,0,0,0];
var g5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var sn5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var eps = [];
h = [[0],[0],[0]];

cpvec(g, g_save);

if (rp)
    fs.appendFileSync('linit.rpt.jsc', "\nIter(k)      F(g)     (X,g)    //X//g   Ind Nr.       Eps      Alfa  It_entry\n");
console.log("\nIter(k)      F(g)     (X,g)    //X//g   Ind Nr.       Eps      Alfa  It_entry\n");

//#pragma dive
//#pragma sequential
while (iter<=5000 && ind != 3) {

    cpvec(EPS5, eps);

    DEL = DELsave;
    ind=2;

    if (iter == 1) k_max = 1;
    else k_max = 5;

//#pragma wait
//#pragma parallel
//#pragma noautoparvar
//#pragma parvar g5
//#pragma parvar sn5
//#pragma parvar x5
//#pragma parvar y5
//#pragma parvar xg5
//#pragma parvar fg5
//#pragma parvar ind5
//#pragma parvar i_n5
//#pragma parvar xgnorm5
//#pragma parvar EPS5
    for (k=1;k<=k_max;k++) {

        if (!k_min) k_min = 1;
        EPS = eps[k_min]; 

	    effDEL = DEL;
	    it_entr = 0;

	    m = [];
	    x = [];
	    fg=0.;

	    cpvec(g_save, g);

	    while (ind == 2) {

   	        i_n = Minxg(k, sm, sp);

	        for (var ii=1;ii<=n;ii++) {
		        for (j=1;j<=mp1;j++) hm1[j] = hm[j][ii];
		        h[2][ii] = Skabg(x,hm1,1,mp1);
		        }

	        ind=1;
	        DELs = DEL;

	        while (ind == 1) {

                ind = Analys(Mnxgco(), DZV);
		        xgnorm = Skabg(x,x,2,mp1);
		
		        it_entr = it_entr + 1;
		        if (it_entr%500 == 0) {
		            DEL = DEL * 2.0;
		            if (DEL > 0.3) DEL = 0.3;
		            effDEL = DEL;
	    
//		            if (rp)
//			        fs.appendFileSync('linit.rpt.jsc',""+it_entr + "  " + DEL + "\n");
		            console.log(""+it_entr + "  " + DEL);
		            }
		        } // while (ind == 1)
	    
    		DEL=DELs;
	        }  // while (ind == 2)

	        __set_Par_Var_Value('xgnorm5['+k+']', xgnorm, __job, true);

	        if (ind == 3) {
    
		        __set_Par_Var_Value('ind5['+k+']', ind, __job, true);
		        __set_Par_Var_Value('sn5['+k+']', sn, __job, true);
		        }

	        for (i=1; i<=mp1; i++) hm1[i] = hm[i][np1];

	        dz[1] = Hb(hm1,g,mp1);
	        dz[2] = Skabg(hm1,y,1,mp1);
	        alfa = Mxmnxg();
	        if (alfa != 0.) {
		        alf1 = 1.-alfa*y[1];
		        for (i=1; i<=mp1 ; i++) g[i] = alf1*g[i] + alfa*y[i];

	            __set_Par_Var_Value('g5['+k+']', g, __job, true);

	            xg = Hb(x,g,mp1);
	            if (rp)
    		        fs.appendFileSync('linit.rpt.jsc',strf(iter,4)+"("+k+") "+strf(fg,10)+" "+strf(xg,10)+" "+strf(xgnorm,10)+" "+strf(i_n,10)+" "+strf(EPS,10)+" "+strf(alfa,10)+" "+strf(it_entr,6)+"\n");
    	        console.log(strf(iter,4)+"("+k+") "+strf(fg,10)+" "+strf(xg,10)+" "+strf(xgnorm,10)+" "+strf(i_n,10)+" "+strf(EPS,10)+" "+strf(alfa,10)+" "+strf(it_entr,6));

	            niuf = 2.* Math.abs(fg-xg)/ Math.abs(fg+xg);
	            if (niuf < NIU / 2. ) {
		        EPS = EPS*1.25;
		        }

	        __set_Par_Var_Value('EPS5['+k+']', EPS, __job, true);
	        }
	    else {
	        console.log("Problem has no solution");
	        exit(1);
	        }
	    ind = 2;
	    } // end for

//#pragma wait
//#pragma sequential
    var xgnorm_min = xgnorm5[1];
    cpvec(EPS5, eps);

    k_min = 1;
    var ki=1;
    for (ki=1; ki<=k_max; ki++) {
	    if (xgnorm5[ki] < xgnorm_min) {
	        xgnorm_min = xgnorm5[ki];
	        k_min = ki;
	        }
	    if (ind5[ki] == 3) {ind=3; k_min=ki; break;}
	    }

	g_save = __get_Par_Var_Value('g5['+k_min+']', false, __job);
    xgnorm = xgnorm5[k_min];
    EPS = EPS5[k_min];    

    fs.appendFileSync('linit.rpt.jsc',"\nk_min="+k_min+"\n");
    console.log("\nk_min="+k_min+"\n");

    if (ind != 3) ind = ind5[k_min];
	else sn = __get_Par_Var_Value('sn5['+k_min+']', false, __job);

    iter=iter+1;
    }

//#pragma sequential
//#wait
if (ind != 3 ) {
    if (rp) fs.appendFileSync('linit.rpt.jsc'," No solution after more than 200 iterations !\n");
    console.log (" No solution after more than 500 iterations !\n");
    }

for (var i=1; i<=np1; i++) hm[1][i] = -1*MXMN*hm[1][i];

finish_time = new Date().getTime();
console.log(finish_time);
if (rp) fs.appendFileSync('linit.rpt.jsc', finish_time + "\n");
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec");
if (rp) fs.appendFileSync('linit.rpt.jsc', "Elapse time: " + elapse_time + " sec\n");

for (i=1;i<=np1-1;i++) {
    if (rp) fs.appendFileSync('linit.rpt.jsc',sn[i]+ "  ");
    if (i%3 == 0) {
        if (rp) fs.appendFileSync('linit.rpt.jsc', "\n");
        }
   }
if (rp) {
    fs.appendFileSync('linit.rpt.jsc', "\nXG="+xg+"   "+"FG="+fg+"\n");
    console.log("\nXG="+xg+"   "+"FG="+fg+"\n");
   }
console.log(" End of solution \n");

// Functions

function max(a,b) {
    return a > b ? a : b; 
}

function min(a,b) {
    return a < b ? a : b; 
}

function readex(fromfile) {

    var i, j;
    var data = {};
    var mp1 = MP1, np1 = NP1;

    if (fromfile) {
	    var res = fs.readFileSync("linit.data.json");
	    data = JSON.parse(res, null);
	    hm = data.hm;
	    sm = data.sm;
	    sp = data.sp;
	    }
}

function cpvec(av, bv) {

    if (!av) return;
    for (var ii=0; ii<av.length; ii++ ) bv[ii] = av[ii];

}

function strf(num, len) {

    var bl = "";
    for (var i=1; i<=len; i++) bl+=" ";
    var ns = num.toString() + bl;
    return ns.substr(0,len);
}


function Minxg(k, sm, sp) {

    var hmg;
    var i, j, i_n;
    coef = [0, 1., -1.18, 1.18, -1.18, 1.18, -1.18, 1.18, -1.18, 1.18];

    for (i=1; i<=n ;i++) {
	    for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
	    h[1][i] = Hb(hm1,g,mp1);
	    hmg = Skabg(hm1,hm1,2,mp1);

	    if ( h[1][i] > coef[k]*EPS*hmg ) sn[i] = sm[i];
	    else sn[i] = sp[i];
        }

    for (i=1; i<=mp1; i++) {
	    x[i] = hm[i][np1];
	    for (j=1; j<=n; j++) x[i] = x[i] + hm[i][j]*sn[j];
	    }

    fg = Hb(x,g,mp1);

    i_n=0;

    for (i=1; i<=n; i++) {
	    for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
	    hmg = Skabg(hm1,hm1,2,mp1);
	    m[i]=0;
	    if (Math.abs(h[1][i]) <= (0.8+k*0.2)*EPS*hmg) {
    	    m[i] = 1;
    	    i_n++;
    	    }
	    }

    return(i_n);

}

function Analys(ind1, DZV) {

    var d=0., niuf=0., s=0., xgnorm=0.;
    var i, j, kt, ind = 0;

    xg = Hb(x,g,mp1);
    if (fg + xg != 0. ) {
	    niuf = 2.* Math.abs((fg-xg))/ Math.abs((fg+xg));
	    if (niuf > NIU ) {
    	    ind = 2;
    	    EPS = EPS*0.75;
    	    }
	    }

    if (ind != 2) {
	    kt = 0;
	    if (Math.abs((x[1]-xg)) > DEL ) kt = 1;
	    for (i=2; i<=mp1; i++) {
    	    if (Math.abs(x[i]) > DEL ) kt = 1;
    	    }
	    if ( kt == 0) ind = 3;
	    if ( ind != 3) {
    	    xgnorm = Skabg(x,x,2,mp1);
    	    y[1] = (x[1]-xg)/xgnorm;
    	    for (i=2; i<=mp1; i++) y[i] = x[i]/xgnorm;
    	    for (i=1; i<=n; i++) {
		        for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
		        h[2][i] = Skabg(hm1,y,1,mp1);
		        }
    	    d = 0.;
    	    for (i=1; i<=n; i++) {
		        if ( m[i] != 0 ) {
		            if (h[2][i] > 0.) s = sn[i] - sm[i];
		            else s = sn[i] - sp[i];
		            d = d + h[2][i]*s;
		            }
		        }
    	    d = d/xgnorm;
    	    if (d >= DZV) ind = 1;
    	    }
	    }

    if (ind1 == 0) return(0);
    return(ind);

}

function Mnxgco() {


    var dels = 0., del = 0., temp = 0.;
    var fdels = 0., fdels_old = 0., fdels_diff = 0.;

    var dz1, dz2, i, j;
    var iter_out = 0, iter_in = 0;

    do {
	    dz1 = 0;
	    dz2 = 0;

	    for (i=1; i<=n; i++) if (m[i]>0) m[i] = 2;

	    iter_in = 0;

	    do {

    	    if (dz1 == 0 && dz2 == 1 ) dz1 = 1;
    	    dz2 = 0;
    	    for (i=1; i<=n; i++) {
		        if ( m[i] == 2) {
		            for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
		            temp = Skabg(hm1,hm1,2,mp1);
		            del = Skabg(x,hm1,1,mp1)/(-temp*temp);
		            if (del < 0. ) dels=max(del,(sm[i]-sn[i]));
		            else dels=min(del,(sp[i]-sn[i]));
		            for (j=1; j<=mp1; j++) x[j] += dels*hm1[j];
		            sn[i] += dels;
		            if (sn[i]==sp[i] || sn[i]==sm[i]) {
			            m[i] = 1;
			            dz2 = 1;
			            }
		            }
		        }
    	    iter_in = iter_in + 1;
    	    fdels = Math.abs(dels);
    	    if (fdels < effDEL*effDEL) {
    		    return(1);
    		    }
    	    fdels_diff = (fdels_old == 0.) ? 1000. : Math.abs(fdels - fdels_old);
    	    fdels_old = fdels;
    	    } while (dz2 == 1);

	    iter_out=iter_out+1;
	    if (fdels_diff < effDEL*effDEL || iter_out%3000 == 0) {
	        effDEL = effDEL * 2.0;
	        }
	    } while(dz1==1 && dz2 == 0 && iter_out <= 7000);

    for (i=1; i<=n; i++)
        if (m[i] !=0 && sn[i]<sp[i] && sn[i] > sm[i]) m[i] = 2;

    return(1);
}


function Mxmnxg() {

    var bm = [0.,0.,1.], bp=[0.,1.,0.];
    var b = [0.,0.,1.]; 
    var z=[0.,0.,0.]; 
    h1=[0.,0.,0.];
    var i, j, itr = 0;

    Zdef(b, z);

    if (z[2] > 0.) {
	    return 0.;
	    }

    while(itr<=20) {

	    b[1] = (bp[1]+bm[1])/2.;
	    b[2] = (bp[2]+bm[2])/2.;
	    itr = itr + 1;
	    Zdef(b, z);

	    if (z[2] <= 0.) {
    	    bm[1] = b[1];
    	    bm[2] = b[2];
    	    }
	    else {
    	    bp[1] = b[1];
    	    bp[2] = b[2];
    	    }
	    }

    return(b[2]/b[1]);

}

function Zdef(b, z) {

    var sn1 = 0.;
    var i, j;

    for (i=1; i<=2; i++) {
	    z[i]=dz[i];
	    for (j=1; j<=n; j++) {
    	    h1[1]=h[1][j];
    	    h1[2]=h[2][j];
    	    if ( Hb(h1,b,2) > 0. ) sn1 = sm[j];
    	    else sn1 = sp[j];
    	    z[i] = z[i] + sn1*h[i][j];
    	    }
	    }

}

function Hnorm() {

    var lam = 0., xnor = 0.;
    var i, j;

    for (i=1; i<=n; i++) hm1[i] = hm[1][i];
    lam = Hb(hm1,hm1,n);
    lam = Math.sqrt(lam);
    for (i=1; i<=n; i++) hm[1][i]= hm[1][i]/lam;

    for (j=2; j<=mp1; j++) {
	    for (i=1; i<=n; i++) hm1[i] = hm[j][i];
	    xnor = Hb(hm1,hm1,n);
	    xnor = Math.sqrt(xnor);
	    for (i=1; i<=n; i++) hm[j][i]= hm[j][i]/xnor;
	    }

    return (lam);
}


function Epsdef () {

    var deps = [];
    var hmg = 0., ruf = 0.;
    var i, j, ip1;

    for (i=1;i<=n;i++) {
	    for (j=1;j<=mp1;j++) hm1[j] = hm[j][i];
	    hmg = Skabg(hm1,hm1,2,mp1);
	    deps[i] = Math.abs(h[1][i])/hmg;
	    }

    for (i=1;i<=n;i++) {
	    ip1=i+1;
	    for(j=ip1;j<=n;j++) {
    	    if (deps[i]<deps[j]) {
		        ruf = deps[j];
		        deps[j] = deps[i];
		        deps[i] = ruf;
		        }
    	    }
	    }

    EPS = (deps[IDEF] + deps[IDEF+1]) / 2.;

}

function Hb(hh, bb, nn) {

    var hb = 0.;
    var i;

    for (i=1; i<=nn; i++) hb += hh[i]*bb[i];

    return(hb);

}

function Skabg(a, b, i_nn, nn) {

    var ag = 0., skbg = 0.;
    var i;

    for (i=1; i<=nn; i++) ag = ag + a[i]*g[i];

    if (i_nn==1) {
	    skbg = (a[1]-ag)*b[1];
	    for (i=2;i<=nn;i++) {
    	    skbg = skbg + a[i]*b[i];
    	    }
	    return(skbg);
	    }
    else {
	    skbg = (a[1]-ag)*(a[1]-ag);
	    for (i=2;i<=nn;i++) {
    	    skbg = skbg + a[i]*a[i];
    	    }
	    }

    return(Math.sqrt(skbg));

}

-------------------------------------

2020-06-20T12:06:29.855Z: user: vladas
//#pragma sequential

dfltParams = {
    NORM : 1,
    IDEF : 1,
    MXMN : -1,
    DEL : 1.e-5,
    NIU : 0.1,
    EPS : 0.001,
    DZV : 0.2
    };

var NORM, // these must be explicitly defined to receive further values.
    IDEF,
    MXMN,
    DEL,
    NIU,
    EPS,
    DZV,
    NP1,
    MP1;

var rp = true;
params = {};
var dz = [0.,0.,0.];
var g = [], g_save = [];
var g5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]]; // prevent array from a jam by JSON.stringify
var h = [];
var hm = [];
var hm1 = [];
var sm = [], sn = [];
var sn5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var sp = [];
var x = [];
var x5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]]; 
var y = [];
var y5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var m = [];
var z = [];
var b = [];
var h1 = [];
var xg, fg;
var xg5 = [0,0,0,0,0,0,0,0,0];
var fg5 = [0,0,0,0,0,0,0,0,0];
var iter;
var kbh;
var pstr;
var effDEL;
var funcalls = 0, funcallsp;

var res = fs.readFileSync("linit.prm.json");
try {params = JSON.parse(res.toString(), null);}
catch(err){console.log(err.message);}

for (var p in dfltParams) {
    if (!params[p]) params[p] = dfltParams[p];
}

for (var p in params) {
    eval(p +'= params["'+p+'"]');  // I know it's ugly
}

var np1 = NP1;
var mp1 = MP1;
var np11 = np1+1, mp11 = mp1+1 ,i;
var kbh=0;

for (i=1; i<=mp1; i++) g[i]=0.;
g[1]=1.;

readex(true);

pstr = "NORM="+NORM+" IDEF="+IDEF+" MXMN="+MXMN+" DEL="+DEL+" NIU="+NIU+"\n EPS="+EPS+" DZV="+DZV+" MP1="+MP1+" NP1="+NP1;
console.log(pstr);
if (rp) fs.writeFileSync('linit.rpt.jsc', pstr+'\n');

var alfa, alf1;
var lamnor, niuf;
var xgnorm, xgnorm_min;
var xgnorm5 = [0,0,0,0,0,,0,0,0];
var  xg_min;
var ind=0, ind5=[0,0,0,0,0,0,0,0,0];
var i, j, k, k_max, k_min, n, ind_gt_3;
var i_n, i_n5 = [0,0,0,0,0,0,0,0,0];
var it_entr;
var DELsave, DELs;
var coef=[];

var start_time = new Date().getTime();
console.log(start_time);
if (rp) fs.appendFileSync('linit.rpt.jsc', start_time + "\n");
var finish_time;
var elapse_time;

var n=np1-1;
for (i=1;i<=n;i++) hm[1][i] = -1.*MXMN*hm[1][i];

if (NORM == 0) lamnor = Hnorm();
if (EPS == 0) Epsdef();

//#pragma wait
//#pragma cache hm
//#pragma cache sp
//#pragma cache sm
////#pragma cachefuncs
//#pragma sequential
iter = 1;
ind=0;
DELsave = DEL;
var EPS5=[EPS,EPS,EPS,EPS,EPS,EPS,EPS,EPS,EPS];
var xgnorm5 = [0,0,0,0,0,0,0,0,0];
var g5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var sn5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var eps = [];
h = [[0],[0],[0]];

cpvec(g, g_save);

if (rp)
    fs.appendFileSync('linit.rpt.jsc', "\nIter(k)      F(g)     (X,g)    //X//g   Ind Nr.       Eps      Alfa  It_entry\n");
console.log("\nIter(k)      F(g)     (X,g)    //X//g   Ind Nr.       Eps      Alfa  It_entry\n");

//#pragma dive
//#pragma sequential
while (iter<=5000 && ind != 3) {

    cpvec(EPS5, eps);

    DEL = DELsave;
    ind=2;

    if (iter == 1) k_max = 1;
    else k_max = 5;

//#pragma wait
//#pragma parallel
//#pragma noautoparvar
//#pragma parvar g5
//#pragma parvar sn5
//#pragma parvar x5
//#pragma parvar y5
//#pragma parvar xg5
//#pragma parvar fg5
//#pragma parvar ind5
//#pragma parvar i_n5
//#pragma parvar xgnorm5
//#pragma parvar EPS5
    for (k=1;k<=k_max;k++) {

        if (!k_min) k_min = 1;
        EPS = eps[k_min]; 

	    effDEL = DEL;
	    it_entr = 0;

	    m = [];
	    x = [];
	    fg=0.;

	    cpvec(g_save, g);

	    while (ind == 2) {

   	        i_n = Minxg(k, sm, sp);

	        for (var ii=1;ii<=n;ii++) {
		        for (j=1;j<=mp1;j++) hm1[j] = hm[j][ii];
		        h[2][ii] = Skabg(x,hm1,1,mp1);
		        }

	        ind=1;
	        DELs = DEL;

	        while (ind == 1) {

                ind = Analys(Mnxgco(), DZV);
		        xgnorm = Skabg(x,x,2,mp1);
		
		        it_entr = it_entr + 1;
		        if (it_entr%500 == 0) {
		            DEL = DEL * 2.0;
		            if (DEL > 0.3) DEL = 0.3;
		            effDEL = DEL;
	    
//		            if (rp)
//			        fs.appendFileSync('linit.rpt.jsc',""+it_entr + "  " + DEL + "\n");
		            console.log(""+it_entr + "  " + DEL);
		            }
		        } // while (ind == 1)
	    
    		DEL=DELs;
	        }  // while (ind == 2)

	        __set_Par_Var_Value('xgnorm5['+k+']', xgnorm, __job, true);

	        if (ind == 3) {
    
		        __set_Par_Var_Value('ind5['+k+']', ind, __job, true);
		        __set_Par_Var_Value('sn5['+k+']', sn, __job, true);
		        }

	        for (i=1; i<=mp1; i++) hm1[i] = hm[i][np1];

	        dz[1] = Hb(hm1,g,mp1);
	        dz[2] = Skabg(hm1,y,1,mp1);
	        alfa = Mxmnxg();
	        if (alfa != 0.) {
		        alf1 = 1.-alfa*y[1];
		        for (i=1; i<=mp1 ; i++) g[i] = alf1*g[i] + alfa*y[i];

	            __set_Par_Var_Value('g5['+k+']', g, __job, true);

	            xg = Hb(x,g,mp1);
	            if (rp)
    		        fs.appendFileSync('linit.rpt.jsc',strf(iter,4)+"("+k+") "+strf(fg,10)+" "+strf(xg,10)+" "+strf(xgnorm,10)+" "+strf(i_n,10)+" "+strf(EPS,10)+" "+strf(alfa,10)+" "+strf(it_entr,6)+"\n");
    	        console.log(strf(iter,4)+"("+k+") "+strf(fg,10)+" "+strf(xg,10)+" "+strf(xgnorm,10)+" "+strf(i_n,10)+" "+strf(EPS,10)+" "+strf(alfa,10)+" "+strf(it_entr,6));

	            niuf = 2.* Math.abs(fg-xg)/ Math.abs(fg+xg);
	            if (niuf < NIU / 2. ) {
		        EPS = EPS*1.25;
		        }

	        __set_Par_Var_Value('EPS5['+k+']', EPS, __job, true);
	        }
	    else {
	        console.log("Problem has no solution");
	        exit(1);
	        }
	    ind = 2;
	    } // end for

//#pragma wait
//#pragma sequential
    var xgnorm_min = xgnorm5[1];
    cpvec(EPS5, eps);

    k_min = 1;
    var ki=1;
    for (ki=1; ki<=k_max; ki++) {
	    if (xgnorm5[ki] < xgnorm_min) {
	        xgnorm_min = xgnorm5[ki];
	        k_min = ki;
	        }
	    if (ind5[ki] == 3) {ind=3; k_min=ki; break;}
	    }

	g_save = __get_Par_Var_Value('g5['+k_min+']', false, __job);
    xgnorm = xgnorm5[k_min];
    EPS = EPS5[k_min];    

    fs.appendFileSync('linit.rpt.jsc',"\nk_min="+k_min+"\n");
    console.log("\nk_min="+k_min+"\n");

    if (ind != 3) ind = ind5[k_min];
	else sn = __get_Par_Var_Value('sn5['+k_min+']', false, __job);

    iter=iter+1;
    }

//#pragma sequential
//#wait
if (ind != 3 ) {
    if (rp) fs.appendFileSync('linit.rpt.jsc'," No solution after more than 200 iterations !\n");
    console.log (" No solution after more than 500 iterations !\n");
    }

for (var i=1; i<=np1; i++) hm[1][i] = -1*MXMN*hm[1][i];

finish_time = new Date().getTime();
console.log(finish_time);
if (rp) fs.appendFileSync('linit.rpt.jsc', finish_time + "\n");
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec");
if (rp) fs.appendFileSync('linit.rpt.jsc', "Elapse time: " + elapse_time + " sec\n");

for (i=1;i<=np1-1;i++) {
    if (rp) fs.appendFileSync('linit.rpt.jsc',sn[i]+ "  ");
    if (i%3 == 0) {
        if (rp) fs.appendFileSync('linit.rpt.jsc', "\n");
        }
   }
if (rp) {
    fs.appendFileSync('linit.rpt.jsc', "\nXG="+xg+"   "+"FG="+fg+"\n");
    console.log("\nXG="+xg+"   "+"FG="+fg+"\n");
   }
console.log(" End of solution \n");

// Functions

function max(a,b) {
    return a > b ? a : b; 
}

function min(a,b) {
    return a < b ? a : b; 
}

function readex(fromfile) {

    var i, j;
    var data = {};
    var mp1 = MP1, np1 = NP1;

    if (fromfile) {
	    var res = fs.readFileSync("linit.data.json");
	    data = JSON.parse(res, null);
	    hm = data.hm;
	    sm = data.sm;
	    sp = data.sp;
	    }
}

function cpvec(av, bv) {

    if (!av) return;
    for (var ii=0; ii<av.length; ii++ ) bv[ii] = av[ii];

}

function strf(num, len) {

    var bl = "";
    for (var i=1; i<=len; i++) bl+=" ";
    var ns = num.toString() + bl;
    return ns.substr(0,len);
}


function Minxg(k, sm, sp) {

    var hmg;
    var i, j, i_n;
    coef = [0, 1.12, -1.18, 1.18, -1.18, 1.18, -1.18, 1.18, -1.18, 1.18];

    for (i=1; i<=n ;i++) {
	    for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
	    h[1][i] = Hb(hm1,g,mp1);
	    hmg = Skabg(hm1,hm1,2,mp1);

	    if ( h[1][i] > coef[k]*EPS*hmg ) sn[i] = sm[i];
	    else sn[i] = sp[i];
        }

    for (i=1; i<=mp1; i++) {
	    x[i] = hm[i][np1];
	    for (j=1; j<=n; j++) x[i] = x[i] + hm[i][j]*sn[j];
	    }

    fg = Hb(x,g,mp1);

    i_n=0;

    for (i=1; i<=n; i++) {
	    for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
	    hmg = Skabg(hm1,hm1,2,mp1);
	    m[i]=0;
	    if (Math.abs(h[1][i]) <= (1.04+k*0.18)*EPS*hmg) { // was 0.8+k*0.2
    	    m[i] = 1;
    	    i_n++;
    	    }
	    }

    return(i_n);

}

function Analys(ind1, DZV) {

    var d=0., niuf=0., s=0., xgnorm=0.;
    var i, j, kt, ind = 0;

    xg = Hb(x,g,mp1);
    if (fg + xg != 0. ) {
	    niuf = 2.* Math.abs((fg-xg))/ Math.abs((fg+xg));
	    if (niuf > NIU ) {
    	    ind = 2;
    	    EPS = EPS*0.75;
    	    }
	    }

    if (ind != 2) {
	    kt = 0;
	    if (Math.abs((x[1]-xg)) > DEL ) kt = 1;
	    for (i=2; i<=mp1; i++) {
    	    if (Math.abs(x[i]) > DEL ) kt = 1;
    	    }
	    if ( kt == 0) ind = 3;
	    if ( ind != 3) {
    	    xgnorm = Skabg(x,x,2,mp1);
    	    y[1] = (x[1]-xg)/xgnorm;
    	    for (i=2; i<=mp1; i++) y[i] = x[i]/xgnorm;
    	    for (i=1; i<=n; i++) {
		        for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
		        h[2][i] = Skabg(hm1,y,1,mp1);
		        }
    	    d = 0.;
    	    for (i=1; i<=n; i++) {
		        if ( m[i] != 0 ) {
		            if (h[2][i] > 0.) s = sn[i] - sm[i];
		            else s = sn[i] - sp[i];
		            d = d + h[2][i]*s;
		            }
		        }
    	    d = d/xgnorm;
    	    if (d >= DZV) ind = 1;
    	    }
	    }

    if (ind1 == 0) return(0);
    return(ind);

}

function Mnxgco() {


    var dels = 0., del = 0., temp = 0.;
    var fdels = 0., fdels_old = 0., fdels_diff = 0.;

    var dz1, dz2, i, j;
    var iter_out = 0, iter_in = 0;

    do {
	    dz1 = 0;
	    dz2 = 0;

	    for (i=1; i<=n; i++) if (m[i]>0) m[i] = 2;

	    iter_in = 0;

	    do {

    	    if (dz1 == 0 && dz2 == 1 ) dz1 = 1;
    	    dz2 = 0;
    	    for (i=1; i<=n; i++) {
		        if ( m[i] == 2) {
		            for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
		            temp = Skabg(hm1,hm1,2,mp1);
		            del = Skabg(x,hm1,1,mp1)/(-temp*temp);
		            if (del < 0. ) dels=max(del,(sm[i]-sn[i]));
		            else dels=min(del,(sp[i]-sn[i]));
		            for (j=1; j<=mp1; j++) x[j] += dels*hm1[j];
		            sn[i] += dels;
		            if (sn[i]==sp[i] || sn[i]==sm[i]) {
			            m[i] = 1;
			            dz2 = 1;
			            }
		            }
		        }
    	    iter_in = iter_in + 1;
    	    fdels = Math.abs(dels);
    	    if (fdels < effDEL*effDEL) {
    		    return(1);
    		    }
    	    fdels_diff = (fdels_old == 0.) ? 1000. : Math.abs(fdels - fdels_old);
    	    fdels_old = fdels;
    	    } while (dz2 == 1);

	    iter_out=iter_out+1;
	    if (fdels_diff < effDEL*effDEL || iter_out%3000 == 0) {
	        effDEL = effDEL * 2.0;
	        }
	    } while(dz1==1 && dz2 == 0 && iter_out <= 7000);

    for (i=1; i<=n; i++)
        if (m[i] !=0 && sn[i]<sp[i] && sn[i] > sm[i]) m[i] = 2;

    return(1);
}


function Mxmnxg() {

    var bm = [0.,0.,1.], bp=[0.,1.,0.];
    var b = [0.,0.,1.]; 
    var z=[0.,0.,0.]; 
    h1=[0.,0.,0.];
    var i, j, itr = 0;

    Zdef(b, z);

    if (z[2] > 0.) {
	    return 0.;
	    }

    while(itr<=20) {

	    b[1] = (bp[1]+bm[1])/2.;
	    b[2] = (bp[2]+bm[2])/2.;
	    itr = itr + 1;
	    Zdef(b, z);

	    if (z[2] <= 0.) {
    	    bm[1] = b[1];
    	    bm[2] = b[2];
    	    }
	    else {
    	    bp[1] = b[1];
    	    bp[2] = b[2];
    	    }
	    }

    return(b[2]/b[1]);

}

function Zdef(b, z) {

    var sn1 = 0.;
    var i, j;

    for (i=1; i<=2; i++) {
	    z[i]=dz[i];
	    for (j=1; j<=n; j++) {
    	    h1[1]=h[1][j];
    	    h1[2]=h[2][j];
    	    if ( Hb(h1,b,2) > 0. ) sn1 = sm[j];
    	    else sn1 = sp[j];
    	    z[i] = z[i] + sn1*h[i][j];
    	    }
	    }

}

function Hnorm() {

    var lam = 0., xnor = 0.;
    var i, j;

    for (i=1; i<=n; i++) hm1[i] = hm[1][i];
    lam = Hb(hm1,hm1,n);
    lam = Math.sqrt(lam);
    for (i=1; i<=n; i++) hm[1][i]= hm[1][i]/lam;

    for (j=2; j<=mp1; j++) {
	    for (i=1; i<=n; i++) hm1[i] = hm[j][i];
	    xnor = Hb(hm1,hm1,n);
	    xnor = Math.sqrt(xnor);
	    for (i=1; i<=n; i++) hm[j][i]= hm[j][i]/xnor;
	    }

    return (lam);
}


function Epsdef () {

    var deps = [];
    var hmg = 0., ruf = 0.;
    var i, j, ip1;

    for (i=1;i<=n;i++) {
	    for (j=1;j<=mp1;j++) hm1[j] = hm[j][i];
	    hmg = Skabg(hm1,hm1,2,mp1);
	    deps[i] = Math.abs(h[1][i])/hmg;
	    }

    for (i=1;i<=n;i++) {
	    ip1=i+1;
	    for(j=ip1;j<=n;j++) {
    	    if (deps[i]<deps[j]) {
		        ruf = deps[j];
		        deps[j] = deps[i];
		        deps[i] = ruf;
		        }
    	    }
	    }

    EPS = (deps[IDEF] + deps[IDEF+1]) / 2.;

}

function Hb(hh, bb, nn) {

    var hb = 0.;
    var i;

    for (i=1; i<=nn; i++) hb += hh[i]*bb[i];

    return(hb);

}

function Skabg(a, b, i_nn, nn) {

    var ag = 0., skbg = 0.;
    var i;

    for (i=1; i<=nn; i++) ag = ag + a[i]*g[i];

    if (i_nn==1) {
	    skbg = (a[1]-ag)*b[1];
	    for (i=2;i<=nn;i++) {
    	    skbg = skbg + a[i]*b[i];
    	    }
	    return(skbg);
	    }
    else {
	    skbg = (a[1]-ag)*(a[1]-ag);
	    for (i=2;i<=nn;i++) {
    	    skbg = skbg + a[i]*a[i];
    	    }
	    }

    return(Math.sqrt(skbg));

}

-------------------------------------

2020-06-22T18:54:04.679Z: user: vladas
//#pragma sequential

dfltParams = {
    NORM : 1,
    IDEF : 1,
    MXMN : -1,
    DEL : 1.e-5,
    NIU : 0.1,
    EPS : 0.001,
    DZV : 0.2
    };

var NORM, // these must be explicitly defined to receive further values.
    IDEF,
    MXMN,
    DEL,
    NIU,
    EPS,
    DZV,
    NP1,
    MP1;

var rp = true;
params = {};
var dz = [0.,0.,0.];
var g = [], g_save = [];
var g5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]]; // prevent array from a jam by JSON.stringify
var h = [];
var hm = [];
var hm1 = [];
var sm = [], sn = [];
var sn5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var sp = [];
var x = [];
var x5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]]; 
var y = [];
var y5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var m = [];
var z = [];
var b = [];
var h1 = [];
var xg, fg;
var xg5 = [0,0,0,0,0,0,0,0,0];
var fg5 = [0,0,0,0,0,0,0,0,0];
var iter;
var kbh;
var pstr;
var effDEL;
var funcalls = 0, funcallsp;

var res = fs.readFileSync("linit.prm.json");
try {params = JSON.parse(res.toString(), null);}
catch(err){console.log(err.message);}

for (var p in dfltParams) {
    if (!params[p]) params[p] = dfltParams[p];
}

for (var p in params) {
    eval(p +'= params["'+p+'"]');  // I know it's ugly
}

var np1 = NP1;
var mp1 = MP1;
var np11 = np1+1, mp11 = mp1+1 ,i;
var kbh=0;

for (i=1; i<=mp1; i++) g[i]=0.;
g[1]=1.;

readex(true);

pstr = "NORM="+NORM+" IDEF="+IDEF+" MXMN="+MXMN+" DEL="+DEL+" NIU="+NIU+"\n EPS="+EPS+" DZV="+DZV+" MP1="+MP1+" NP1="+NP1;
console.log(pstr);
if (rp) fs.writeFileSync('linit.rpt.jsc', pstr+'\n');

var alfa, alf1;
var lamnor, niuf;
var xgnorm, xgnorm_min;
var xgnorm5 = [0,0,0,0,0,,0,0,0];
var  xg_min;
var ind=0, ind5=[0,0,0,0,0,0,0,0,0];
var i, j, k, k_max, k_min, n, ind_gt_3;
var i_n, i_n5 = [0,0,0,0,0,0,0,0,0];
var it_entr;
var DELsave, DELs;
var coef=[];

var start_time = new Date().getTime();
console.log(start_time);
if (rp) fs.appendFileSync('linit.rpt.jsc', start_time + "\n");
var finish_time;
var elapse_time;

var n=np1-1;
for (i=1;i<=n;i++) hm[1][i] = -1.*MXMN*hm[1][i];

if (NORM == 0) lamnor = Hnorm();
if (EPS == 0) Epsdef();

//#pragma wait
//#pragma cache hm
//#pragma cache sp
//#pragma cache sm
////#pragma cachefuncs
//#pragma sequential
iter = 1;
ind=0;
DELsave = DEL;
var EPS5=[EPS,EPS,EPS,EPS,EPS,EPS,EPS,EPS,EPS];
var xgnorm5 = [0,0,0,0,0,0,0,0,0];
var g5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var sn5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var eps = [];
h = [[0],[0],[0]];

cpvec(g, g_save);

if (rp)
    fs.appendFileSync('linit.rpt.jsc', "\nIter(k)      F(g)     (X,g)    //X//g   Ind Nr.       Eps      Alfa  It_entry\n");
console.log("\nIter(k)      F(g)     (X,g)    //X//g   Ind Nr.       Eps      Alfa  It_entry\n");

//#pragma dive
//#pragma sequential
while (iter<=5000 && ind != 3) {

    cpvec(EPS5, eps);

    DEL = DELsave;
    ind=2;

    if (iter == 1) k_max = 1;
    else k_max = 5;

//#pragma wait
//#pragma parallel
//#pragma noautoparvar
//#pragma parvar g5
//#pragma parvar sn5
//#pragma parvar x5
//#pragma parvar y5
//#pragma parvar xg5
//#pragma parvar fg5
//#pragma parvar ind5
//#pragma parvar i_n5
//#pragma parvar xgnorm5
//#pragma parvar EPS5
    for (k=1;k<=k_max;k++) {

        if (!k_min) k_min = 1;
        EPS = eps[k_min]; 

	    effDEL = DEL;
	    it_entr = 0;

	    m = [];
	    x = [];
	    fg=0.;

	    cpvec(g_save, g);

	    while (ind == 2) {

   	        i_n = Minxg(k, k_min, sm, sp);

	        for (var ii=1;ii<=n;ii++) {
		        for (j=1;j<=mp1;j++) hm1[j] = hm[j][ii];
		        h[2][ii] = Skabg(x,hm1,1,mp1);
		        }

	        ind=1;
	        DELs = DEL;

	        while (ind == 1) {

                ind = Analys(Mnxgco(), DZV);
		        xgnorm = Skabg(x,x,2,mp1);
		
		        it_entr = it_entr + 1;
		        if (it_entr%500 == 0) {
		            DEL = DEL * 2.0;
		            if (DEL > 0.3) DEL = 0.3;
		            effDEL = DEL;
	    
//		            if (rp)
//			        fs.appendFileSync('linit.rpt.jsc',""+it_entr + "  " + DEL + "\n");
		            console.log(""+it_entr + "  " + DEL);
		            }
		        } // while (ind == 1)
	    
    		DEL=DELs;
	        }  // while (ind == 2)

	        __set_Par_Var_Value('xgnorm5['+k+']', xgnorm, __job, true);

	        if (ind == 3) {
    
		        __set_Par_Var_Value('ind5['+k+']', ind, __job, true);
		        __set_Par_Var_Value('sn5['+k+']', sn, __job, true);
		        }

	        for (i=1; i<=mp1; i++) hm1[i] = hm[i][np1];

	        dz[1] = Hb(hm1,g,mp1);
	        dz[2] = Skabg(hm1,y,1,mp1);
	        alfa = Mxmnxg();
	        if (alfa != 0.) {
		        alf1 = 1.-alfa*y[1];
		        for (i=1; i<=mp1 ; i++) g[i] = alf1*g[i] + alfa*y[i];

	            __set_Par_Var_Value('g5['+k+']', g, __job, true);

	            xg = Hb(x,g,mp1);
	            if (rp)
    		        fs.appendFileSync('linit.rpt.jsc',strf(iter,4)+"("+k+") "+strf(fg,10)+" "+strf(xg,10)+" "+strf(xgnorm,10)+" "+strf(i_n,10)+" "+strf(EPS,10)+" "+strf(alfa,10)+" "+strf(it_entr,6)+"\n");
    	        console.log(strf(iter,4)+"("+k+") "+strf(fg,10)+" "+strf(xg,10)+" "+strf(xgnorm,10)+" "+strf(i_n,10)+" "+strf(EPS,10)+" "+strf(alfa,10)+" "+strf(it_entr,6));

	            niuf = 2.* Math.abs(fg-xg)/ Math.abs(fg+xg);
	            if (niuf < NIU / 2. ) {
		        EPS = EPS*1.25;
		        }

	        __set_Par_Var_Value('EPS5['+k+']', EPS, __job, true);
	        }
	    else {
	        console.log("Problem has no solution");
	        exit(1);
	        }
	    ind = 2;
	    } // end for

//#pragma wait
//#pragma sequential
    var xgnorm_min = xgnorm5[1];
    cpvec(EPS5, eps);

    k_min = 1;
    var ki=1;
    for (ki=1; ki<=k_max; ki++) {
	    if (xgnorm5[ki] < xgnorm_min) {
	        xgnorm_min = xgnorm5[ki];
	        k_min = ki;
	        }
	    if (ind5[ki] == 3) {ind=3; k_min=ki; break;}
	    }

	g_save = __get_Par_Var_Value('g5['+k_min+']', false, __job);
    xgnorm = xgnorm5[k_min];
    EPS = EPS5[k_min];    

    fs.appendFileSync('linit.rpt.jsc',"\nk_min="+k_min+"\n");
    console.log("\nk_min="+k_min+"\n");

    if (ind != 3) ind = ind5[k_min];
	else sn = __get_Par_Var_Value('sn5['+k_min+']', false, __job);

    iter=iter+1;
    }

//#pragma sequential
//#wait
if (ind != 3 ) {
    if (rp) fs.appendFileSync('linit.rpt.jsc'," No solution after more than 200 iterations !\n");
    console.log (" No solution after more than 500 iterations !\n");
    }

for (var i=1; i<=np1; i++) hm[1][i] = -1*MXMN*hm[1][i];

finish_time = new Date().getTime();
console.log(finish_time);
if (rp) fs.appendFileSync('linit.rpt.jsc', finish_time + "\n");
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec");
if (rp) fs.appendFileSync('linit.rpt.jsc', "Elapse time: " + elapse_time + " sec\n");

for (i=1;i<=np1-1;i++) {
    if (rp) fs.appendFileSync('linit.rpt.jsc',sn[i]+ "  ");
    if (i%3 == 0) {
        if (rp) fs.appendFileSync('linit.rpt.jsc', "\n");
        }
   }
if (rp) {
    fs.appendFileSync('linit.rpt.jsc', "\nXG="+xg+"   "+"FG="+fg+"\n");
    console.log("\nXG="+xg+"   "+"FG="+fg+"\n");
   }
console.log(" End of solution \n");

// Functions

function max(a,b) {
    return a > b ? a : b; 
}

function min(a,b) {
    return a < b ? a : b; 
}

function readex(fromfile) {

    var i, j;
    var data = {};
    var mp1 = MP1, np1 = NP1;

    if (fromfile) {
	    var res = fs.readFileSync("linit.data.json");
	    data = JSON.parse(res, null);
	    hm = data.hm;
	    sm = data.sm;
	    sp = data.sp;
	    }
}

function cpvec(av, bv) {

    if (!av) return;
    for (var ii=0; ii<av.length; ii++ ) bv[ii] = av[ii];

}

function strf(num, len) {

    var bl = "";
    for (var i=1; i<=len; i++) bl+=" ";
    var ns = num.toString() + bl;
    return ns.substr(0,len);
}


function Minxg(k, k_m, sm, sp) {

    var hmg;
    var i, j, i_n;
    coef = [0, 1.12, -1.18, 1.18, -1.18, 1.18, -1.18, 1.18, -1.18, 1.18];

    for (i=1; i<=n ;i++) {
	    for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
	    h[1][i] = Hb(hm1,g,mp1);
	    hmg = Skabg(hm1,hm1,2,mp1);

	    if ( h[1][i] > coef[k]*EPS*hmg ) sn[i] = sm[i];
	    else sn[i] = sp[i];
        }

    for (i=1; i<=mp1; i++) {
	    x[i] = hm[i][np1];
	    for (j=1; j<=n; j++) x[i] = x[i] + hm[i][j]*sn[j];
	    }

    fg = Hb(x,g,mp1);

    i_n=0;

    var kmul = 3-k_m;
    for (i=1; i<=n; i++) {
	    for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
	    hmg = Skabg(hm1,hm1,2,mp1);
	    m[i]=0;
	    if (Math.abs(h[1][i]) <= (1.04+(k+kmul)*0.18)*EPS*hmg) { // was 0.8+k*0.2
    	    m[i] = 1;
    	    i_n++;
    	    }
	    }

    return(i_n);

}

function Analys(ind1, DZV) {

    var d=0., niuf=0., s=0., xgnorm=0.;
    var i, j, kt, ind = 0;

    xg = Hb(x,g,mp1);
    if (fg + xg != 0. ) {
	    niuf = 2.* Math.abs((fg-xg))/ Math.abs((fg+xg));
	    if (niuf > NIU ) {
    	    ind = 2;
    	    EPS = EPS*0.75;
    	    }
	    }

    if (ind != 2) {
	    kt = 0;
	    if (Math.abs((x[1]-xg)) > DEL ) kt = 1;
	    for (i=2; i<=mp1; i++) {
    	    if (Math.abs(x[i]) > DEL ) kt = 1;
    	    }
	    if ( kt == 0) ind = 3;
	    if ( ind != 3) {
    	    xgnorm = Skabg(x,x,2,mp1);
    	    y[1] = (x[1]-xg)/xgnorm;
    	    for (i=2; i<=mp1; i++) y[i] = x[i]/xgnorm;
    	    for (i=1; i<=n; i++) {
		        for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
		        h[2][i] = Skabg(hm1,y,1,mp1);
		        }
    	    d = 0.;
    	    for (i=1; i<=n; i++) {
		        if ( m[i] != 0 ) {
		            if (h[2][i] > 0.) s = sn[i] - sm[i];
		            else s = sn[i] - sp[i];
		            d = d + h[2][i]*s;
		            }
		        }
    	    d = d/xgnorm;
    	    if (d >= DZV) ind = 1;
    	    }
	    }

    if (ind1 == 0) return(0);
    return(ind);

}

function Mnxgco() {


    var dels = 0., del = 0., temp = 0.;
    var fdels = 0., fdels_old = 0., fdels_diff = 0.;

    var dz1, dz2, i, j;
    var iter_out = 0, iter_in = 0;

    do {
	    dz1 = 0;
	    dz2 = 0;

	    for (i=1; i<=n; i++) if (m[i]>0) m[i] = 2;

	    iter_in = 0;

	    do {

    	    if (dz1 == 0 && dz2 == 1 ) dz1 = 1;
    	    dz2 = 0;
    	    for (i=1; i<=n; i++) {
		        if ( m[i] == 2) {
		            for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
		            temp = Skabg(hm1,hm1,2,mp1);
		            del = Skabg(x,hm1,1,mp1)/(-temp*temp);
		            if (del < 0. ) dels=max(del,(sm[i]-sn[i]));
		            else dels=min(del,(sp[i]-sn[i]));
		            for (j=1; j<=mp1; j++) x[j] += dels*hm1[j];
		            sn[i] += dels;
		            if (sn[i]==sp[i] || sn[i]==sm[i]) {
			            m[i] = 1;
			            dz2 = 1;
			            }
		            }
		        }
    	    iter_in = iter_in + 1;
    	    fdels = Math.abs(dels);
    	    if (fdels < effDEL*effDEL) {
    		    return(1);
    		    }
    	    fdels_diff = (fdels_old == 0.) ? 1000. : Math.abs(fdels - fdels_old);
    	    fdels_old = fdels;
    	    } while (dz2 == 1);

	    iter_out=iter_out+1;
	    if (fdels_diff < effDEL*effDEL || iter_out%3000 == 0) {
	        effDEL = effDEL * 2.0;
	        }
	    } while(dz1==1 && dz2 == 0 && iter_out <= 7000);

    for (i=1; i<=n; i++)
        if (m[i] !=0 && sn[i]<sp[i] && sn[i] > sm[i]) m[i] = 2;

    return(1);
}


function Mxmnxg() {

    var bm = [0.,0.,1.], bp=[0.,1.,0.];
    var b = [0.,0.,1.]; 
    var z=[0.,0.,0.]; 
    h1=[0.,0.,0.];
    var i, j, itr = 0;

    Zdef(b, z);

    if (z[2] > 0.) {
	    return 0.;
	    }

    while(itr<=20) {

	    b[1] = (bp[1]+bm[1])/2.;
	    b[2] = (bp[2]+bm[2])/2.;
	    itr = itr + 1;
	    Zdef(b, z);

	    if (z[2] <= 0.) {
    	    bm[1] = b[1];
    	    bm[2] = b[2];
    	    }
	    else {
    	    bp[1] = b[1];
    	    bp[2] = b[2];
    	    }
	    }

    return(b[2]/b[1]);

}

function Zdef(b, z) {

    var sn1 = 0.;
    var i, j;

    for (i=1; i<=2; i++) {
	    z[i]=dz[i];
	    for (j=1; j<=n; j++) {
    	    h1[1]=h[1][j];
    	    h1[2]=h[2][j];
    	    if ( Hb(h1,b,2) > 0. ) sn1 = sm[j];
    	    else sn1 = sp[j];
    	    z[i] = z[i] + sn1*h[i][j];
    	    }
	    }

}

function Hnorm() {

    var lam = 0., xnor = 0.;
    var i, j;

    for (i=1; i<=n; i++) hm1[i] = hm[1][i];
    lam = Hb(hm1,hm1,n);
    lam = Math.sqrt(lam);
    for (i=1; i<=n; i++) hm[1][i]= hm[1][i]/lam;

    for (j=2; j<=mp1; j++) {
	    for (i=1; i<=n; i++) hm1[i] = hm[j][i];
	    xnor = Hb(hm1,hm1,n);
	    xnor = Math.sqrt(xnor);
	    for (i=1; i<=n; i++) hm[j][i]= hm[j][i]/xnor;
	    }

    return (lam);
}


function Epsdef () {

    var deps = [];
    var hmg = 0., ruf = 0.;
    var i, j, ip1;

    for (i=1;i<=n;i++) {
	    for (j=1;j<=mp1;j++) hm1[j] = hm[j][i];
	    hmg = Skabg(hm1,hm1,2,mp1);
	    deps[i] = Math.abs(h[1][i])/hmg;
	    }

    for (i=1;i<=n;i++) {
	    ip1=i+1;
	    for(j=ip1;j<=n;j++) {
    	    if (deps[i]<deps[j]) {
		        ruf = deps[j];
		        deps[j] = deps[i];
		        deps[i] = ruf;
		        }
    	    }
	    }

    EPS = (deps[IDEF] + deps[IDEF+1]) / 2.;

}

function Hb(hh, bb, nn) {

    var hb = 0.;
    var i;

    for (i=1; i<=nn; i++) hb += hh[i]*bb[i];

    return(hb);

}

function Skabg(a, b, i_nn, nn) {

    var ag = 0., skbg = 0.;
    var i;

    for (i=1; i<=nn; i++) ag = ag + a[i]*g[i];

    if (i_nn==1) {
	    skbg = (a[1]-ag)*b[1];
	    for (i=2;i<=nn;i++) {
    	    skbg = skbg + a[i]*b[i];
    	    }
	    return(skbg);
	    }
    else {
	    skbg = (a[1]-ag)*(a[1]-ag);
	    for (i=2;i<=nn;i++) {
    	    skbg = skbg + a[i]*a[i];
    	    }
	    }

    return(Math.sqrt(skbg));

}

-------------------------------------

2020-06-22T19:34:38.830Z: user: vladas
//#pragma sequential

dfltParams = {
    NORM : 1,
    IDEF : 1,
    MXMN : -1,
    DEL : 1.e-5,
    NIU : 0.1,
    EPS : 0.001,
    DZV : 0.2
    };

var NORM, // these must be explicitly defined to receive further values.
    IDEF,
    MXMN,
    DEL,
    NIU,
    EPS,
    DZV,
    NP1,
    MP1;

var rp = true;
params = {};
var dz = [0.,0.,0.];
var g = [], g_save = [];
var g5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]]; // prevent array from a jam by JSON.stringify
var h = [];
var hm = [];
var hm1 = [];
var sm = [], sn = [];
var sn5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var sp = [];
var x = [];
var x5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]]; 
var y = [];
var y5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var m = [];
var z = [];
var b = [];
var h1 = [];
var xg, fg;
var xg5 = [0,0,0,0,0,0,0,0,0];
var fg5 = [0,0,0,0,0,0,0,0,0];
var iter;
var kbh;
var pstr;
var effDEL;
var funcalls = 0, funcallsp;

var res = fs.readFileSync("linit.prm.json");
try {params = JSON.parse(res.toString(), null);}
catch(err){console.log(err.message);}

for (var p in dfltParams) {
    if (!params[p]) params[p] = dfltParams[p];
}

for (var p in params) {
    eval(p +'= params["'+p+'"]');  // I know it's ugly
}

var np1 = NP1;
var mp1 = MP1;
var np11 = np1+1, mp11 = mp1+1 ,i;
var kbh=0;

for (i=1; i<=mp1; i++) g[i]=0.;
g[1]=1.;

readex(true);

pstr = "NORM="+NORM+" IDEF="+IDEF+" MXMN="+MXMN+" DEL="+DEL+" NIU="+NIU+"\n EPS="+EPS+" DZV="+DZV+" MP1="+MP1+" NP1="+NP1;
console.log(pstr);
if (rp) fs.writeFileSync('linit.rpt.jsc', pstr+'\n');

var alfa, alf1;
var lamnor, niuf;
var xgnorm, xgnorm_min;
var xgnorm5 = [0,0,0,0,0,,0,0,0];
var  xg_min;
var ind=0, ind5=[0,0,0,0,0,0,0,0,0];
var i, j, k, k_max, k_min, n, ind_gt_3;
var i_n, i_n5 = [0,0,0,0,0,0,0,0,0];
var it_entr;
var DELsave, DELs;
var coef=[];

var start_time = new Date().getTime();
console.log(start_time);
if (rp) fs.appendFileSync('linit.rpt.jsc', start_time + "\n");
var finish_time;
var elapse_time;

var n=np1-1;
for (i=1;i<=n;i++) hm[1][i] = -1.*MXMN*hm[1][i];

if (NORM == 0) lamnor = Hnorm();
if (EPS == 0) Epsdef();

//#pragma wait
//#pragma cache hm
//#pragma cache sp
//#pragma cache sm
////#pragma cachefuncs
//#pragma sequential
iter = 1;
ind=0;
DELsave = DEL;
var EPS5=[EPS,EPS,EPS,EPS,EPS,EPS,EPS,EPS,EPS];
var xgnorm5 = [0,0,0,0,0,0,0,0,0];
var g5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var sn5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var eps = [];
h = [[0],[0],[0]];

cpvec(g, g_save);

if (rp)
    fs.appendFileSync('linit.rpt.jsc', "\nIter(k)      F(g)     (X,g)    //X//g   Ind Nr.       Eps      Alfa  It_entry\n");
console.log("\nIter(k)      F(g)     (X,g)    //X//g   Ind Nr.       Eps      Alfa  It_entry\n");

//#pragma dive
//#pragma sequential
while (iter<=5000 && ind != 3) {

    cpvec(EPS5, eps);

    DEL = DELsave;
    ind=2;

    if (iter == 1) k_max = 1;
    else k_max = 5;

//#pragma wait
//#pragma parallel
//#pragma noautoparvar
//#pragma parvar g5
//#pragma parvar sn5
//#pragma parvar x5
//#pragma parvar y5
//#pragma parvar xg5
//#pragma parvar fg5
//#pragma parvar ind5
//#pragma parvar i_n5
//#pragma parvar xgnorm5
//#pragma parvar EPS5
    for (k=1;k<=k_max;k++) {

        if (!k_min) k_min = 1;
        EPS = eps[k_min]; 

	    effDEL = DEL;
	    it_entr = 0;

	    m = [];
	    x = [];
	    fg=0.;

	    cpvec(g_save, g);

	    while (ind == 2) {

   	        i_n = Minxg(k, k_min, sm, sp);

	        for (var ii=1;ii<=n;ii++) {
		        for (j=1;j<=mp1;j++) hm1[j] = hm[j][ii];
		        h[2][ii] = Skabg(x,hm1,1,mp1);
		        }

	        ind=1;
	        DELs = DEL;

	        while (ind == 1) {

                ind = Analys(Mnxgco(), DZV);
		        xgnorm = Skabg(x,x,2,mp1);
		
		        it_entr = it_entr + 1;
		        if (it_entr%500 == 0) {
		            DEL = DEL * 2.0;
		            if (DEL > 0.3) DEL = 0.3;
		            effDEL = DEL;
	    
//		            if (rp)
//			        fs.appendFileSync('linit.rpt.jsc',""+it_entr + "  " + DEL + "\n");
		            console.log(""+it_entr + "  " + DEL);
		            }
		        } // while (ind == 1)
	    
    		DEL=DELs;
	        }  // while (ind == 2)

	        __set_Par_Var_Value('xgnorm5['+k+']', xgnorm, __job, true);

	        if (ind == 3) {
    
		        __set_Par_Var_Value('ind5['+k+']', ind, __job, true);
		        __set_Par_Var_Value('sn5['+k+']', sn, __job, true);
		        }

	        for (i=1; i<=mp1; i++) hm1[i] = hm[i][np1];

	        dz[1] = Hb(hm1,g,mp1);
	        dz[2] = Skabg(hm1,y,1,mp1);
	        alfa = Mxmnxg();
	        if (alfa != 0.) {
		        alf1 = 1.-alfa*y[1];
		        for (i=1; i<=mp1 ; i++) g[i] = alf1*g[i] + alfa*y[i];

	            __set_Par_Var_Value('g5['+k+']', g, __job, true);

	            xg = Hb(x,g,mp1);
	            if (rp)
    		        fs.appendFileSync('linit.rpt.jsc',strf(iter,4)+"("+k+") "+strf(fg,10)+" "+strf(xg,10)+" "+strf(xgnorm,10)+" "+strf(i_n,10)+" "+strf(EPS,10)+" "+strf(alfa,10)+" "+strf(it_entr,6)+"\n");
    	        console.log(strf(iter,4)+"("+k+") "+strf(fg,10)+" "+strf(xg,10)+" "+strf(xgnorm,10)+" "+strf(i_n,10)+" "+strf(EPS,10)+" "+strf(alfa,10)+" "+strf(it_entr,6));

	            niuf = 2.* Math.abs(fg-xg)/ Math.abs(fg+xg);
	            if (niuf < NIU / 2. ) {
		        EPS = EPS*1.25;
		        }

	        __set_Par_Var_Value('EPS5['+k+']', EPS, __job, true);
	        }
	    else {
	        console.log("Problem has no solution");
	        exit(1);
	        }
	    ind = 2;
	    } // end for

//#pragma wait
//#pragma sequential
    var xgnorm_min = xgnorm5[1];
    cpvec(EPS5, eps);

    k_min = 1;
    var ki=1;
    for (ki=1; ki<=k_max; ki++) {
	    if (xgnorm5[ki] < xgnorm_min) {
	        xgnorm_min = xgnorm5[ki];
	        k_min = ki;
	        }
	    if (ind5[ki] == 3) {ind=3; k_min=ki; break;}
	    }

	g_save = __get_Par_Var_Value('g5['+k_min+']', false, __job);
    xgnorm = xgnorm5[k_min];
    EPS = EPS5[k_min];    

    fs.appendFileSync('linit.rpt.jsc',"\nk_min="+k_min+"\n");
    console.log("\nk_min="+k_min+"\n");

    if (ind != 3) ind = ind5[k_min];
	else sn = __get_Par_Var_Value('sn5['+k_min+']', false, __job);

    iter=iter+1;
    }

//#pragma sequential
//#wait
if (ind != 3 ) {
    if (rp) fs.appendFileSync('linit.rpt.jsc'," No solution after more than 200 iterations !\n");
    console.log (" No solution after more than 500 iterations !\n");
    }

for (var i=1; i<=np1; i++) hm[1][i] = -1*MXMN*hm[1][i];

finish_time = new Date().getTime();
console.log(finish_time);
if (rp) fs.appendFileSync('linit.rpt.jsc', finish_time + "\n");
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec");
if (rp) fs.appendFileSync('linit.rpt.jsc', "Elapse time: " + elapse_time + " sec\n");

for (i=1;i<=np1-1;i++) {
    if (rp) fs.appendFileSync('linit.rpt.jsc',sn[i]+ "  ");
    if (i%3 == 0) {
        if (rp) fs.appendFileSync('linit.rpt.jsc', "\n");
        }
   }
if (rp) {
    fs.appendFileSync('linit.rpt.jsc', "\nXG="+xg+"   "+"FG="+fg+"\n");
    console.log("\nXG="+xg+"   "+"FG="+fg+"\n");
   }
console.log(" End of solution \n");

// Functions

function max(a,b) {
    return a > b ? a : b; 
}

function min(a,b) {
    return a < b ? a : b; 
}

function readex(fromfile) {

    var i, j;
    var data = {};
    var mp1 = MP1, np1 = NP1;

    if (fromfile) {
	    var res = fs.readFileSync("linit.data.json");
	    data = JSON.parse(res, null);
	    hm = data.hm;
	    sm = data.sm;
	    sp = data.sp;
	    }
}

function cpvec(av, bv) {

    if (!av) return;
    for (var ii=0; ii<av.length; ii++ ) bv[ii] = av[ii];

}

function strf(num, len) {

    var bl = "";
    for (var i=1; i<=len; i++) bl+=" ";
    var ns = num.toString() + bl;
    return ns.substr(0,len);
}


function Minxg(k, k_m, sm, sp) {

    var hmg;
    var i, j, i_n;
    coef = [0, 1.12, -1.18, 1.18, -1.18, 1.18, -1.18, 1.18, -1.18, 1.18];

    for (i=1; i<=n ;i++) {
	    for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
	    h[1][i] = Hb(hm1,g,mp1);
	    hmg = Skabg(hm1,hm1,2,mp1);

	    if ( h[1][i] > coef[k]*EPS*hmg ) sn[i] = sm[i];
	    else sn[i] = sp[i];
        }

    for (i=1; i<=mp1; i++) {
	    x[i] = hm[i][np1];
	    for (j=1; j<=n; j++) x[i] = x[i] + hm[i][j]*sn[j];
	    }

    fg = Hb(x,g,mp1);

    i_n=0;

    var kmul = (3-k_m)/2;  // adaptive variation
    for (i=1; i<=n; i++) {
	    for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
	    hmg = Skabg(hm1,hm1,2,mp1);
	    m[i]=0;
	    if (Math.abs(h[1][i]) <= (1.04+(k+kmul)*0.18)*EPS*hmg) { // was 0.8+k*0.2
    	    m[i] = 1;
    	    i_n++;
    	    }
	    }

    return(i_n);

}

function Analys(ind1, DZV) {

    var d=0., niuf=0., s=0., xgnorm=0.;
    var i, j, kt, ind = 0;

    xg = Hb(x,g,mp1);
    if (fg + xg != 0. ) {
	    niuf = 2.* Math.abs((fg-xg))/ Math.abs((fg+xg));
	    if (niuf > NIU ) {
    	    ind = 2;
    	    EPS = EPS*0.75;
    	    }
	    }

    if (ind != 2) {
	    kt = 0;
	    if (Math.abs((x[1]-xg)) > DEL ) kt = 1;
	    for (i=2; i<=mp1; i++) {
    	    if (Math.abs(x[i]) > DEL ) kt = 1;
    	    }
	    if ( kt == 0) ind = 3;
	    if ( ind != 3) {
    	    xgnorm = Skabg(x,x,2,mp1);
    	    y[1] = (x[1]-xg)/xgnorm;
    	    for (i=2; i<=mp1; i++) y[i] = x[i]/xgnorm;
    	    for (i=1; i<=n; i++) {
		        for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
		        h[2][i] = Skabg(hm1,y,1,mp1);
		        }
    	    d = 0.;
    	    for (i=1; i<=n; i++) {
		        if ( m[i] != 0 ) {
		            if (h[2][i] > 0.) s = sn[i] - sm[i];
		            else s = sn[i] - sp[i];
		            d = d + h[2][i]*s;
		            }
		        }
    	    d = d/xgnorm;
    	    if (d >= DZV) ind = 1;
    	    }
	    }

    if (ind1 == 0) return(0);
    return(ind);

}

function Mnxgco() {


    var dels = 0., del = 0., temp = 0.;
    var fdels = 0., fdels_old = 0., fdels_diff = 0.;

    var dz1, dz2, i, j;
    var iter_out = 0, iter_in = 0;

    do {
	    dz1 = 0;
	    dz2 = 0;

	    for (i=1; i<=n; i++) if (m[i]>0) m[i] = 2;

	    iter_in = 0;

	    do {

    	    if (dz1 == 0 && dz2 == 1 ) dz1 = 1;
    	    dz2 = 0;
    	    for (i=1; i<=n; i++) {
		        if ( m[i] == 2) {
		            for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
		            temp = Skabg(hm1,hm1,2,mp1);
		            del = Skabg(x,hm1,1,mp1)/(-temp*temp);
		            if (del < 0. ) dels=max(del,(sm[i]-sn[i]));
		            else dels=min(del,(sp[i]-sn[i]));
		            for (j=1; j<=mp1; j++) x[j] += dels*hm1[j];
		            sn[i] += dels;
		            if (sn[i]==sp[i] || sn[i]==sm[i]) {
			            m[i] = 1;
			            dz2 = 1;
			            }
		            }
		        }
    	    iter_in = iter_in + 1;
    	    fdels = Math.abs(dels);
    	    if (fdels < effDEL*effDEL) {
    		    return(1);
    		    }
    	    fdels_diff = (fdels_old == 0.) ? 1000. : Math.abs(fdels - fdels_old);
    	    fdels_old = fdels;
    	    } while (dz2 == 1);

	    iter_out=iter_out+1;
	    if (fdels_diff < effDEL*effDEL || iter_out%3000 == 0) {
	        effDEL = effDEL * 2.0;
	        }
	    } while(dz1==1 && dz2 == 0 && iter_out <= 7000);

    for (i=1; i<=n; i++)
        if (m[i] !=0 && sn[i]<sp[i] && sn[i] > sm[i]) m[i] = 2;

    return(1);
}


function Mxmnxg() {

    var bm = [0.,0.,1.], bp=[0.,1.,0.];
    var b = [0.,0.,1.]; 
    var z=[0.,0.,0.]; 
    h1=[0.,0.,0.];
    var i, j, itr = 0;

    Zdef(b, z);

    if (z[2] > 0.) {
	    return 0.;
	    }

    while(itr<=20) {

	    b[1] = (bp[1]+bm[1])/2.;
	    b[2] = (bp[2]+bm[2])/2.;
	    itr = itr + 1;
	    Zdef(b, z);

	    if (z[2] <= 0.) {
    	    bm[1] = b[1];
    	    bm[2] = b[2];
    	    }
	    else {
    	    bp[1] = b[1];
    	    bp[2] = b[2];
    	    }
	    }

    return(b[2]/b[1]);

}

function Zdef(b, z) {

    var sn1 = 0.;
    var i, j;

    for (i=1; i<=2; i++) {
	    z[i]=dz[i];
	    for (j=1; j<=n; j++) {
    	    h1[1]=h[1][j];
    	    h1[2]=h[2][j];
    	    if ( Hb(h1,b,2) > 0. ) sn1 = sm[j];
    	    else sn1 = sp[j];
    	    z[i] = z[i] + sn1*h[i][j];
    	    }
	    }

}

function Hnorm() {

    var lam = 0., xnor = 0.;
    var i, j;

    for (i=1; i<=n; i++) hm1[i] = hm[1][i];
    lam = Hb(hm1,hm1,n);
    lam = Math.sqrt(lam);
    for (i=1; i<=n; i++) hm[1][i]= hm[1][i]/lam;

    for (j=2; j<=mp1; j++) {
	    for (i=1; i<=n; i++) hm1[i] = hm[j][i];
	    xnor = Hb(hm1,hm1,n);
	    xnor = Math.sqrt(xnor);
	    for (i=1; i<=n; i++) hm[j][i]= hm[j][i]/xnor;
	    }

    return (lam);
}


function Epsdef () {

    var deps = [];
    var hmg = 0., ruf = 0.;
    var i, j, ip1;

    for (i=1;i<=n;i++) {
	    for (j=1;j<=mp1;j++) hm1[j] = hm[j][i];
	    hmg = Skabg(hm1,hm1,2,mp1);
	    deps[i] = Math.abs(h[1][i])/hmg;
	    }

    for (i=1;i<=n;i++) {
	    ip1=i+1;
	    for(j=ip1;j<=n;j++) {
    	    if (deps[i]<deps[j]) {
		        ruf = deps[j];
		        deps[j] = deps[i];
		        deps[i] = ruf;
		        }
    	    }
	    }

    EPS = (deps[IDEF] + deps[IDEF+1]) / 2.;

}

function Hb(hh, bb, nn) {

    var hb = 0.;
    var i;

    for (i=1; i<=nn; i++) hb += hh[i]*bb[i];

    return(hb);

}

function Skabg(a, b, i_nn, nn) {

    var ag = 0., skbg = 0.;
    var i;

    for (i=1; i<=nn; i++) ag = ag + a[i]*g[i];

    if (i_nn==1) {
	    skbg = (a[1]-ag)*b[1];
	    for (i=2;i<=nn;i++) {
    	    skbg = skbg + a[i]*b[i];
    	    }
	    return(skbg);
	    }
    else {
	    skbg = (a[1]-ag)*(a[1]-ag);
	    for (i=2;i<=nn;i++) {
    	    skbg = skbg + a[i]*a[i];
    	    }
	    }

    return(Math.sqrt(skbg));

}

-------------------------------------

2020-06-22T22:57:48.495Z: user: vladas
//#pragma sequential

dfltParams = {
    NORM : 1,
    IDEF : 1,
    MXMN : -1,
    DEL : 1.e-5,
    NIU : 0.1,
    EPS : 0.001,
    DZV : 0.2
    };

var NORM, // these must be explicitly defined to receive further values.
    IDEF,
    MXMN,
    DEL,
    NIU,
    EPS,
    DZV,
    NP1,
    MP1;

var rp = true;
params = {};
var dz = [0.,0.,0.];
var g = [], g_save = [];
var g5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]]; // prevent array from a jam by JSON.stringify
var h = [];
var hm = [];
var hm1 = [];
var sm = [], sn = [];
var sn5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var sp = [];
var x = [];
var x5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]]; 
var y = [];
var y5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var m = [];
var z = [];
var b = [];
var h1 = [];
var xg, fg;
var xg5 = [0,0,0,0,0,0,0,0,0];
var fg5 = [0,0,0,0,0,0,0,0,0];
var iter;
var kbh;
var pstr;
var effDEL;
var funcalls = 0, funcallsp;

var res = fs.readFileSync("linit.prm.json");
try {params = JSON.parse(res.toString(), null);}
catch(err){console.log(err.message);}

for (var p in dfltParams) {
    if (!params[p]) params[p] = dfltParams[p];
}

for (var p in params) {
    eval(p +'= params["'+p+'"]');  // I know it's ugly
}

var np1 = NP1;
var mp1 = MP1;
var np11 = np1+1, mp11 = mp1+1 ,i;
var kbh=0;

for (i=1; i<=mp1; i++) g[i]=0.;
g[1]=1.;

readex(true);

pstr = "NORM="+NORM+" IDEF="+IDEF+" MXMN="+MXMN+" DEL="+DEL+" NIU="+NIU+"\n EPS="+EPS+" DZV="+DZV+" MP1="+MP1+" NP1="+NP1;
console.log(pstr);
if (rp) fs.writeFileSync('linit.rpt.jsc', pstr+'\n');

var alfa, alf1;
var lamnor, niuf;
var xgnorm, xgnorm_min;
var xgnorm5 = [0,0,0,0,0,,0,0,0];
var  xg_min;
var ind=0, ind5=[0,0,0,0,0,0,0,0,0];
var i, j, k, k_max, k_min, n, ind_gt_3;
var i_n, i_n5 = [0,0,0,0,0,0,0,0,0];
var it_entr;
var DELsave, DELs;
var coef=[];

var start_time = new Date().getTime();
console.log(start_time);
if (rp) fs.appendFileSync('linit.rpt.jsc', start_time + "\n");
var finish_time;
var elapse_time;

var n=np1-1;
for (i=1;i<=n;i++) hm[1][i] = -1.*MXMN*hm[1][i];

if (NORM == 0) lamnor = Hnorm();
if (EPS == 0) Epsdef();

//#pragma wait
//#pragma cache hm
//#pragma cache sp
//#pragma cache sm
////#pragma cachefuncs
//#pragma sequential
iter = 1;
ind=0;
DELsave = DEL;
var EPS5=[EPS,EPS,EPS,EPS,EPS,EPS,EPS,EPS,EPS];
var xgnorm5 = [0,0,0,0,0,0,0,0,0];
var g5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var sn5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var eps = [];
h = [[0],[0],[0]];

cpvec(g, g_save);

if (rp)
    fs.appendFileSync('linit.rpt.jsc', "\nIter(k)      F(g)     (X,g)    //X//g   Ind Nr.       Eps      Alfa  It_entry\n");
console.log("\nIter(k)      F(g)     (X,g)    //X//g   Ind Nr.       Eps      Alfa  It_entry\n");

//#pragma dive
//#pragma sequential
while (iter<=5000 && ind != 3) {

    cpvec(EPS5, eps);

    DEL = DELsave;
    ind=2;

    if (iter == 1) k_max = 1;
    else k_max = 5;

//#pragma wait
//#pragma parallel
//#pragma noautoparvar
//#pragma parvar g5
//#pragma parvar sn5
//#pragma parvar x5
//#pragma parvar y5
//#pragma parvar xg5
//#pragma parvar fg5
//#pragma parvar ind5
//#pragma parvar i_n5
//#pragma parvar xgnorm5
//#pragma parvar EPS5
    for (k=1;k<=k_max;k++) {

        if (!k_min) k_min = 1;
        EPS = eps[k_min]; 

	    effDEL = DEL;
	    it_entr = 0;

	    m = [];
	    x = [];
	    fg=0.;

	    cpvec(g_save, g);

	    while (ind == 2) {

   	        i_n = Minxg(k, k_min, sm, sp);

	        for (var ii=1;ii<=n;ii++) {
		        for (j=1;j<=mp1;j++) hm1[j] = hm[j][ii];
		        h[2][ii] = Skabg(x,hm1,1,mp1);
		        }

	        ind=1;
	        DELs = DEL;

	        while (ind == 1) {

                ind = Analys(Mnxgco(), DZV);
		        xgnorm = Skabg(x,x,2,mp1);
		
		        it_entr = it_entr + 1;
		        if (it_entr%500 == 0) {
		            DEL = DEL * 2.0;
		            if (DEL > 0.3) DEL = 0.3;
		            effDEL = DEL;
	    
//		            if (rp)
//			        fs.appendFileSync('linit.rpt.jsc',""+it_entr + "  " + DEL + "\n");
		            console.log(""+it_entr + "  " + DEL);
		            }
		        } // while (ind == 1)
	    
    		DEL=DELs;
	        }  // while (ind == 2)

	        __set_Par_Var_Value('xgnorm5['+k+']', xgnorm, __job, true);

	        if (ind == 3) {
    
		        __set_Par_Var_Value('ind5['+k+']', ind, __job, true);
		        __set_Par_Var_Value('sn5['+k+']', sn, __job, true);
		        }

	        for (i=1; i<=mp1; i++) hm1[i] = hm[i][np1];

	        dz[1] = Hb(hm1,g,mp1);
	        dz[2] = Skabg(hm1,y,1,mp1);
	        alfa = Mxmnxg();
	        if (alfa != 0.) {
		        alf1 = 1.-alfa*y[1];
		        for (i=1; i<=mp1 ; i++) g[i] = alf1*g[i] + alfa*y[i];

	            __set_Par_Var_Value('g5['+k+']', g, __job, true);

	            xg = Hb(x,g,mp1);
	            if (rp)
    		        fs.appendFileSync('linit.rpt.jsc',strf(iter,4)+"("+k+") "+strf(fg,10)+" "+strf(xg,10)+" "+strf(xgnorm,10)+" "+strf(i_n,10)+" "+strf(EPS,10)+" "+strf(alfa,10)+" "+strf(it_entr,6)+"\n");
    	        console.log(strf(iter,4)+"("+k+") "+strf(fg,10)+" "+strf(xg,10)+" "+strf(xgnorm,10)+" "+strf(i_n,10)+" "+strf(EPS,10)+" "+strf(alfa,10)+" "+strf(it_entr,6));

	            niuf = 2.* Math.abs(fg-xg)/ Math.abs(fg+xg);
	            if (niuf < NIU / 2. ) {
		        EPS = EPS*1.25;
		        }

	        __set_Par_Var_Value('EPS5['+k+']', EPS, __job, true);
	        }
	    else {
	        console.log("Problem has no solution");
	        exit(1);
	        }
	    ind = 2;
	    } // end for

//#pragma wait
//#pragma sequential
    var xgnorm_min = xgnorm5[1];
    cpvec(EPS5, eps);

    k_min = 1;
    var ki=1;
    for (ki=1; ki<=k_max; ki++) {
	    if (xgnorm5[ki] < xgnorm_min) {
	        xgnorm_min = xgnorm5[ki];
	        k_min = ki;
	        }
	    if (ind5[ki] == 3) {ind=3; k_min=ki; break;}
	    }

	g_save = __get_Par_Var_Value('g5['+k_min+']', false, __job);
    xgnorm = xgnorm5[k_min];
    EPS = EPS5[k_min];    

    fs.appendFileSync('linit.rpt.jsc',"\nk_min="+k_min+"\n");
    console.log("\nk_min="+k_min+"\n");

    if (ind != 3) ind = ind5[k_min];
	else sn = __get_Par_Var_Value('sn5['+k_min+']', false, __job);

    iter=iter+1;
    }

//#pragma sequential
//#wait
if (ind != 3 ) {
    if (rp) fs.appendFileSync('linit.rpt.jsc'," No solution after more than 200 iterations !\n");
    console.log (" No solution after more than 500 iterations !\n");
    }

for (var i=1; i<=np1; i++) hm[1][i] = -1*MXMN*hm[1][i];

finish_time = new Date().getTime();
console.log(finish_time);
if (rp) fs.appendFileSync('linit.rpt.jsc', finish_time + "\n");
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec");
if (rp) fs.appendFileSync('linit.rpt.jsc', "Elapse time: " + elapse_time + " sec\n");

for (i=1;i<=np1-1;i++) {
    if (rp) fs.appendFileSync('linit.rpt.jsc',sn[i]+ "  ");
    if (i%3 == 0) {
        if (rp) fs.appendFileSync('linit.rpt.jsc', "\n");
        }
   }
if (rp) {
    fs.appendFileSync('linit.rpt.jsc', "\nXG="+xg+"   "+"FG="+fg+"\n");
    console.log("\nXG="+xg+"   "+"FG="+fg+"\n");
   }
console.log(" End of solution \n");

// Functions

function max(a,b) {
    return a > b ? a : b; 
}

function min(a,b) {
    return a < b ? a : b; 
}

function readex(fromfile) {

    var i, j;
    var data = {};
    var mp1 = MP1, np1 = NP1;

    if (fromfile) {
	    var res = fs.readFileSync("linit.data.json");
	    data = JSON.parse(res, null);
	    hm = data.hm;
	    sm = data.sm;
	    sp = data.sp;
	    }
}

function cpvec(av, bv) {

    if (!av) return;
    for (var ii=0; ii<av.length; ii++ ) bv[ii] = av[ii];

}

function strf(num, len) {

    var bl = "";
    for (var i=1; i<=len; i++) bl+=" ";
    var ns = num.toString() + bl;
    return ns.substr(0,len);
}


function Minxg(k, k_m, sm, sp) {

    var hmg;
    var i, j, i_n;
    coef = [0, 1.12, -1.18, 1.18, -1.18, 1.18, -1.18, 1.18, -1.18, 1.18];

    for (i=1; i<=n ;i++) {
	    for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
	    h[1][i] = Hb(hm1,g,mp1);
	    hmg = Skabg(hm1,hm1,2,mp1);

	    if ( h[1][i] > coef[k]*EPS*hmg ) sn[i] = sm[i];
	    else sn[i] = sp[i];
        }

    for (i=1; i<=mp1; i++) {
	    x[i] = hm[i][np1];
	    for (j=1; j<=n; j++) x[i] = x[i] + hm[i][j]*sn[j];
	    }

    fg = Hb(x,g,mp1);

    i_n=0;

    var kmul = (3-k_m)/2;  // adaptive variation
    for (i=1; i<=n; i++) {
	    for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
	    hmg = Skabg(hm1,hm1,2,mp1);
	    m[i]=0;
	    if (Math.abs(h[1][i]) <= (1.04+(k-kmul)*0.18)*EPS*hmg) { // was 0.8+k*0.2
    	    m[i] = 1;
    	    i_n++;
    	    }
	    }

    return(i_n);

}

function Analys(ind1, DZV) {

    var d=0., niuf=0., s=0., xgnorm=0.;
    var i, j, kt, ind = 0;

    xg = Hb(x,g,mp1);
    if (fg + xg != 0. ) {
	    niuf = 2.* Math.abs((fg-xg))/ Math.abs((fg+xg));
	    if (niuf > NIU ) {
    	    ind = 2;
    	    EPS = EPS*0.75;
    	    }
	    }

    if (ind != 2) {
	    kt = 0;
	    if (Math.abs((x[1]-xg)) > DEL ) kt = 1;
	    for (i=2; i<=mp1; i++) {
    	    if (Math.abs(x[i]) > DEL ) kt = 1;
    	    }
	    if ( kt == 0) ind = 3;
	    if ( ind != 3) {
    	    xgnorm = Skabg(x,x,2,mp1);
    	    y[1] = (x[1]-xg)/xgnorm;
    	    for (i=2; i<=mp1; i++) y[i] = x[i]/xgnorm;
    	    for (i=1; i<=n; i++) {
		        for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
		        h[2][i] = Skabg(hm1,y,1,mp1);
		        }
    	    d = 0.;
    	    for (i=1; i<=n; i++) {
		        if ( m[i] != 0 ) {
		            if (h[2][i] > 0.) s = sn[i] - sm[i];
		            else s = sn[i] - sp[i];
		            d = d + h[2][i]*s;
		            }
		        }
    	    d = d/xgnorm;
    	    if (d >= DZV) ind = 1;
    	    }
	    }

    if (ind1 == 0) return(0);
    return(ind);

}

function Mnxgco() {


    var dels = 0., del = 0., temp = 0.;
    var fdels = 0., fdels_old = 0., fdels_diff = 0.;

    var dz1, dz2, i, j;
    var iter_out = 0, iter_in = 0;

    do {
	    dz1 = 0;
	    dz2 = 0;

	    for (i=1; i<=n; i++) if (m[i]>0) m[i] = 2;

	    iter_in = 0;

	    do {

    	    if (dz1 == 0 && dz2 == 1 ) dz1 = 1;
    	    dz2 = 0;
    	    for (i=1; i<=n; i++) {
		        if ( m[i] == 2) {
		            for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
		            temp = Skabg(hm1,hm1,2,mp1);
		            del = Skabg(x,hm1,1,mp1)/(-temp*temp);
		            if (del < 0. ) dels=max(del,(sm[i]-sn[i]));
		            else dels=min(del,(sp[i]-sn[i]));
		            for (j=1; j<=mp1; j++) x[j] += dels*hm1[j];
		            sn[i] += dels;
		            if (sn[i]==sp[i] || sn[i]==sm[i]) {
			            m[i] = 1;
			            dz2 = 1;
			            }
		            }
		        }
    	    iter_in = iter_in + 1;
    	    fdels = Math.abs(dels);
    	    if (fdels < effDEL*effDEL) {
    		    return(1);
    		    }
    	    fdels_diff = (fdels_old == 0.) ? 1000. : Math.abs(fdels - fdels_old);
    	    fdels_old = fdels;
    	    } while (dz2 == 1);

	    iter_out=iter_out+1;
	    if (fdels_diff < effDEL*effDEL || iter_out%3000 == 0) {
	        effDEL = effDEL * 2.0;
	        }
	    } while(dz1==1 && dz2 == 0 && iter_out <= 7000);

    for (i=1; i<=n; i++)
        if (m[i] !=0 && sn[i]<sp[i] && sn[i] > sm[i]) m[i] = 2;

    return(1);
}


function Mxmnxg() {

    var bm = [0.,0.,1.], bp=[0.,1.,0.];
    var b = [0.,0.,1.]; 
    var z=[0.,0.,0.]; 
    h1=[0.,0.,0.];
    var i, j, itr = 0;

    Zdef(b, z);

    if (z[2] > 0.) {
	    return 0.;
	    }

    while(itr<=20) {

	    b[1] = (bp[1]+bm[1])/2.;
	    b[2] = (bp[2]+bm[2])/2.;
	    itr = itr + 1;
	    Zdef(b, z);

	    if (z[2] <= 0.) {
    	    bm[1] = b[1];
    	    bm[2] = b[2];
    	    }
	    else {
    	    bp[1] = b[1];
    	    bp[2] = b[2];
    	    }
	    }

    return(b[2]/b[1]);

}

function Zdef(b, z) {

    var sn1 = 0.;
    var i, j;

    for (i=1; i<=2; i++) {
	    z[i]=dz[i];
	    for (j=1; j<=n; j++) {
    	    h1[1]=h[1][j];
    	    h1[2]=h[2][j];
    	    if ( Hb(h1,b,2) > 0. ) sn1 = sm[j];
    	    else sn1 = sp[j];
    	    z[i] = z[i] + sn1*h[i][j];
    	    }
	    }

}

function Hnorm() {

    var lam = 0., xnor = 0.;
    var i, j;

    for (i=1; i<=n; i++) hm1[i] = hm[1][i];
    lam = Hb(hm1,hm1,n);
    lam = Math.sqrt(lam);
    for (i=1; i<=n; i++) hm[1][i]= hm[1][i]/lam;

    for (j=2; j<=mp1; j++) {
	    for (i=1; i<=n; i++) hm1[i] = hm[j][i];
	    xnor = Hb(hm1,hm1,n);
	    xnor = Math.sqrt(xnor);
	    for (i=1; i<=n; i++) hm[j][i]= hm[j][i]/xnor;
	    }

    return (lam);
}


function Epsdef () {

    var deps = [];
    var hmg = 0., ruf = 0.;
    var i, j, ip1;

    for (i=1;i<=n;i++) {
	    for (j=1;j<=mp1;j++) hm1[j] = hm[j][i];
	    hmg = Skabg(hm1,hm1,2,mp1);
	    deps[i] = Math.abs(h[1][i])/hmg;
	    }

    for (i=1;i<=n;i++) {
	    ip1=i+1;
	    for(j=ip1;j<=n;j++) {
    	    if (deps[i]<deps[j]) {
		        ruf = deps[j];
		        deps[j] = deps[i];
		        deps[i] = ruf;
		        }
    	    }
	    }

    EPS = (deps[IDEF] + deps[IDEF+1]) / 2.;

}

function Hb(hh, bb, nn) {

    var hb = 0.;
    var i;

    for (i=1; i<=nn; i++) hb += hh[i]*bb[i];

    return(hb);

}

function Skabg(a, b, i_nn, nn) {

    var ag = 0., skbg = 0.;
    var i;

    for (i=1; i<=nn; i++) ag = ag + a[i]*g[i];

    if (i_nn==1) {
	    skbg = (a[1]-ag)*b[1];
	    for (i=2;i<=nn;i++) {
    	    skbg = skbg + a[i]*b[i];
    	    }
	    return(skbg);
	    }
    else {
	    skbg = (a[1]-ag)*(a[1]-ag);
	    for (i=2;i<=nn;i++) {
    	    skbg = skbg + a[i]*a[i];
    	    }
	    }

    return(Math.sqrt(skbg));

}

-------------------------------------

2020-06-22T23:31:48.286Z: user: vladas
//#pragma sequential

dfltParams = {
    NORM : 1,
    IDEF : 1,
    MXMN : -1,
    DEL : 1.e-5,
    NIU : 0.1,
    EPS : 0.001,
    DZV : 0.2
    };

var NORM, // these must be explicitly defined to receive further values.
    IDEF,
    MXMN,
    DEL,
    NIU,
    EPS,
    DZV,
    NP1,
    MP1;

var rp = true;
params = {};
var dz = [0.,0.,0.];
var g = [], g_save = [];
var g5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]]; // prevent array from a jam by JSON.stringify
var h = [];
var hm = [];
var hm1 = [];
var sm = [], sn = [];
var sn5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var sp = [];
var x = [];
var x5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]]; 
var y = [];
var y5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var m = [];
var z = [];
var b = [];
var h1 = [];
var xg, fg;
var xg5 = [0,0,0,0,0,0,0,0,0];
var fg5 = [0,0,0,0,0,0,0,0,0];
var iter;
var kbh;
var pstr;
var effDEL;
var funcalls = 0, funcallsp;

var res = fs.readFileSync("linit.prm.json");
try {params = JSON.parse(res.toString(), null);}
catch(err){console.log(err.message);}

for (var p in dfltParams) {
    if (!params[p]) params[p] = dfltParams[p];
}

for (var p in params) {
    eval(p +'= params["'+p+'"]');  // I know it's ugly
}

var np1 = NP1;
var mp1 = MP1;
var np11 = np1+1, mp11 = mp1+1 ,i;
var kbh=0;

for (i=1; i<=mp1; i++) g[i]=0.;
g[1]=1.;

readex(true);

pstr = "NORM="+NORM+" IDEF="+IDEF+" MXMN="+MXMN+" DEL="+DEL+" NIU="+NIU+"\n EPS="+EPS+" DZV="+DZV+" MP1="+MP1+" NP1="+NP1;
console.log(pstr);
if (rp) fs.writeFileSync('linit.rpt.jsc', pstr+'\n');

var alfa, alf1;
var lamnor, niuf;
var xgnorm, xgnorm_min;
var xgnorm5 = [0,0,0,0,0,,0,0,0];
var  xg_min;
var ind=0, ind5=[0,0,0,0,0,0,0,0,0];
var i, j, k, k_max, k_min, n, ind_gt_3;
var i_n, i_n5 = [0,0,0,0,0,0,0,0,0];
var it_entr;
var DELsave, DELs;
var coef=[];

var start_time = new Date().getTime();
console.log(start_time);
if (rp) fs.appendFileSync('linit.rpt.jsc', start_time + "\n");
var finish_time;
var elapse_time;

var n=np1-1;
for (i=1;i<=n;i++) hm[1][i] = -1.*MXMN*hm[1][i];

if (NORM == 0) lamnor = Hnorm();
if (EPS == 0) Epsdef();

//#pragma wait
//#pragma cache hm
//#pragma cache sp
//#pragma cache sm
////#pragma cachefuncs
//#pragma sequential
iter = 1;
ind=0;
DELsave = DEL;
var EPS5=[EPS,EPS,EPS,EPS,EPS,EPS,EPS,EPS,EPS];
var xgnorm5 = [0,0,0,0,0,0,0,0,0];
var g5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var sn5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var eps = [];
h = [[0],[0],[0]];

cpvec(g, g_save);

if (rp)
    fs.appendFileSync('linit.rpt.jsc', "\nIter(k)      F(g)     (X,g)    //X//g   Ind Nr.       Eps      Alfa  It_entry\n");
console.log("\nIter(k)      F(g)     (X,g)    //X//g   Ind Nr.       Eps      Alfa  It_entry\n");

//#pragma dive
//#pragma sequential
while (iter<=5000 && ind != 3) {

    cpvec(EPS5, eps);

    DEL = DELsave;
    ind=2;

    if (iter == 1) k_max = 1;
    else k_max = 5;

//#pragma wait
//#pragma parallel
//#pragma noautoparvar
//#pragma parvar g5
//#pragma parvar sn5
//#pragma parvar x5
//#pragma parvar y5
//#pragma parvar xg5
//#pragma parvar fg5
//#pragma parvar ind5
//#pragma parvar i_n5
//#pragma parvar xgnorm5
//#pragma parvar EPS5
    for (k=1;k<=k_max;k++) {

        if (!k_min) k_min = 1;
        EPS = eps[k_min]; 

	    effDEL = DEL;
	    it_entr = 0;

	    m = [];
	    x = [];
	    fg=0.;

	    cpvec(g_save, g);

	    while (ind == 2) {

   	        i_n = Minxg(k, k_min, sm, sp);

	        for (var ii=1;ii<=n;ii++) {
		        for (j=1;j<=mp1;j++) hm1[j] = hm[j][ii];
		        h[2][ii] = Skabg(x,hm1,1,mp1);
		        }

	        ind=1;
	        DELs = DEL;

	        while (ind == 1) {

                ind = Analys(Mnxgco(), DZV);
		        xgnorm = Skabg(x,x,2,mp1);
		
		        it_entr = it_entr + 1;
		        if (it_entr%500 == 0) {
		            DEL = DEL * 2.0;
		            if (DEL > 0.3) DEL = 0.3;
		            effDEL = DEL;
	    
//		            if (rp)
//			        fs.appendFileSync('linit.rpt.jsc',""+it_entr + "  " + DEL + "\n");
		            console.log(""+it_entr + "  " + DEL);
		            }
		        } // while (ind == 1)
	    
    		DEL=DELs;
	        }  // while (ind == 2)

	        __set_Par_Var_Value('xgnorm5['+k+']', xgnorm, __job, true);

	        if (ind == 3) {
    
		        __set_Par_Var_Value('ind5['+k+']', ind, __job, true);
		        __set_Par_Var_Value('sn5['+k+']', sn, __job, true);
		        }

	        for (i=1; i<=mp1; i++) hm1[i] = hm[i][np1];

	        dz[1] = Hb(hm1,g,mp1);
	        dz[2] = Skabg(hm1,y,1,mp1);
	        alfa = Mxmnxg();
	        if (alfa != 0.) {
		        alf1 = 1.-alfa*y[1];
		        for (i=1; i<=mp1 ; i++) g[i] = alf1*g[i] + alfa*y[i];

	            __set_Par_Var_Value('g5['+k+']', g, __job, true);

	            xg = Hb(x,g,mp1);
	            if (rp)
    		        fs.appendFileSync('linit.rpt.jsc',strf(iter,4)+"("+k+") "+strf(fg,10)+" "+strf(xg,10)+" "+strf(xgnorm,10)+" "+strf(i_n,10)+" "+strf(EPS,10)+" "+strf(alfa,10)+" "+strf(it_entr,6)+"\n");
    	        console.log(strf(iter,4)+"("+k+") "+strf(fg,10)+" "+strf(xg,10)+" "+strf(xgnorm,10)+" "+strf(i_n,10)+" "+strf(EPS,10)+" "+strf(alfa,10)+" "+strf(it_entr,6));

	            niuf = 2.* Math.abs(fg-xg)/ Math.abs(fg+xg);
	            if (niuf < NIU / 2. ) {
		        EPS = EPS*1.25;
		        }

	        __set_Par_Var_Value('EPS5['+k+']', EPS, __job, true);
	        }
	    else {
	        console.log("Problem has no solution");
	        exit(1);
	        }
	    ind = 2;
	    } // end for

//#pragma wait
//#pragma sequential
    var xgnorm_min = xgnorm5[1];
    cpvec(EPS5, eps);

    k_min = 1;
    var ki=1;
    for (ki=1; ki<=k_max; ki++) {
	    if (xgnorm5[ki] < xgnorm_min) {
	        xgnorm_min = xgnorm5[ki];
	        k_min = ki;
	        }
	    if (ind5[ki] == 3) {ind=3; k_min=ki; break;}
	    }

	g_save = __get_Par_Var_Value('g5['+k_min+']', false, __job);
    xgnorm = xgnorm5[k_min];
    EPS = EPS5[k_min];    

    fs.appendFileSync('linit.rpt.jsc',"\nk_min="+k_min+"\n");
    console.log("\nk_min="+k_min+"\n");

    if (ind != 3) ind = ind5[k_min];
	else sn = __get_Par_Var_Value('sn5['+k_min+']', false, __job);

    iter=iter+1;
    }

//#pragma sequential
//#wait
if (ind != 3 ) {
    if (rp) fs.appendFileSync('linit.rpt.jsc'," No solution after more than 200 iterations !\n");
    console.log (" No solution after more than 500 iterations !\n");
    }

for (var i=1; i<=np1; i++) hm[1][i] = -1*MXMN*hm[1][i];

finish_time = new Date().getTime();
console.log(finish_time);
if (rp) fs.appendFileSync('linit.rpt.jsc', finish_time + "\n");
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec");
if (rp) fs.appendFileSync('linit.rpt.jsc', "Elapse time: " + elapse_time + " sec\n");

for (i=1;i<=np1-1;i++) {
    if (rp) fs.appendFileSync('linit.rpt.jsc',sn[i]+ "  ");
    if (i%3 == 0) {
        if (rp) fs.appendFileSync('linit.rpt.jsc', "\n");
        }
   }
if (rp) {
    fs.appendFileSync('linit.rpt.jsc', "\nXG="+xg+"   "+"FG="+fg+"\n");
    console.log("\nXG="+xg+"   "+"FG="+fg+"\n");
   }
console.log(" End of solution \n");

// Functions

function max(a,b) {
    return a > b ? a : b; 
}

function min(a,b) {
    return a < b ? a : b; 
}

function readex(fromfile) {

    var i, j;
    var data = {};
    var mp1 = MP1, np1 = NP1;

    if (fromfile) {
	    var res = fs.readFileSync("linit.data.json");
	    data = JSON.parse(res, null);
	    hm = data.hm;
	    sm = data.sm;
	    sp = data.sp;
	    }
}

function cpvec(av, bv) {

    if (!av) return;
    for (var ii=0; ii<av.length; ii++ ) bv[ii] = av[ii];

}

function strf(num, len) {

    var bl = "";
    for (var i=1; i<=len; i++) bl+=" ";
    var ns = num.toString() + bl;
    return ns.substr(0,len);
}


function Minxg(k, k_m, sm, sp) {

    var hmg;
    var i, j, i_n;
    coef = [0, 1.12, -1.18, 1.18, -1.18, 1.18, -1.18, 1.18, -1.18, 1.18];

    for (i=1; i<=n ;i++) {
	    for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
	    h[1][i] = Hb(hm1,g,mp1);
	    hmg = Skabg(hm1,hm1,2,mp1);

	    if ( h[1][i] > coef[k]*EPS*hmg ) sn[i] = sm[i];
	    else sn[i] = sp[i];
        }

    for (i=1; i<=mp1; i++) {
	    x[i] = hm[i][np1];
	    for (j=1; j<=n; j++) x[i] = x[i] + hm[i][j]*sn[j];
	    }

    fg = Hb(x,g,mp1);

    i_n=0;

    var kmul = (3-k_m)/3;  // adaptive variation
    for (i=1; i<=n; i++) {
	    for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
	    hmg = Skabg(hm1,hm1,2,mp1);
	    m[i]=0;
	    if (Math.abs(h[1][i]) <= (0.8+(k+kmul)*0.18)*EPS*hmg) { // was 0.8+k*0.2
    	    m[i] = 1;
    	    i_n++;
    	    }
	    }

    return(i_n);

}

function Analys(ind1, DZV) {

    var d=0., niuf=0., s=0., xgnorm=0.;
    var i, j, kt, ind = 0;

    xg = Hb(x,g,mp1);
    if (fg + xg != 0. ) {
	    niuf = 2.* Math.abs((fg-xg))/ Math.abs((fg+xg));
	    if (niuf > NIU ) {
    	    ind = 2;
    	    EPS = EPS*0.75;
    	    }
	    }

    if (ind != 2) {
	    kt = 0;
	    if (Math.abs((x[1]-xg)) > DEL ) kt = 1;
	    for (i=2; i<=mp1; i++) {
    	    if (Math.abs(x[i]) > DEL ) kt = 1;
    	    }
	    if ( kt == 0) ind = 3;
	    if ( ind != 3) {
    	    xgnorm = Skabg(x,x,2,mp1);
    	    y[1] = (x[1]-xg)/xgnorm;
    	    for (i=2; i<=mp1; i++) y[i] = x[i]/xgnorm;
    	    for (i=1; i<=n; i++) {
		        for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
		        h[2][i] = Skabg(hm1,y,1,mp1);
		        }
    	    d = 0.;
    	    for (i=1; i<=n; i++) {
		        if ( m[i] != 0 ) {
		            if (h[2][i] > 0.) s = sn[i] - sm[i];
		            else s = sn[i] - sp[i];
		            d = d + h[2][i]*s;
		            }
		        }
    	    d = d/xgnorm;
    	    if (d >= DZV) ind = 1;
    	    }
	    }

    if (ind1 == 0) return(0);
    return(ind);

}

function Mnxgco() {


    var dels = 0., del = 0., temp = 0.;
    var fdels = 0., fdels_old = 0., fdels_diff = 0.;

    var dz1, dz2, i, j;
    var iter_out = 0, iter_in = 0;

    do {
	    dz1 = 0;
	    dz2 = 0;

	    for (i=1; i<=n; i++) if (m[i]>0) m[i] = 2;

	    iter_in = 0;

	    do {

    	    if (dz1 == 0 && dz2 == 1 ) dz1 = 1;
    	    dz2 = 0;
    	    for (i=1; i<=n; i++) {
		        if ( m[i] == 2) {
		            for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
		            temp = Skabg(hm1,hm1,2,mp1);
		            del = Skabg(x,hm1,1,mp1)/(-temp*temp);
		            if (del < 0. ) dels=max(del,(sm[i]-sn[i]));
		            else dels=min(del,(sp[i]-sn[i]));
		            for (j=1; j<=mp1; j++) x[j] += dels*hm1[j];
		            sn[i] += dels;
		            if (sn[i]==sp[i] || sn[i]==sm[i]) {
			            m[i] = 1;
			            dz2 = 1;
			            }
		            }
		        }
    	    iter_in = iter_in + 1;
    	    fdels = Math.abs(dels);
    	    if (fdels < effDEL*effDEL) {
    		    return(1);
    		    }
    	    fdels_diff = (fdels_old == 0.) ? 1000. : Math.abs(fdels - fdels_old);
    	    fdels_old = fdels;
    	    } while (dz2 == 1);

	    iter_out=iter_out+1;
	    if (fdels_diff < effDEL*effDEL || iter_out%3000 == 0) {
	        effDEL = effDEL * 2.0;
	        }
	    } while(dz1==1 && dz2 == 0 && iter_out <= 7000);

    for (i=1; i<=n; i++)
        if (m[i] !=0 && sn[i]<sp[i] && sn[i] > sm[i]) m[i] = 2;

    return(1);
}


function Mxmnxg() {

    var bm = [0.,0.,1.], bp=[0.,1.,0.];
    var b = [0.,0.,1.]; 
    var z=[0.,0.,0.]; 
    h1=[0.,0.,0.];
    var i, j, itr = 0;

    Zdef(b, z);

    if (z[2] > 0.) {
	    return 0.;
	    }

    while(itr<=20) {

	    b[1] = (bp[1]+bm[1])/2.;
	    b[2] = (bp[2]+bm[2])/2.;
	    itr = itr + 1;
	    Zdef(b, z);

	    if (z[2] <= 0.) {
    	    bm[1] = b[1];
    	    bm[2] = b[2];
    	    }
	    else {
    	    bp[1] = b[1];
    	    bp[2] = b[2];
    	    }
	    }

    return(b[2]/b[1]);

}

function Zdef(b, z) {

    var sn1 = 0.;
    var i, j;

    for (i=1; i<=2; i++) {
	    z[i]=dz[i];
	    for (j=1; j<=n; j++) {
    	    h1[1]=h[1][j];
    	    h1[2]=h[2][j];
    	    if ( Hb(h1,b,2) > 0. ) sn1 = sm[j];
    	    else sn1 = sp[j];
    	    z[i] = z[i] + sn1*h[i][j];
    	    }
	    }

}

function Hnorm() {

    var lam = 0., xnor = 0.;
    var i, j;

    for (i=1; i<=n; i++) hm1[i] = hm[1][i];
    lam = Hb(hm1,hm1,n);
    lam = Math.sqrt(lam);
    for (i=1; i<=n; i++) hm[1][i]= hm[1][i]/lam;

    for (j=2; j<=mp1; j++) {
	    for (i=1; i<=n; i++) hm1[i] = hm[j][i];
	    xnor = Hb(hm1,hm1,n);
	    xnor = Math.sqrt(xnor);
	    for (i=1; i<=n; i++) hm[j][i]= hm[j][i]/xnor;
	    }

    return (lam);
}


function Epsdef () {

    var deps = [];
    var hmg = 0., ruf = 0.;
    var i, j, ip1;

    for (i=1;i<=n;i++) {
	    for (j=1;j<=mp1;j++) hm1[j] = hm[j][i];
	    hmg = Skabg(hm1,hm1,2,mp1);
	    deps[i] = Math.abs(h[1][i])/hmg;
	    }

    for (i=1;i<=n;i++) {
	    ip1=i+1;
	    for(j=ip1;j<=n;j++) {
    	    if (deps[i]<deps[j]) {
		        ruf = deps[j];
		        deps[j] = deps[i];
		        deps[i] = ruf;
		        }
    	    }
	    }

    EPS = (deps[IDEF] + deps[IDEF+1]) / 2.;

}

function Hb(hh, bb, nn) {

    var hb = 0.;
    var i;

    for (i=1; i<=nn; i++) hb += hh[i]*bb[i];

    return(hb);

}

function Skabg(a, b, i_nn, nn) {

    var ag = 0., skbg = 0.;
    var i;

    for (i=1; i<=nn; i++) ag = ag + a[i]*g[i];

    if (i_nn==1) {
	    skbg = (a[1]-ag)*b[1];
	    for (i=2;i<=nn;i++) {
    	    skbg = skbg + a[i]*b[i];
    	    }
	    return(skbg);
	    }
    else {
	    skbg = (a[1]-ag)*(a[1]-ag);
	    for (i=2;i<=nn;i++) {
    	    skbg = skbg + a[i]*a[i];
    	    }
	    }

    return(Math.sqrt(skbg));

}

-------------------------------------

2020-06-23T01:13:44.360Z: user: vladas
//#pragma sequential

dfltParams = {
    NORM : 1,
    IDEF : 1,
    MXMN : -1,
    DEL : 1.e-5,
    NIU : 0.1,
    EPS : 0.001,
    DZV : 0.2
    };

var NORM, // these must be explicitly defined to receive further values.
    IDEF,
    MXMN,
    DEL,
    NIU,
    EPS,
    DZV,
    NP1,
    MP1;

var rp = true;
params = {};
var dz = [0.,0.,0.];
var g = [], g_save = [];
var g5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]]; // prevent array from a jam by JSON.stringify
var h = [];
var hm = [];
var hm1 = [];
var sm = [], sn = [];
var sn5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var sp = [];
var x = [];
var x5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]]; 
var y = [];
var y5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var m = [];
var z = [];
var b = [];
var h1 = [];
var xg, fg;
var xg5 = [0,0,0,0,0,0,0,0,0];
var fg5 = [0,0,0,0,0,0,0,0,0];
var iter;
var kbh;
var pstr;
var effDEL;
var funcalls = 0, funcallsp;

var res = fs.readFileSync("linit.prm.json");
try {params = JSON.parse(res.toString(), null);}
catch(err){console.log(err.message);}

for (var p in dfltParams) {
    if (!params[p]) params[p] = dfltParams[p];
}

for (var p in params) {
    eval(p +'= params["'+p+'"]');  // I know it's ugly
}

var np1 = NP1;
var mp1 = MP1;
var np11 = np1+1, mp11 = mp1+1 ,i;
var kbh=0;

for (i=1; i<=mp1; i++) g[i]=0.;
g[1]=1.;

readex(true);

pstr = "NORM="+NORM+" IDEF="+IDEF+" MXMN="+MXMN+" DEL="+DEL+" NIU="+NIU+"\n EPS="+EPS+" DZV="+DZV+" MP1="+MP1+" NP1="+NP1;
console.log(pstr);
if (rp) fs.writeFileSync('linit.rpt.jsc', pstr+'\n');

var alfa, alf1;
var lamnor, niuf;
var xgnorm, xgnorm_min;
var xgnorm5 = [0,0,0,0,0,,0,0,0];
var  xg_min;
var ind=0, ind5=[0,0,0,0,0,0,0,0,0];
var i, j, k, k_max, k_min, n, ind_gt_3;
var i_n, i_n5 = [0,0,0,0,0,0,0,0,0];
var it_entr;
var DELsave, DELs;
var coef=[];

var start_time = new Date().getTime();
console.log(start_time);
if (rp) fs.appendFileSync('linit.rpt.jsc', start_time + "\n");
var finish_time;
var elapse_time;

var n=np1-1;
for (i=1;i<=n;i++) hm[1][i] = -1.*MXMN*hm[1][i];

if (NORM == 0) lamnor = Hnorm();
if (EPS == 0) Epsdef();

//#pragma wait
//#pragma cache hm
//#pragma cache sp
//#pragma cache sm
////#pragma cachefuncs
//#pragma sequential
iter = 1;
ind=0;
DELsave = DEL;
var EPS5=[EPS,EPS,EPS,EPS,EPS,EPS,EPS,EPS,EPS];
var xgnorm5 = [0,0,0,0,0,0,0,0,0];
var g5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var sn5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var eps = [];
h = [[0],[0],[0]];

cpvec(g, g_save);

if (rp)
    fs.appendFileSync('linit.rpt.jsc', "\nIter(k)      F(g)     (X,g)    //X//g   Ind Nr.       Eps      Alfa  It_entry\n");
console.log("\nIter(k)      F(g)     (X,g)    //X//g   Ind Nr.       Eps      Alfa  It_entry\n");

//#pragma dive
//#pragma sequential
while (iter<=5000 && ind != 3) {

    cpvec(EPS5, eps);

    DEL = DELsave;
    ind=2;

    if (iter == 1) k_max = 1;
    else k_max = 5;

//#pragma wait
//#pragma parallel
//#pragma noautoparvar
//#pragma parvar g5
//#pragma parvar sn5
//#pragma parvar x5
//#pragma parvar y5
//#pragma parvar xg5
//#pragma parvar fg5
//#pragma parvar ind5
//#pragma parvar i_n5
//#pragma parvar xgnorm5
//#pragma parvar EPS5
    for (k=1;k<=k_max;k++) {

        if (!k_min) k_min = 1;
        EPS = eps[k_min]; 

	    effDEL = DEL;
	    it_entr = 0;

	    m = [];
	    x = [];
	    fg=0.;

	    cpvec(g_save, g);

	    while (ind == 2) {

   	        i_n = Minxg(k, k_min, sm, sp);

	        for (var ii=1;ii<=n;ii++) {
		        for (j=1;j<=mp1;j++) hm1[j] = hm[j][ii];
		        h[2][ii] = Skabg(x,hm1,1,mp1);
		        }

	        ind=1;
	        DELs = DEL;

	        while (ind == 1) {

                ind = Analys(Mnxgco(), DZV);
		        xgnorm = Skabg(x,x,2,mp1);
		
		        it_entr = it_entr + 1;
		        if (it_entr%500 == 0) {
		            DEL = DEL * 2.0;
		            if (DEL > 0.3) DEL = 0.3;
		            effDEL = DEL;
	    
//		            if (rp)
//			        fs.appendFileSync('linit.rpt.jsc',""+it_entr + "  " + DEL + "\n");
		            console.log(""+it_entr + "  " + DEL);
		            }
		        } // while (ind == 1)
	    
    		DEL=DELs;
	        }  // while (ind == 2)

	        __set_Par_Var_Value('xgnorm5['+k+']', xgnorm, __job, true);

	        if (ind == 3) {
    
		        __set_Par_Var_Value('ind5['+k+']', ind, __job, true);
		        __set_Par_Var_Value('sn5['+k+']', sn, __job, true);
		        }

	        for (i=1; i<=mp1; i++) hm1[i] = hm[i][np1];

	        dz[1] = Hb(hm1,g,mp1);
	        dz[2] = Skabg(hm1,y,1,mp1);
	        alfa = Mxmnxg();
	        if (alfa != 0.) {
		        alf1 = 1.-alfa*y[1];
		        for (i=1; i<=mp1 ; i++) g[i] = alf1*g[i] + alfa*y[i];

	            __set_Par_Var_Value('g5['+k+']', g, __job, true);

	            xg = Hb(x,g,mp1);
	            if (rp)
    		        fs.appendFileSync('linit.rpt.jsc',strf(iter,4)+"("+k+") "+strf(fg,10)+" "+strf(xg,10)+" "+strf(xgnorm,10)+" "+strf(i_n,10)+" "+strf(EPS,10)+" "+strf(alfa,10)+" "+strf(it_entr,6)+"\n");
    	        console.log(strf(iter,4)+"("+k+") "+strf(fg,10)+" "+strf(xg,10)+" "+strf(xgnorm,10)+" "+strf(i_n,10)+" "+strf(EPS,10)+" "+strf(alfa,10)+" "+strf(it_entr,6));

	            niuf = 2.* Math.abs(fg-xg)/ Math.abs(fg+xg);
	            if (niuf < NIU / 2. ) {
		        EPS = EPS*1.25;
		        }

	        __set_Par_Var_Value('EPS5['+k+']', EPS, __job, true);
	        }
	    else {
	        console.log("Problem has no solution");
	        exit(1);
	        }
	    ind = 2;
	    } // end for

//#pragma wait
//#pragma sequential
    var xgnorm_min = xgnorm5[1];
    cpvec(EPS5, eps);

    k_min = 1;
    var ki=1;
    for (ki=1; ki<=k_max; ki++) {
	    if (xgnorm5[ki] < xgnorm_min) {
	        xgnorm_min = xgnorm5[ki];
	        k_min = ki;
	        }
	    if (ind5[ki] == 3) {ind=3; k_min=ki; break;}
	    }

	g_save = __get_Par_Var_Value('g5['+k_min+']', false, __job);
    xgnorm = xgnorm5[k_min];
    EPS = EPS5[k_min];    

    fs.appendFileSync('linit.rpt.jsc',"\nk_min="+k_min+"\n");
    console.log("\nk_min="+k_min+"\n");

    if (ind != 3) ind = ind5[k_min];
	else sn = __get_Par_Var_Value('sn5['+k_min+']', false, __job);

    iter=iter+1;
    }

//#pragma sequential
//#wait
if (ind != 3 ) {
    if (rp) fs.appendFileSync('linit.rpt.jsc'," No solution after more than 200 iterations !\n");
    console.log (" No solution after more than 500 iterations !\n");
    }

for (var i=1; i<=np1; i++) hm[1][i] = -1*MXMN*hm[1][i];

finish_time = new Date().getTime();
console.log(finish_time);
if (rp) fs.appendFileSync('linit.rpt.jsc', finish_time + "\n");
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec");
if (rp) fs.appendFileSync('linit.rpt.jsc', "Elapse time: " + elapse_time + " sec\n");

for (i=1;i<=np1-1;i++) {
    if (rp) fs.appendFileSync('linit.rpt.jsc',sn[i]+ "  ");
    if (i%3 == 0) {
        if (rp) fs.appendFileSync('linit.rpt.jsc', "\n");
        }
   }
if (rp) {
    fs.appendFileSync('linit.rpt.jsc', "\nXG="+xg+"   "+"FG="+fg+"\n");
    console.log("\nXG="+xg+"   "+"FG="+fg+"\n");
   }
console.log(" End of solution \n");

// Functions

function max(a,b) {
    return a > b ? a : b; 
}

function min(a,b) {
    return a < b ? a : b; 
}

function readex(fromfile) {

    var i, j;
    var data = {};
    var mp1 = MP1, np1 = NP1;

    if (fromfile) {
	    var res = fs.readFileSync("linit.data.json");
	    data = JSON.parse(res, null);
	    hm = data.hm;
	    sm = data.sm;
	    sp = data.sp;
	    }
}

function cpvec(av, bv) {

    if (!av) return;
    for (var ii=0; ii<av.length; ii++ ) bv[ii] = av[ii];

}

function strf(num, len) {

    var bl = "";
    for (var i=1; i<=len; i++) bl+=" ";
    var ns = num.toString() + bl;
    return ns.substr(0,len);
}


function Minxg(k, k_m, sm, sp) {

    var hmg;
    var i, j, i_n;
    coef = [0, 1.12, -1.18, 1.18, -1.18, 1.18, -1.18, 1.18, -1.18, 1.18];

    for (i=1; i<=n ;i++) {
	    for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
	    h[1][i] = Hb(hm1,g,mp1);
	    hmg = Skabg(hm1,hm1,2,mp1);

	    if ( h[1][i] > coef[k]*EPS*hmg ) sn[i] = sm[i];
	    else sn[i] = sp[i];
        }

    for (i=1; i<=mp1; i++) {
	    x[i] = hm[i][np1];
	    for (j=1; j<=n; j++) x[i] = x[i] + hm[i][j]*sn[j];
	    }

    fg = Hb(x,g,mp1);

    i_n=0;

    var kmul = (3-k_m)/3;  // adaptive variation
    for (i=1; i<=n; i++) {
	    for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
	    hmg = Skabg(hm1,hm1,2,mp1);
	    m[i]=0;
	    if (Math.abs(h[1][i]) <= (0.8+(k-kmul)*0.18)*EPS*hmg) { // was 0.8+k*0.2
    	    m[i] = 1;
    	    i_n++;
    	    }
	    }

    return(i_n);

}

function Analys(ind1, DZV) {

    var d=0., niuf=0., s=0., xgnorm=0.;
    var i, j, kt, ind = 0;

    xg = Hb(x,g,mp1);
    if (fg + xg != 0. ) {
	    niuf = 2.* Math.abs((fg-xg))/ Math.abs((fg+xg));
	    if (niuf > NIU ) {
    	    ind = 2;
    	    EPS = EPS*0.75;
    	    }
	    }

    if (ind != 2) {
	    kt = 0;
	    if (Math.abs((x[1]-xg)) > DEL ) kt = 1;
	    for (i=2; i<=mp1; i++) {
    	    if (Math.abs(x[i]) > DEL ) kt = 1;
    	    }
	    if ( kt == 0) ind = 3;
	    if ( ind != 3) {
    	    xgnorm = Skabg(x,x,2,mp1);
    	    y[1] = (x[1]-xg)/xgnorm;
    	    for (i=2; i<=mp1; i++) y[i] = x[i]/xgnorm;
    	    for (i=1; i<=n; i++) {
		        for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
		        h[2][i] = Skabg(hm1,y,1,mp1);
		        }
    	    d = 0.;
    	    for (i=1; i<=n; i++) {
		        if ( m[i] != 0 ) {
		            if (h[2][i] > 0.) s = sn[i] - sm[i];
		            else s = sn[i] - sp[i];
		            d = d + h[2][i]*s;
		            }
		        }
    	    d = d/xgnorm;
    	    if (d >= DZV) ind = 1;
    	    }
	    }

    if (ind1 == 0) return(0);
    return(ind);

}

function Mnxgco() {


    var dels = 0., del = 0., temp = 0.;
    var fdels = 0., fdels_old = 0., fdels_diff = 0.;

    var dz1, dz2, i, j;
    var iter_out = 0, iter_in = 0;

    do {
	    dz1 = 0;
	    dz2 = 0;

	    for (i=1; i<=n; i++) if (m[i]>0) m[i] = 2;

	    iter_in = 0;

	    do {

    	    if (dz1 == 0 && dz2 == 1 ) dz1 = 1;
    	    dz2 = 0;
    	    for (i=1; i<=n; i++) {
		        if ( m[i] == 2) {
		            for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
		            temp = Skabg(hm1,hm1,2,mp1);
		            del = Skabg(x,hm1,1,mp1)/(-temp*temp);
		            if (del < 0. ) dels=max(del,(sm[i]-sn[i]));
		            else dels=min(del,(sp[i]-sn[i]));
		            for (j=1; j<=mp1; j++) x[j] += dels*hm1[j];
		            sn[i] += dels;
		            if (sn[i]==sp[i] || sn[i]==sm[i]) {
			            m[i] = 1;
			            dz2 = 1;
			            }
		            }
		        }
    	    iter_in = iter_in + 1;
    	    fdels = Math.abs(dels);
    	    if (fdels < effDEL*effDEL) {
    		    return(1);
    		    }
    	    fdels_diff = (fdels_old == 0.) ? 1000. : Math.abs(fdels - fdels_old);
    	    fdels_old = fdels;
    	    } while (dz2 == 1);

	    iter_out=iter_out+1;
	    if (fdels_diff < effDEL*effDEL || iter_out%3000 == 0) {
	        effDEL = effDEL * 2.0;
	        }
	    } while(dz1==1 && dz2 == 0 && iter_out <= 7000);

    for (i=1; i<=n; i++)
        if (m[i] !=0 && sn[i]<sp[i] && sn[i] > sm[i]) m[i] = 2;

    return(1);
}


function Mxmnxg() {

    var bm = [0.,0.,1.], bp=[0.,1.,0.];
    var b = [0.,0.,1.]; 
    var z=[0.,0.,0.]; 
    h1=[0.,0.,0.];
    var i, j, itr = 0;

    Zdef(b, z);

    if (z[2] > 0.) {
	    return 0.;
	    }

    while(itr<=20) {

	    b[1] = (bp[1]+bm[1])/2.;
	    b[2] = (bp[2]+bm[2])/2.;
	    itr = itr + 1;
	    Zdef(b, z);

	    if (z[2] <= 0.) {
    	    bm[1] = b[1];
    	    bm[2] = b[2];
    	    }
	    else {
    	    bp[1] = b[1];
    	    bp[2] = b[2];
    	    }
	    }

    return(b[2]/b[1]);

}

function Zdef(b, z) {

    var sn1 = 0.;
    var i, j;

    for (i=1; i<=2; i++) {
	    z[i]=dz[i];
	    for (j=1; j<=n; j++) {
    	    h1[1]=h[1][j];
    	    h1[2]=h[2][j];
    	    if ( Hb(h1,b,2) > 0. ) sn1 = sm[j];
    	    else sn1 = sp[j];
    	    z[i] = z[i] + sn1*h[i][j];
    	    }
	    }

}

function Hnorm() {

    var lam = 0., xnor = 0.;
    var i, j;

    for (i=1; i<=n; i++) hm1[i] = hm[1][i];
    lam = Hb(hm1,hm1,n);
    lam = Math.sqrt(lam);
    for (i=1; i<=n; i++) hm[1][i]= hm[1][i]/lam;

    for (j=2; j<=mp1; j++) {
	    for (i=1; i<=n; i++) hm1[i] = hm[j][i];
	    xnor = Hb(hm1,hm1,n);
	    xnor = Math.sqrt(xnor);
	    for (i=1; i<=n; i++) hm[j][i]= hm[j][i]/xnor;
	    }

    return (lam);
}


function Epsdef () {

    var deps = [];
    var hmg = 0., ruf = 0.;
    var i, j, ip1;

    for (i=1;i<=n;i++) {
	    for (j=1;j<=mp1;j++) hm1[j] = hm[j][i];
	    hmg = Skabg(hm1,hm1,2,mp1);
	    deps[i] = Math.abs(h[1][i])/hmg;
	    }

    for (i=1;i<=n;i++) {
	    ip1=i+1;
	    for(j=ip1;j<=n;j++) {
    	    if (deps[i]<deps[j]) {
		        ruf = deps[j];
		        deps[j] = deps[i];
		        deps[i] = ruf;
		        }
    	    }
	    }

    EPS = (deps[IDEF] + deps[IDEF+1]) / 2.;

}

function Hb(hh, bb, nn) {

    var hb = 0.;
    var i;

    for (i=1; i<=nn; i++) hb += hh[i]*bb[i];

    return(hb);

}

function Skabg(a, b, i_nn, nn) {

    var ag = 0., skbg = 0.;
    var i;

    for (i=1; i<=nn; i++) ag = ag + a[i]*g[i];

    if (i_nn==1) {
	    skbg = (a[1]-ag)*b[1];
	    for (i=2;i<=nn;i++) {
    	    skbg = skbg + a[i]*b[i];
    	    }
	    return(skbg);
	    }
    else {
	    skbg = (a[1]-ag)*(a[1]-ag);
	    for (i=2;i<=nn;i++) {
    	    skbg = skbg + a[i]*a[i];
    	    }
	    }

    return(Math.sqrt(skbg));

}

-------------------------------------

2020-06-23T08:04:11.371Z: user: vladas
//#pragma sequential

dfltParams = {
    NORM : 1,
    IDEF : 1,
    MXMN : -1,
    DEL : 1.e-5,
    NIU : 0.1,
    EPS : 0.001,
    DZV : 0.2
    };

var NORM, // these must be explicitly defined to receive further values.
    IDEF,
    MXMN,
    DEL,
    NIU,
    EPS,
    DZV,
    NP1,
    MP1;

var rp = true;
params = {};
var dz = [0.,0.,0.];
var g = [], g_save = [];
var g5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]]; // prevent array from a jam by JSON.stringify
var h = [];
var hm = [];
var hm1 = [];
var sm = [], sn = [];
var sn5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var sp = [];
var x = [];
var x5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]]; 
var y = [];
var y5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var m = [];
var z = [];
var b = [];
var h1 = [];
var xg, fg;
var xg5 = [0,0,0,0,0,0,0,0,0];
var fg5 = [0,0,0,0,0,0,0,0,0];
var iter;
var kbh;
var pstr;
var effDEL;
var funcalls = 0, funcallsp;

var res = fs.readFileSync("linit.prm.json");
try {params = JSON.parse(res.toString(), null);}
catch(err){console.log(err.message);}

for (var p in dfltParams) {
    if (!params[p]) params[p] = dfltParams[p];
}

for (var p in params) {
    eval(p +'= params["'+p+'"]');  // I know it's ugly
}

var np1 = NP1;
var mp1 = MP1;
var np11 = np1+1, mp11 = mp1+1 ,i;
var kbh=0;

for (i=1; i<=mp1; i++) g[i]=0.;
g[1]=1.;

readex(true);

pstr = "NORM="+NORM+" IDEF="+IDEF+" MXMN="+MXMN+" DEL="+DEL+" NIU="+NIU+"\n EPS="+EPS+" DZV="+DZV+" MP1="+MP1+" NP1="+NP1;
console.log(pstr);
if (rp) fs.writeFileSync('linit.rpt.jsc', pstr+'\n');

var alfa, alf1;
var lamnor, niuf;
var xgnorm, xgnorm_min;
var xgnorm5 = [0,0,0,0,0,,0,0,0];
var  xg_min;
var ind=0, ind5=[0,0,0,0,0,0,0,0,0];
var i, j, k, k_max, k_min, n, ind_gt_3;
var i_n, i_n5 = [0,0,0,0,0,0,0,0,0];
var it_entr;
var DELsave, DELs;
var coef=[];

var start_time = new Date().getTime();
console.log(start_time);
if (rp) fs.appendFileSync('linit.rpt.jsc', start_time + "\n");
var finish_time;
var elapse_time;

var n=np1-1;
for (i=1;i<=n;i++) hm[1][i] = -1.*MXMN*hm[1][i];

if (NORM == 0) lamnor = Hnorm();
if (EPS == 0) Epsdef();

//#pragma wait
//#pragma cache hm
//#pragma cache sp
//#pragma cache sm
////#pragma cachefuncs
//#pragma sequential
iter = 1;
ind=0;
DELsave = DEL;
var EPS5=[EPS,EPS,EPS,EPS,EPS,EPS,EPS,EPS,EPS];
var xgnorm5 = [0,0,0,0,0,0,0,0,0];
var g5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var sn5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var eps = [];
h = [[0],[0],[0]];

cpvec(g, g_save);

if (rp)
    fs.appendFileSync('linit.rpt.jsc', "\nIter(k)      F(g)     (X,g)    //X//g   Ind Nr.       Eps      Alfa  It_entry\n");
console.log("\nIter(k)      F(g)     (X,g)    //X//g   Ind Nr.       Eps      Alfa  It_entry\n");

//#pragma dive
//#pragma sequential
while (iter<=5000 && ind != 3) {

    cpvec(EPS5, eps);

    DEL = DELsave;
    ind=2;

    if (iter == 1) k_max = 1;
    else k_max = 5;

//#pragma wait
//#pragma parallel
//#pragma noautoparvar
//#pragma parvar g5
//#pragma parvar sn5
//#pragma parvar x5
//#pragma parvar y5
//#pragma parvar xg5
//#pragma parvar fg5
//#pragma parvar ind5
//#pragma parvar i_n5
//#pragma parvar xgnorm5
//#pragma parvar EPS5
    for (k=1;k<=k_max;k++) {

        if (!k_min) k_min = 1;
        EPS = eps[k_min]; 

	    effDEL = DEL;
	    it_entr = 0;

	    m = [];
	    x = [];
	    fg=0.;

	    cpvec(g_save, g);

	    while (ind == 2) {

   	        i_n = Minxg(k, k_min, sm, sp);

	        for (var ii=1;ii<=n;ii++) {
		        for (j=1;j<=mp1;j++) hm1[j] = hm[j][ii];
		        h[2][ii] = Skabg(x,hm1,1,mp1);
		        }

	        ind=1;
	        DELs = DEL;

	        while (ind == 1) {

                ind = Analys(Mnxgco(), DZV);
		        xgnorm = Skabg(x,x,2,mp1);
		
		        it_entr = it_entr + 1;
		        if (it_entr%500 == 0) {
		            DEL = DEL * 2.0;
		            if (DEL > 0.3) DEL = 0.3;
		            effDEL = DEL;
	    
//		            if (rp)
//			        fs.appendFileSync('linit.rpt.jsc',""+it_entr + "  " + DEL + "\n");
		            console.log(""+it_entr + "  " + DEL);
		            }
		        } // while (ind == 1)
	    
    		DEL=DELs;
	        }  // while (ind == 2)

	        __set_Par_Var_Value('xgnorm5['+k+']', xgnorm, __job, true);

	        if (ind == 3) {
    
		        __set_Par_Var_Value('ind5['+k+']', ind, __job, true);
		        __set_Par_Var_Value('sn5['+k+']', sn, __job, true);
		        }

	        for (i=1; i<=mp1; i++) hm1[i] = hm[i][np1];

	        dz[1] = Hb(hm1,g,mp1);
	        dz[2] = Skabg(hm1,y,1,mp1);
	        alfa = Mxmnxg();
	        if (alfa != 0.) {
		        alf1 = 1.-alfa*y[1];
		        for (i=1; i<=mp1 ; i++) g[i] = alf1*g[i] + alfa*y[i];

	            __set_Par_Var_Value('g5['+k+']', g, __job, true);

	            xg = Hb(x,g,mp1);
	            if (rp)
    		        fs.appendFileSync('linit.rpt.jsc',strf(iter,4)+"("+k+") "+strf(fg,10)+" "+strf(xg,10)+" "+strf(xgnorm,10)+" "+strf(i_n,10)+" "+strf(EPS,10)+" "+strf(alfa,10)+" "+strf(it_entr,6)+"\n");
    	        console.log(strf(iter,4)+"("+k+") "+strf(fg,10)+" "+strf(xg,10)+" "+strf(xgnorm,10)+" "+strf(i_n,10)+" "+strf(EPS,10)+" "+strf(alfa,10)+" "+strf(it_entr,6));

	            niuf = 2.* Math.abs(fg-xg)/ Math.abs(fg+xg);
	            if (niuf < NIU / 2. ) {
		        EPS = EPS*1.25;
		        }

	        __set_Par_Var_Value('EPS5['+k+']', EPS, __job, true);
	        }
	    else {
	        console.log("Problem has no solution");
	        exit(1);
	        }
	    ind = 2;
	    } // end for

//#pragma wait
//#pragma sequential
    var xgnorm_min = xgnorm5[1];
    cpvec(EPS5, eps);

    k_min = 1;
    var ki=1;
    for (ki=1; ki<=k_max; ki++) {
	    if (xgnorm5[ki] < xgnorm_min) {
	        xgnorm_min = xgnorm5[ki];
	        k_min = ki;
	        }
	    if (ind5[ki] == 3) {ind=3; k_min=ki; break;}
	    }

	g_save = __get_Par_Var_Value('g5['+k_min+']', false, __job);
    xgnorm = xgnorm5[k_min];
    EPS = EPS5[k_min];    

    fs.appendFileSync('linit.rpt.jsc',"\nk_min="+k_min+"\n");
    console.log("\nk_min="+k_min+"\n");

    if (ind != 3) ind = ind5[k_min];
	else sn = __get_Par_Var_Value('sn5['+k_min+']', false, __job);

    iter=iter+1;
    }

//#pragma sequential
//#wait
if (ind != 3 ) {
    if (rp) fs.appendFileSync('linit.rpt.jsc'," No solution after more than 200 iterations !\n");
    console.log (" No solution after more than 500 iterations !\n");
    }

for (var i=1; i<=np1; i++) hm[1][i] = -1*MXMN*hm[1][i];

finish_time = new Date().getTime();
console.log(finish_time);
if (rp) fs.appendFileSync('linit.rpt.jsc', finish_time + "\n");
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec");
if (rp) fs.appendFileSync('linit.rpt.jsc', "Elapse time: " + elapse_time + " sec\n");

for (i=1;i<=np1-1;i++) {
    if (rp) fs.appendFileSync('linit.rpt.jsc',sn[i]+ "  ");
    if (i%3 == 0) {
        if (rp) fs.appendFileSync('linit.rpt.jsc', "\n");
        }
   }
if (rp) {
    fs.appendFileSync('linit.rpt.jsc', "\nXG="+xg+"   "+"FG="+fg+"\n");
    console.log("\nXG="+xg+"   "+"FG="+fg+"\n");
   }
console.log(" End of solution \n");

// Functions

function max(a,b) {
    return a > b ? a : b; 
}

function min(a,b) {
    return a < b ? a : b; 
}

function readex(fromfile) {

    var i, j;
    var data = {};
    var mp1 = MP1, np1 = NP1;

    if (fromfile) {
	    var res = fs.readFileSync("linit.data.json");
	    data = JSON.parse(res, null);
	    hm = data.hm;
	    sm = data.sm;
	    sp = data.sp;
	    }
}

function cpvec(av, bv) {

    if (!av) return;
    for (var ii=0; ii<av.length; ii++ ) bv[ii] = av[ii];

}

function strf(num, len) {

    var bl = "";
    for (var i=1; i<=len; i++) bl+=" ";
    var ns = num.toString() + bl;
    return ns.substr(0,len);
}


function Minxg(k, k_m, sm, sp) {

    var hmg;
    var i, j, i_n;
    coef = [0, 1.12, -1.18, 1.18, -1.18, 1.18, -1.18, 1.18, -1.18, 1.18];

    for (i=1; i<=n ;i++) {
	    for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
	    h[1][i] = Hb(hm1,g,mp1);
	    hmg = Skabg(hm1,hm1,2,mp1);

	    if ( h[1][i] > coef[k]*EPS*hmg ) sn[i] = sm[i];
	    else sn[i] = sp[i];
        }

    for (i=1; i<=mp1; i++) {
	    x[i] = hm[i][np1];
	    for (j=1; j<=n; j++) x[i] = x[i] + hm[i][j]*sn[j];
	    }

    fg = Hb(x,g,mp1);

    i_n=0;

    var kmul = (3-k_m)/3;  // adaptive variation
    for (i=1; i<=n; i++) {
	    for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
	    hmg = Skabg(hm1,hm1,2,mp1);
	    m[i]=0;
	    if (Math.abs(h[1][i]) <= (0.8+(k+kmul)*0.18)*EPS*hmg) { // was 0.8+k*0.2
    	    m[i] = 1;
    	    i_n++;
    	    }
	    }

    return(i_n);

}

function Analys(ind1, DZV) {

    var d=0., niuf=0., s=0., xgnorm=0.;
    var i, j, kt, ind = 0;

    xg = Hb(x,g,mp1);
    if (fg + xg != 0. ) {
	    niuf = 2.* Math.abs((fg-xg))/ Math.abs((fg+xg));
	    if (niuf > NIU ) {
    	    ind = 2;
    	    EPS = EPS*0.75;
    	    }
	    }

    if (ind != 2) {
	    kt = 0;
	    if (Math.abs((x[1]-xg)) > DEL ) kt = 1;
	    for (i=2; i<=mp1; i++) {
    	    if (Math.abs(x[i]) > DEL ) kt = 1;
    	    }
	    if ( kt == 0) ind = 3;
	    if ( ind != 3) {
    	    xgnorm = Skabg(x,x,2,mp1);
    	    y[1] = (x[1]-xg)/xgnorm;
    	    for (i=2; i<=mp1; i++) y[i] = x[i]/xgnorm;
    	    for (i=1; i<=n; i++) {
		        for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
		        h[2][i] = Skabg(hm1,y,1,mp1);
		        }
    	    d = 0.;
    	    for (i=1; i<=n; i++) {
		        if ( m[i] != 0 ) {
		            if (h[2][i] > 0.) s = sn[i] - sm[i];
		            else s = sn[i] - sp[i];
		            d = d + h[2][i]*s;
		            }
		        }
    	    d = d/xgnorm;
    	    if (d >= DZV) ind = 1;
    	    }
	    }

    if (ind1 == 0) return(0);
    return(ind);

}

function Mnxgco() {


    var dels = 0., del = 0., temp = 0.;
    var fdels = 0., fdels_old = 0., fdels_diff = 0.;

    var dz1, dz2, i, j;
    var iter_out = 0, iter_in = 0;

    do {
	    dz1 = 0;
	    dz2 = 0;

	    for (i=1; i<=n; i++) if (m[i]>0) m[i] = 2;

	    iter_in = 0;

	    do {

    	    if (dz1 == 0 && dz2 == 1 ) dz1 = 1;
    	    dz2 = 0;
    	    for (i=1; i<=n; i++) {
		        if ( m[i] == 2) {
		            for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
		            temp = Skabg(hm1,hm1,2,mp1);
		            del = Skabg(x,hm1,1,mp1)/(-temp*temp);
		            if (del < 0. ) dels=max(del,(sm[i]-sn[i]));
		            else dels=min(del,(sp[i]-sn[i]));
		            for (j=1; j<=mp1; j++) x[j] += dels*hm1[j];
		            sn[i] += dels;
		            if (sn[i]==sp[i] || sn[i]==sm[i]) {
			            m[i] = 1;
			            dz2 = 1;
			            }
		            }
		        }
    	    iter_in = iter_in + 1;
    	    fdels = Math.abs(dels);
    	    if (fdels < effDEL*effDEL) {
    		    return(1);
    		    }
    	    fdels_diff = (fdels_old == 0.) ? 1000. : Math.abs(fdels - fdels_old);
    	    fdels_old = fdels;
    	    } while (dz2 == 1);

	    iter_out=iter_out+1;
	    if (fdels_diff < effDEL*effDEL || iter_out%3000 == 0) {
	        effDEL = effDEL * 2.0;
	        }
	    } while(dz1==1 && dz2 == 0 && iter_out <= 7000);

    for (i=1; i<=n; i++)
        if (m[i] !=0 && sn[i]<sp[i] && sn[i] > sm[i]) m[i] = 2;

    return(1);
}


function Mxmnxg() {

    var bm = [0.,0.,1.], bp=[0.,1.,0.];
    var b = [0.,0.,1.]; 
    var z=[0.,0.,0.]; 
    h1=[0.,0.,0.];
    var i, j, itr = 0;

    Zdef(b, z);

    if (z[2] > 0.) {
	    return 0.;
	    }

    while(itr<=20) {

	    b[1] = (bp[1]+bm[1])/2.;
	    b[2] = (bp[2]+bm[2])/2.;
	    itr = itr + 1;
	    Zdef(b, z);

	    if (z[2] <= 0.) {
    	    bm[1] = b[1];
    	    bm[2] = b[2];
    	    }
	    else {
    	    bp[1] = b[1];
    	    bp[2] = b[2];
    	    }
	    }

    return(b[2]/b[1]);

}

function Zdef(b, z) {

    var sn1 = 0.;
    var i, j;

    for (i=1; i<=2; i++) {
	    z[i]=dz[i];
	    for (j=1; j<=n; j++) {
    	    h1[1]=h[1][j];
    	    h1[2]=h[2][j];
    	    if ( Hb(h1,b,2) > 0. ) sn1 = sm[j];
    	    else sn1 = sp[j];
    	    z[i] = z[i] + sn1*h[i][j];
    	    }
	    }

}

function Hnorm() {

    var lam = 0., xnor = 0.;
    var i, j;

    for (i=1; i<=n; i++) hm1[i] = hm[1][i];
    lam = Hb(hm1,hm1,n);
    lam = Math.sqrt(lam);
    for (i=1; i<=n; i++) hm[1][i]= hm[1][i]/lam;

    for (j=2; j<=mp1; j++) {
	    for (i=1; i<=n; i++) hm1[i] = hm[j][i];
	    xnor = Hb(hm1,hm1,n);
	    xnor = Math.sqrt(xnor);
	    for (i=1; i<=n; i++) hm[j][i]= hm[j][i]/xnor;
	    }

    return (lam);
}


function Epsdef () {

    var deps = [];
    var hmg = 0., ruf = 0.;
    var i, j, ip1;

    for (i=1;i<=n;i++) {
	    for (j=1;j<=mp1;j++) hm1[j] = hm[j][i];
	    hmg = Skabg(hm1,hm1,2,mp1);
	    deps[i] = Math.abs(h[1][i])/hmg;
	    }

    for (i=1;i<=n;i++) {
	    ip1=i+1;
	    for(j=ip1;j<=n;j++) {
    	    if (deps[i]<deps[j]) {
		        ruf = deps[j];
		        deps[j] = deps[i];
		        deps[i] = ruf;
		        }
    	    }
	    }

    EPS = (deps[IDEF] + deps[IDEF+1]) / 2.;

}

function Hb(hh, bb, nn) {

    var hb = 0.;
    var i;

    for (i=1; i<=nn; i++) hb += hh[i]*bb[i];

    return(hb);

}

function Skabg(a, b, i_nn, nn) {

    var ag = 0., skbg = 0.;
    var i;

    for (i=1; i<=nn; i++) ag = ag + a[i]*g[i];

    if (i_nn==1) {
	    skbg = (a[1]-ag)*b[1];
	    for (i=2;i<=nn;i++) {
    	    skbg = skbg + a[i]*b[i];
    	    }
	    return(skbg);
	    }
    else {
	    skbg = (a[1]-ag)*(a[1]-ag);
	    for (i=2;i<=nn;i++) {
    	    skbg = skbg + a[i]*a[i];
    	    }
	    }

    return(Math.sqrt(skbg));

}

-------------------------------------

2020-06-24T08:19:10.825Z: user: vladas
// use --max-old-space-size=2048 with node binary
// Embarrassingly parallel NAS benchmark

//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;

var OPUS = 4;

// var n = 268435456;  // 2^28  - Class A
var n = 1073741824; // 2^30  - Class B

var x1, x2, sx = 0, sy = 0;
var t1, t2, t3, t4;
var l;
var q = [0,0,0,0,0,0,0,0,0,0];

for (var i = 0; i < n; i++) {
    x1 = 2 * Math.random() - 1;
    x2 = 2 * Math.random() - 1;
    t1 = x1 * x1 + x2 * x2;
    if (t1 <= 1.0) {
	t2 = Math.sqrt(-2.0 * Math.log(t1) / t1);
	t3 = x1 * t2;
	t4 = x2 * t2;
	l = Math.floor(Math.max(Math.abs(t3), Math.abs(t4)));
	q[l] = q[l] + 1;
	sx += t3;
	sy += t4;
	}
    }


finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");


var timchk = 0;
var sxtchk = 0;
var syschk = 0;
var qchk = [];

if (n == 268435456) {
    timchk = 70.0;
    sxchk = -4.295875165629892e3;
    sychk = -1.580732573678431e4;
    qchk = [98257395, 93827014, 17611549, 1110028, 26536, 245, 0, 0, 0, 0];
    }
if (n == 1073741824) {
    timchk = 267.5;
    sxchk = 4.033815542441498e4;
    sychk = -2.660669192809235e4;
    qchk = [393058470, 375280898, 70460742, 4438852, 105691, 948, 5, 0, 0, 0];
    }


console.log("Problem size: n = " + n);
console.log("Total execution time:     " + elapse_time);
console.log("Reference execution time: " + timchk);

console.log("\n");
console.log("Computed sx:     " + sx);
console.log("Reference value: " + sxchk);
console.log("\n");
console.log("Computed sy:     " + sy);
console.log("Reference value: " + sychk);
console.log("\n");
console.log("Q values: ");
console.log(q);



-------------------------------------

2020-06-24T10:17:02.428Z: user: vladas
// use --max-old-space-size=2048 with node binary
// Embarrassingly parallel NAS benchmark

//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;

var OPUS = 8;

// var n = 268435456;  // 2^28  - Class A
var n = 1073741824; // 2^30  - Class B
var q = [0,0,0,0,0,0,0,0,0,0];
var sx = 0; sy = 0;

//#pragma parvar q
//#pragma parvar sx
//#pragma parvar sy
//#pragma parallel
for (k = 1; k <= OPUS; k++) {
    var chunk_len = Math.floor(n / OPUS);
    var slice_start = (opu-1) * chunk_len;
    var slice_end = slice_start + chunk_len - 1;
    if (slice_end >= n) slice_end = n - 1;

    var x1, x2, sxk = 0, syk = 0;
    var t1, t2, t3, t4;
    var l;
    var qk = [0,0,0,0,0,0,0,0,0,0];

    for (var i = slice_start; i < slice_end; i++) {
	x1 = 2 * Math.random() - 1;
	x2 = 2 * Math.random() - 1;
	t1 = x1 * x1 + x2 * x2;
	if (t1 <= 1.0) {
	    t2 = Math.sqrt(-2.0 * Math.log(t1) / t1);
	    t3 = x1 * t2;
	    t4 = x2 * t2;
	    l = Math.floor(Math.max(Math.abs(t3), Math.abs(t4)));
	    qk[l] = qk[l] + 1;
	    sxk += t3;
	    syk += t4;
	    }
	}

    for (i = 0; i < 10; i++) q[i] = q[i] + qk[i];
    sx = sx + sxk;
    sy = sy + syk;
    }

//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");

var timchk = 0;
var sxtchk = 0;
var syschk = 0;
var qchk = [];

if (n == 268435456) {
    timchk = 70.0;
    sxchk = -4.295875165629892e3;
    sychk = -1.580732573678431e4;
    qchk = [98257395, 93827014, 17611549, 1110028, 26536, 245, 0, 0, 0, 0];
    }
if (n == 1073741824) {
    timchk = 267.5;
    sxchk = 4.033815542441498e4;
    sychk = -2.660669192809235e4;
    qchk = [393058470, 375280898, 70460742, 4438852, 105691, 948, 5, 0, 0, 0];
    }


console.log("Problem size: n = " + n);
console.log("Total execution time:     " + elapse_time);
console.log("Reference execution time: " + timchk);

console.log("\n");
console.log("Computed sx:     " + sx);
console.log("Reference value: " + sxchk);
console.log("\n");
console.log("Computed sy:     " + sy);
console.log("Reference value: " + sychk);
console.log("\n");
console.log("Q values: ");
console.log(q);
console.log("Reference Q values: ");
console.log(qchk);



-------------------------------------

2020-06-24T10:18:32.069Z: user: vladas
// use --max-old-space-size=2048 with node binary
// Embarrassingly parallel NAS benchmark

//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;

var OPUS = 8;

// var n = 268435456;  // 2^28  - Class A
var n = 1073741824; // 2^30  - Class B
var q = [0,0,0,0,0,0,0,0,0,0];
var sx = 0; sy = 0;

//#pragma wait
//#pragma parvar q
//#pragma parvar sx
//#pragma parvar sy
//#pragma parallel
for (k = 1; k <= OPUS; k++) {
    var chunk_len = Math.floor(n / OPUS);
    var slice_start = (opu-1) * chunk_len;
    var slice_end = slice_start + chunk_len - 1;
    if (slice_end >= n) slice_end = n - 1;

    var x1, x2, sxk = 0, syk = 0;
    var t1, t2, t3, t4;
    var l;
    var qk = [0,0,0,0,0,0,0,0,0,0];

    for (var i = slice_start; i < slice_end; i++) {
	x1 = 2 * Math.random() - 1;
	x2 = 2 * Math.random() - 1;
	t1 = x1 * x1 + x2 * x2;
	if (t1 <= 1.0) {
	    t2 = Math.sqrt(-2.0 * Math.log(t1) / t1);
	    t3 = x1 * t2;
	    t4 = x2 * t2;
	    l = Math.floor(Math.max(Math.abs(t3), Math.abs(t4)));
	    qk[l] = qk[l] + 1;
	    sxk += t3;
	    syk += t4;
	    }
	}

    for (i = 0; i < 10; i++) q[i] = q[i] + qk[i];
    sx = sx + sxk;
    sy = sy + syk;
    }

//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");

var timchk = 0;
var sxtchk = 0;
var syschk = 0;
var qchk = [];

if (n == 268435456) {
    timchk = 70.0;
    sxchk = -4.295875165629892e3;
    sychk = -1.580732573678431e4;
    qchk = [98257395, 93827014, 17611549, 1110028, 26536, 245, 0, 0, 0, 0];
    }
if (n == 1073741824) {
    timchk = 267.5;
    sxchk = 4.033815542441498e4;
    sychk = -2.660669192809235e4;
    qchk = [393058470, 375280898, 70460742, 4438852, 105691, 948, 5, 0, 0, 0];
    }


console.log("Problem size: n = " + n);
console.log("Total execution time:     " + elapse_time);
console.log("Reference execution time: " + timchk);

console.log("\n");
console.log("Computed sx:     " + sx);
console.log("Reference value: " + sxchk);
console.log("\n");
console.log("Computed sy:     " + sy);
console.log("Reference value: " + sychk);
console.log("\n");
console.log("Q values: ");
console.log(q);
console.log("Reference Q values: ");
console.log(qchk);



-------------------------------------

2020-06-24T10:21:39.182Z: user: vladas
// use --max-old-space-size=2048 with node binary
// Embarrassingly parallel NAS benchmark

//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;

var OPUS = 8;

// var n = 268435456;  // 2^28  - Class A
var n = 1073741824; // 2^30  - Class B
var q = [0,0,0,0,0,0,0,0,0,0];
var sx = 0; sy = 0;

//#pragma wait
//#pragma parvar q
//#pragma parvar sx
//#pragma parvar sy
//#pragma parallel
for (k = 1; k <= OPUS; k++) {
    var chunk_len = Math.floor(n / OPUS);
    var slice_start = (opu-1) * chunk_len;
    var slice_end = slice_start + chunk_len - 1;
    if (slice_end >= n) slice_end = n - 1;

    var x1, x2, sxk = 0, syk = 0;
    var t1, t2, t3, t4;
    var l;
    var qk = [0,0,0,0,0,0,0,0,0,0];

    for (var i = slice_start; i < slice_end; i++) {
	x1 = 2 * Math.random() - 1;
	x2 = 2 * Math.random() - 1;
	t1 = x1 * x1 + x2 * x2;
	if (t1 <= 1.0) {
	    t2 = Math.sqrt(-2.0 * Math.log(t1) / t1);
	    t3 = x1 * t2;
	    t4 = x2 * t2;
	    l = Math.floor(Math.max(Math.abs(t3), Math.abs(t4)));
	    qk[l] = qk[l] + 1;
	    sxk += t3;
	    syk += t4;
	    }
	}

    for (i = 0; i < 10; i++) q[i] = q[i] + qk[i];
    sx = sx + sxk;
    sy = sy + syk;
    }

//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");

var timchk = 0;
var sxtchk = 0;
var syschk = 0;
var qchk = [];

if (n == 268435456) {
    timchk = 70.0;
    sxchk = -4.295875165629892e3;
    sychk = -1.580732573678431e4;
    qchk = [98257395, 93827014, 17611549, 1110028, 26536, 245, 0, 0, 0, 0];
    }
if (n == 1073741824) {
    timchk = 267.5;
    sxchk = 4.033815542441498e4;
    sychk = -2.660669192809235e4;
    qchk = [393058470, 375280898, 70460742, 4438852, 105691, 948, 5, 0, 0, 0];
    }


console.log("Problem size: n = " + n);
console.log("Total execution time:     " + elapse_time);
console.log("Reference execution time: " + timchk);

console.log("\n");
console.log("Computed sx:     " + sx);
console.log("Reference value: " + sxchk);
console.log("\n");
console.log("Computed sy:     " + sy);
console.log("Reference value: " + sychk);
console.log("\n");
console.log("Q values: ");
console.log(q);
console.log("Reference Q values: ");
console.log(qchk);



-------------------------------------

2020-06-24T10:23:35.033Z: user: vladas
// use --max-old-space-size=2048 with node binary
// Embarrassingly parallel NAS benchmark

//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;

var OPUS = 8;

// var n = 268435456;  // 2^28  - Class A
var n = 1073741824; // 2^30  - Class B
var q = [0,0,0,0,0,0,0,0,0,0];
var sx = 0; sy = 0;

//#pragma wait
//#pragma parvar q
//#pragma parvar sx
//#pragma parvar sy
//#pragma parallel
for (k = 1; k <= OPUS; k++) {
    var chunk_len = Math.floor(n / OPUS);
    var slice_start = (k-1) * chunk_len;
    var slice_end = slice_start + chunk_len - 1;
    if (slice_end >= n) slice_end = n - 1;

    var x1, x2, sxk = 0, syk = 0;
    var t1, t2, t3, t4;
    var l;
    var qk = [0,0,0,0,0,0,0,0,0,0];

    for (var i = slice_start; i < slice_end; i++) {
	x1 = 2 * Math.random() - 1;
	x2 = 2 * Math.random() - 1;
	t1 = x1 * x1 + x2 * x2;
	if (t1 <= 1.0) {
	    t2 = Math.sqrt(-2.0 * Math.log(t1) / t1);
	    t3 = x1 * t2;
	    t4 = x2 * t2;
	    l = Math.floor(Math.max(Math.abs(t3), Math.abs(t4)));
	    qk[l] = qk[l] + 1;
	    sxk += t3;
	    syk += t4;
	    }
	}

    for (i = 0; i < 10; i++) q[i] = q[i] + qk[i];
    sx = sx + sxk;
    sy = sy + syk;
    }

//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");

var timchk = 0;
var sxtchk = 0;
var syschk = 0;
var qchk = [];

if (n == 268435456) {
    timchk = 70.0;
    sxchk = -4.295875165629892e3;
    sychk = -1.580732573678431e4;
    qchk = [98257395, 93827014, 17611549, 1110028, 26536, 245, 0, 0, 0, 0];
    }
if (n == 1073741824) {
    timchk = 267.5;
    sxchk = 4.033815542441498e4;
    sychk = -2.660669192809235e4;
    qchk = [393058470, 375280898, 70460742, 4438852, 105691, 948, 5, 0, 0, 0];
    }


console.log("Problem size: n = " + n);
console.log("Total execution time:     " + elapse_time);
console.log("Reference execution time: " + timchk);

console.log("\n");
console.log("Computed sx:     " + sx);
console.log("Reference value: " + sxchk);
console.log("\n");
console.log("Computed sy:     " + sy);
console.log("Reference value: " + sychk);
console.log("\n");
console.log("Q values: ");
console.log(q);
console.log("Reference Q values: ");
console.log(qchk);



-------------------------------------

2020-06-24T10:33:24.490Z: user: vladas
// use --max-old-space-size=2048 with node binary
// Embarrassingly parallel NAS benchmark

//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;

var OPUS = 8;

// var n = 268435456;  // 2^28  - Class A
var n = 1073741824; // 2^30  - Class B
var q = [0,0,0,0,0,0,0,0,0,0];
var sx = 0; sy = 0;

//#pragma wait
//#pragma parvar q
//#pragma parvar sx
//#pragma parvar sy
//#pragma parallel
for (k = 1; k <= OPUS; k++) {
    var chunk_len = Math.floor(n / OPUS);
    var slice_start = (k-1) * chunk_len;
    var slice_end = slice_start + chunk_len - 1;
    if (slice_end >= n) slice_end = n - 1;

    var x1, x2, sxk = 0, syk = 0;
    var t1, t2, t3, t4;
    var l;
    var qk = [0,0,0,0,0,0,0,0,0,0];

    for (var i = slice_start; i < slice_end; i++) {
	x1 = 2 * Math.random() - 1;
	x2 = 2 * Math.random() - 1;
	t1 = x1 * x1 + x2 * x2;
	if (t1 <= 1.0) {
	    t2 = Math.sqrt(-2.0 * Math.log(t1) / t1);
	    t3 = x1 * t2;
	    t4 = x2 * t2;
	    l = Math.floor(Math.max(Math.abs(t3), Math.abs(t4)));
	    qk[l] = qk[l] + 1;
	    sxk += t3;
	    syk += t4;
	    }
	}

    for (i = 0; i < 10; i++) q[i] = q[i] + qk[i];
    sx = sx + sxk;
    sy = sy + syk;
    }

//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");

var timchk = 0;
var sxtchk = 0;
var syschk = 0;
var qchk = [];

if (n == 268435456) {
    timchk = 70.0;
    sxchk = -4.295875165629892e3;
    sychk = -1.580732573678431e4;
    qchk = [98257395, 93827014, 17611549, 1110028, 26536, 245, 0, 0, 0, 0];
    }
if (n == 1073741824) {
    timchk = 267.5;
    sxchk = 4.033815542441498e4;
    sychk = -2.660669192809235e4;
    qchk = [393058470, 375280898, 70460742, 4438852, 105691, 948, 5, 0, 0, 0];
    }


console.log("Problem size: n = " + n);
console.log("Total execution time:     " + elapse_time);
console.log("Reference execution time: " + timchk);

console.log("\n");
console.log("Computed sx:     " + sx);
console.log("Reference value: " + sxchk);
console.log("\n");
console.log("Computed sy:     " + sy);
console.log("Reference value: " + sychk);
console.log("\n");
console.log("Q values: ");
console.log(q);
console.log("Reference Q values: ");
console.log(qchk);



-------------------------------------

2020-06-24T10:40:06.296Z: user: vladas
// use --max-old-space-size=2048 with node binary
// Embarrassingly parallel NAS benchmark

//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;

var OPUS = 8;

// var n = 268435456;  // 2^28  - Class A
var n = 1073741824; // 2^30  - Class B
var q = [0,0,0,0,0,0,0,0,0,0];
var sx = 0; sy = 0;

//#pragma wait
//#pragma parvar q
//#pragma parvar sx
//#pragma parvar sy
//#pragma parallel
for (k = 1; k <= OPUS; k++) {
    var chunk_len = Math.floor(n / OPUS);
    var slice_start = (k-1) * chunk_len;
    var slice_end = slice_start + chunk_len - 1;
    if (slice_end >= n) slice_end = n - 1;

    var x1, x2, sxk = 0, syk = 0;
    var t1, t2, t3, t4;
    var l;
    var qk = [0,0,0,0,0,0,0,0,0,0];

    for (var i = slice_start; i < slice_end; i++) {
	x1 = 2 * Math.random() - 1;
	x2 = 2 * Math.random() - 1;
	t1 = x1 * x1 + x2 * x2;
	if (t1 <= 1.0) {
	    t2 = Math.sqrt(-2.0 * Math.log(t1) / t1);
	    t3 = x1 * t2;
	    t4 = x2 * t2;
	    l = Math.floor(Math.max(Math.abs(t3), Math.abs(t4)));
	    qk[l] = qk[l] + 1;
	    sxk += t3;
	    syk += t4;
	    }
	}

    for (i = 0; i < 10; i++) q[i] = q[i] + qk[i];
    sx = sx + sxk;
    sy = sy + syk;
    }

//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");

var timchk = 0;
var sxtchk = 0;
var syschk = 0;
var qchk = [];

if (n == 268435456) {
    timchk = 70.0;
    sxchk = -4.295875165629892e3;
    sychk = -1.580732573678431e4;
    qchk = [98257395, 93827014, 17611549, 1110028, 26536, 245, 0, 0, 0, 0];
    }
if (n == 1073741824) {
    timchk = 267.5;
    sxchk = 4.033815542441498e4;
    sychk = -2.660669192809235e4;
    qchk = [393058470, 375280898, 70460742, 4438852, 105691, 948, 5, 0, 0, 0];
    }


console.log("Problem size: n = " + n);
console.log("Total execution time:     " + elapse_time);
console.log("Reference execution time: " + timchk);

console.log("\n");
console.log("Computed sx:     " + sx);
console.log("Reference value: " + sxchk);
console.log("\n");
console.log("Computed sy:     " + sy);
console.log("Reference value: " + sychk);
console.log("\n");
console.log("Q values: ");
console.log(q);
console.log("Reference Q values: ");
console.log(qchk);



-------------------------------------

2020-06-24T10:43:58.701Z: user: vladas
// use --max-old-space-size=2048 with node binary
// Embarrassingly parallel NAS benchmark

//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;

var OPUS = 8;

// var n = 268435456;  // 2^28  - Class A
var n = 1073741824; // 2^30  - Class B
var q = [0,0,0,0,0,0,0,0,0,0];
var sx = 0; sy = 0;

//#pragma wait
//#pragma parvar q
//#pragma parvar sx
//#pragma parvar sy
//#pragma parallel
for (k = 1; k <= OPUS; k++) {
    var chunk_len = Math.floor(n / OPUS);
    var slice_start = (k-1) * chunk_len;
    var slice_end = slice_start + chunk_len - 1;
    if (slice_end >= n) slice_end = n - 1;

    var x1, x2, sxk = 0, syk = 0;
    var t1, t2, t3, t4;
    var l;
    var qk = [0,0,0,0,0,0,0,0,0,0];

    for (var i = slice_start; i < slice_end; i++) {
	x1 = 2 * Math.random() - 1;
	x2 = 2 * Math.random() - 1;
	t1 = x1 * x1 + x2 * x2;
	if (t1 <= 1.0) {
	    t2 = Math.sqrt(-2.0 * Math.log(t1) / t1);
	    t3 = x1 * t2;
	    t4 = x2 * t2;
	    l = Math.floor(Math.max(Math.abs(t3), Math.abs(t4)));
	    qk[l] = qk[l] + 1;
	    sxk += t3;
	    syk += t4;
	    }
	}

    for (i = 0; i < 10; i++) q[i] = q[i] + qk[i];
    sx = sx + sxk;
    sy = sy + syk;
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");

var timchk = 0;
var sxtchk = 0;
var syschk = 0;
var qchk = [];

if (n == 268435456) {
    timchk = 70.0;
    sxchk = -4.295875165629892e3;
    sychk = -1.580732573678431e4;
    qchk = [98257395, 93827014, 17611549, 1110028, 26536, 245, 0, 0, 0, 0];
    }
if (n == 1073741824) {
    timchk = 267.5;
    sxchk = 4.033815542441498e4;
    sychk = -2.660669192809235e4;
    qchk = [393058470, 375280898, 70460742, 4438852, 105691, 948, 5, 0, 0, 0];
    }


console.log("Problem size: n = " + n);
console.log("Total execution time:     " + elapse_time);
console.log("Reference execution time: " + timchk);

console.log("\n");
console.log("Computed sx:     " + sx);
console.log("Reference value: " + sxchk);
console.log("\n");
console.log("Computed sy:     " + sy);
console.log("Reference value: " + sychk);
console.log("\n");
console.log("Q values: ");
console.log(q);
console.log("Reference Q values: ");
console.log(qchk);



-------------------------------------

2020-06-24T10:45:36.072Z: user: vladas
// use --max-old-space-size=2048 with node binary
// Embarrassingly parallel NAS benchmark

//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;

var OPUS = 8;

// var n = 268435456;  // 2^28  - Class A
var n = 1073741824; // 2^30  - Class B
var q = [0,0,0,0,0,0,0,0,0,0];
var sx = 0; sy = 0;

//#pragma wait
//#pragma parvar q
//#pragma parvar sx
//#pragma parvar sy
//#pragma parallel
for (k = 1; k <= OPUS; k++) {
    var chunk_len = Math.floor(n / OPUS);
    var slice_start = (k-1) * chunk_len;
    var slice_end = slice_start + chunk_len - 1;
    if (slice_end >= n) slice_end = n - 1;

    var x1, x2, sxk = 0, syk = 0;
    var t1, t2, t3, t4;
    var l;
    var qk = [0,0,0,0,0,0,0,0,0,0];

    for (var i = slice_start; i < slice_end; i++) {
	x1 = 2 * Math.random() - 1;
	x2 = 2 * Math.random() - 1;
	t1 = x1 * x1 + x2 * x2;
	if (t1 <= 1.0) {
	    t2 = Math.sqrt(-2.0 * Math.log(t1) / t1);
	    t3 = x1 * t2;
	    t4 = x2 * t2;
	    l = Math.floor(Math.max(Math.abs(t3), Math.abs(t4)));
	    qk[l] = qk[l] + 1;
	    sxk += t3;
	    syk += t4;
	    }
	}

    for (i = 0; i < 10; i++) q[i] = q[i] + qk[i];
    sx = sx + sxk;
    sy = sy + syk;
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");

var timchk = 0;
var sxtchk = 0;
var syschk = 0;
var qchk = [];

if (n == 268435456) {
    timchk = 70.0;
    sxchk = -4.295875165629892e3;
    sychk = -1.580732573678431e4;
    qchk = [98257395, 93827014, 17611549, 1110028, 26536, 245, 0, 0, 0, 0];
    }
if (n == 1073741824) {
    timchk = 267.5;
    sxchk = 4.033815542441498e4;
    sychk = -2.660669192809235e4;
    qchk = [393058470, 375280898, 70460742, 4438852, 105691, 948, 5, 0, 0, 0];
    }


console.log("Problem size: n = " + n);
console.log("Total execution time:     " + elapse_time);
console.log("Reference execution time: " + timchk);

console.log("\n");
console.log("Computed sx:     " + sx);
console.log("Reference value: " + sxchk);
console.log("\n");
console.log("Computed sy:     " + sy);
console.log("Reference value: " + sychk);
console.log("\n");
console.log("Q values: ");
console.log(q);
console.log("Reference Q values: ");
console.log(qchk);



-------------------------------------

2020-06-24T10:48:07.349Z: user: vladas
// use --max-old-space-size=2048 with node binary
// Embarrassingly parallel NAS benchmark

//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;

var OPUS = 8;

// var n = 268435456;  // 2^28  - Class A
var n = 1073741824; // 2^30  - Class B
var q = [0,0,0,0,0,0,0,0,0,0];
var sx = 0; sy = 0;

//#pragma wait
//#pragma parvar q
//#pragma parvar sx
//#pragma parvar sy
//#pragma parallel
for (k = 1; k <= OPUS; k++) {
    var chunk_len = Math.floor(n / OPUS);
    var slice_start = (k-1) * chunk_len;
    var slice_end = slice_start + chunk_len - 1;
    if (slice_end >= n) slice_end = n - 1;

    var x1, x2, sxk = 0, syk = 0;
    var t1, t2, t3, t4;
    var l;
    var qk = [0,0,0,0,0,0,0,0,0,0];

    for (var i = slice_start; i < slice_end; i++) {
	x1 = 2 * Math.random() - 1;
	x2 = 2 * Math.random() - 1;
	t1 = x1 * x1 + x2 * x2;
	if (t1 <= 1.0) {
	    t2 = Math.sqrt(-2.0 * Math.log(t1) / t1);
	    t3 = x1 * t2;
	    t4 = x2 * t2;
	    l = Math.floor(Math.max(Math.abs(t3), Math.abs(t4)));
	    qk[l] = qk[l] + 1;
	    sxk += t3;
	    syk += t4;
	    }
	}

    for (i = 0; i < 10; i++) q[i] = q[i] + qk[i];
    sx = sx + sxk;
    sy = sy + syk;
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");

var timchk = 0;
var sxtchk = 0;
var syschk = 0;
var qchk = [];

if (n == 268435456) {
    timchk = 70.0;
    sxchk = -4.295875165629892e3;
    sychk = -1.580732573678431e4;
    qchk = [98257395, 93827014, 17611549, 1110028, 26536, 245, 0, 0, 0, 0];
    }
if (n == 1073741824) {
    timchk = 267.5;
    sxchk = 4.033815542441498e4;
    sychk = -2.660669192809235e4;
    qchk = [393058470, 375280898, 70460742, 4438852, 105691, 948, 5, 0, 0, 0];
    }


console.log("Problem size: n = " + n);
console.log("Total execution time:     " + elapse_time);
console.log("Reference execution time: " + timchk);

console.log("\n");
console.log("Computed sx:     " + sx);
console.log("Reference value: " + sxchk);
console.log("\n");
console.log("Computed sy:     " + sy);
console.log("Reference value: " + sychk);
console.log("\n");
console.log("Q values: ");
console.log(q);
console.log("Reference Q values: ");
console.log(qchk);



-------------------------------------

2020-06-24T10:50:10.863Z: user: vladas
// use --max-old-space-size=2048 with node binary
// Embarrassingly parallel NAS benchmark

//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;

var OPUS = 8;

// var n = 268435456;  // 2^28  - Class A
var n = 1073741824; // 2^30  - Class B
var q = [0,0,0,0,0,0,0,0,0,0];
var sx = 0; sy = 0;

//#pragma wait
//#pragma parvar q
//#pragma parvar sx
//#pragma parvar sy
//#pragma parallel
for (k = 1; k <= OPUS; k++) {
    var chunk_len = Math.floor(n / OPUS);
    var slice_start = (k-1) * chunk_len;
    var slice_end = slice_start + chunk_len - 1;
    if (slice_end >= n) slice_end = n - 1;

    var x1, x2, sxk = 0, syk = 0;
    var t1, t2, t3, t4;
    var l;
    var qk = [0,0,0,0,0,0,0,0,0,0];

    for (var i = slice_start; i < slice_end; i++) {
	x1 = 2 * Math.random() - 1;
	x2 = 2 * Math.random() - 1;
	t1 = x1 * x1 + x2 * x2;
	if (t1 <= 1.0) {
	    t2 = Math.sqrt(-2.0 * Math.log(t1) / t1);
	    t3 = x1 * t2;
	    t4 = x2 * t2;
	    l = Math.floor(Math.max(Math.abs(t3), Math.abs(t4)));
	    qk[l] = qk[l] + 1;
	    sxk += t3;
	    syk += t4;
	    }
	}

    for (i = 0; i < 10; i++) q[i] = q[i] + qk[i];
    sx = sx + sxk;
    sy = sy + syk;
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");

var timchk = 0;
var sxtchk = 0;
var syschk = 0;
var qchk = [];

if (n == 268435456) {
    timchk = 70.0;
    sxchk = -4.295875165629892e3;
    sychk = -1.580732573678431e4;
    qchk = [98257395, 93827014, 17611549, 1110028, 26536, 245, 0, 0, 0, 0];
    }
if (n == 1073741824) {
    timchk = 267.5;
    sxchk = 4.033815542441498e4;
    sychk = -2.660669192809235e4;
    qchk = [393058470, 375280898, 70460742, 4438852, 105691, 948, 5, 0, 0, 0];
    }


console.log("Problem size: n = " + n);
console.log("Total execution time:     " + elapse_time);
console.log("Reference execution time: " + timchk);

console.log("\n");
console.log("Computed sx:     " + sx);
console.log("Reference value: " + sxchk);
console.log("\n");
console.log("Computed sy:     " + sy);
console.log("Reference value: " + sychk);
console.log("\n");
console.log("Q values: ");
console.log(q);
console.log("Reference Q values: ");
console.log(qchk);



-------------------------------------

2020-06-24T11:07:26.913Z: user: vladas
//#pragma parvar Tree
//#pragma parvar particles
//#pragma parvar points
//#pragma parvar blk_acc
//#pragma parvar acc
//#pragma noautoparvar
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;

/*
Vect.prototype.mulvs = function(s) {
    return new Vect(
      this.x * s,
      this.y * s,
      this.z * s
    );
};
*/

Vect.prototype.mulvs = function(s) {
      this.x *= s,
      this.y *= s,
      this.z *= s
    return this;
};

/*
Vect.prototype.addv = function(other) {
    return new Vect(
      this.x + other.x,
      this.y + other.y,
      this.z + other.z
    );
};
*/

Vect.prototype.addv = function(other) {
      this.x += other.x,
      this.y += other.y,
      this.z += other.z
    return this;
};

/*
Vect.prototype.subv = function(other) {
    return new Vect(
      this.x - other.x,
      this.y - other.y,
      this.z - other.z
    );
};
*/

Vect.prototype.subv = function(other) {
      this.x -= other.x,
      this.y -= other.y,
      this.z -= other.z
    return this;
};

Vect.prototype.dotvp = function(other) {
    return (
      this.x * other.x +
      this.y * other.y +
      this.z * other.z
    );
};

Vect.prototype.outvp = function(other) {
    return ([
      new Vect(this.x * other.x, this.x * other.y, this.x * other.z),
      new Vect(this.y * other.x, this.y * other.y, this.y * other.z),
      new Vect(this.z * other.x, this.z * other.y, this.z * other.z)
      ]
    );
};

Vect.prototype.mulms = function(vectarr, s) {
    return ([
      vectarr[0].mulvs(s),
      vectarr[1].mulvs(s),
      vectarr[2].mulvs(s)
      ]
    );
};

Vect.prototype.mulmv = function(vectarr, other) {
    return new Vect(
      vectarr[0].dotvp(other),
      vectarr[1].dotvp(other),
      vectarr[2].dotvp(other)
      );
};

Vect.prototype.subm = function(vectarr, otherarr) {
    return ([
      vectarr[0].subv(otherarr[0]),
      vectarr[1].subv(otherarr[1]),
      vectarr[2].subv(otherarr[2])
      ]
    );
};

Vect.prototype.addm = function(vectarr, otherarr) {
    return ([
      vectarr[0].addv(otherarr[0]),
      vectarr[1].addv(otherarr[1]),
      vectarr[2].addv(otherarr[2])
      ]
    );
};

Vect.prototype.normalized = function() {
    var mag = Math.sqrt(this.dotvp(this));
    return new Vect(
      this.x / mag,
      this.y / mag,
      this.z / mag
    );
};


Box.prototype.size = function() {
    return this.sz;
};

Cmass.prototype.mass = function() {
    return this.m;
};

Cmass.prototype.cpos = function() {
    return this.coords;
};

var N = 524288;
var BLOCKS = 8;
var THETA = 2.;
var particles = [];
var points = [];
var mass = 1.0;
var Tree = [];
var acc = [];



for (var i = 0; i < N; i++) {
    particles[i] =  [Math.random()*10-5.0,Math.random()*10-5.0,
		Math.random()*10-5.0,Math.random()*10-5.0,
		Math.random()*10-5.0,Math.random()*10-5.0,mass];
    }

/*
particles = [
    [1.8,-2.3,-2.7,-3.6,0.3,-1.2,1.0],
    [2.9,-0.6,0.9,4.0,-4.2,-1.7,1.0],
    [0.6,-2.2,-2.2,-4.5,2.5,3.8,1.0],
    [0.9,-2.9,-4.5,-3.3,0.2,2.6,1.0],
    [3.2,-4.7,4.9,-1.2,-4.7,1.6,1.0],
    [-1.1,-0.1,4.4,-1.7,-1.6,1.6,1.0],
    [1.7,-2.2,0.9,2.8,-4.4,-0.4,1.0],
    [0.4,1.1,0.4,2.0,-4.2,2.9,1.0],
    [0.6,-1.9,-4.5,-3.7,3.8,2.0,1.0],
    [-3.9,3.0,0.4,-4.6,3.6,-1.3,1.0],
    [4.5,-2.4,3.0,4.2,3.6,4.1,1.0],
    [-2.4,-2.8,2.8,-3.7,-0.6,-3.2,1.0],
    [2.3,4.9,0.7,-0.2,0.7,-1.9,1.0],
    [-4.7,-0.6,2.0,4.4,-0.2,2.2,1.0],
    [4.0,-4.7,1.2,3.0,-2.2,3.8,1.0],
    [3.3,1.8,3.4,2.0,2.1,3.5,1.0]
    ];
*/

for (i = 0; i < N; i++) {
    points[i] = [new Vect(particles[i][0], particles[i][1], particles[i][2]), i];
    acc[i] = new Vect(0.,0.,0.);
    }

Tree = make_main_tree(particles);

// console.log(Tree);
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec");

var interactions = 0; /* possible parvar */

var block_size = Math.floor(N / BLOCKS);

//// following are commented out comments
////#pragma wait
////#pragma parallel
for (block = 0; block < BLOCKS; block++) {

    var block_start = block * block_size;
    var block_end = block_start + block_size - 1;
    if (block_end >= N) block_end = N - 1;

    var init_level = [];
    for (var i = 0; i < block_end - block_start + 1; i++) {
	init_level[i] = [0, block_start + i, 0];
	}

    var blk_acc = [];
    for (i = block_start; i <= block_end; i++) {
	blk_acc[i] = new Vect(0.,0.,0.);
	}
    var inter = 0;
    var r = 0;
    inter = get_force(init_level, inter);

    interactions += inter;
    for (i = block_start; i <= block_end; i++) {
//	acc[i] = acc[i].addv(blk_acc[i]);
	acc[i].addv(blk_acc[i]);
	}

    }

//console.log(acc);

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec");

// Constructors

function Vect(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
}

function Box(coords, sz) {
    this.coords = coords;
    this.sz = sz;
}

function Cmass(m, coords) {
    this.m = m;
    this.coords = coords;
}

function make_main_tree(particles) {

    var x0 = 1000000.; y0 = x0; z0 = x0;
    var dx = -1000000.; dy = dx; dz = dx;

    var pa = [];
    for (var pi = 0; pi < particles.length; pi++) {
	pa = particles[pi];
	if (pa[0] < x0) x0 = pa[0];
	if (pa[1] < y0) y0 = pa[1];
	if (pa[2] < z0) z0 = pa[2];
	if (pa[0] > dx) dx = pa[0];
	if (pa[1] > dy) dy = pa[1];
	if (pa[2] > dz) dz = pa[2];
	}
    dx -= x0;
    dy -= y0;
    dz -= z0;
    
    return make_tree(particles, [[x0, y0, z0], [dx, dy, dz]]);

}

function make_tree(part, cell_box) {

    var desc = [0];
    
    var x0 = cell_box[0][0];
    var y0 = cell_box[0][1];
    var z0 = cell_box[0][2];
    var dx = cell_box[1][0];
    var dy = cell_box[1][1];
    var dz = cell_box[1][2];
    var hdx = dx / 2.;
    var hdy = dy / 2.;
    var hdz = dz / 2.;

    var zpart = [[],[]];
    var ypart = [[],[],[],[]];
    var xpart = [[],[],[],[],[],[],[],[]];

    if (part.length == 1) {
	return [[1, 
		   new Cmass(part[0][6], new Vect(part[0][0], part[0][1], part[0][2])),
		   [new Vect(0.,0.,0.), new Vect(0.,0.,0.), new Vect(0.,0.,0.)],
		   new Box(new Vect(cell_box[0][0],cell_box[0][1],cell_box[0][2]), 
			   new Vect(cell_box[1][0],cell_box[1][1],cell_box[1][2])),
		   [-1]
		   ]];
	}
    

// Split particles into 3D octants

    // z axis
    var pa = [];
    for (var hi = 0; hi < part.length; hi++) {
	pa = part[hi];
	if (pa[2] >= z0+hdz)
	    zpart[1].push(pa);
	else
	    zpart[0].push(pa);
	}

    // y axis
    for (var hj = 0; hj < 2; hj++) {
	for (var hz = 0; hz < zpart[hj].length; hz++) {
	    pa = zpart[hj][hz];
	    if (pa[0] >= x0+hdx)
		ypart[hj*2+1].push(pa);
	    else
		ypart[hj*2].push(pa);
	    }
	}
	
    // x axis
    for (var hj = 0; hj < 4; hj++) {
	for (var hz = 0; hz < ypart[hj].length; hz++) {
	    pa = ypart[hj][hz];
	    if (pa[1] >= y0+hdy)
		xpart[hj*2+1].push(pa);
	    else
		xpart[hj*2].push(pa);
	    }
	}

    var xhalf = x0 + hdx;
    var yhalf = y0 + hdy;
    var zhalf = z0 + hdz;
    var corners = [[x0, y0, z0], [x0, yhalf, z0], [xhalf, y0, z0],
		   [xhalf, yhalf, z0], [x0, y0, zhalf], [x0, yhalf, zhalf],
		   [xhalf, y0, zhalf], [xhalf, yhalf, zhalf]];

    var l;
    var children = [];
    for (var h = 0; h < xpart.length; h++) {
	if (xpart[h].length > 0) {
	    l = desc.length;
	    desc = desc.concat(make_tree(xpart[h], [corners[h], [hdx, hdy, hdz]]));
	    children.push(desc[l]);
	    }
	}

    var child_pos = [];
    var desc_nos = [];
    var desc_no = 1;
    var total_mass = 0.;
    var ch = [];
    var mx = 0., my = 0., mz = 0.;
    for (h = 0; h < children.length; h++) {
	ch = children[h];
	desc_nos[h] = ch[0];
	child_pos[h] = desc_no;
	desc_no += desc_nos[h];
	total_mass += ch[1].mass();
	mx += ch[1].mass() * ch[1].cpos().x;
	my += ch[1].mass() * ch[1].cpos().y;
	mz += ch[1].mass() * ch[1].cpos().z;
	}
	
    mx = mx / total_mass;
    my = my / total_mass;
    mz = mz / total_mass;
    var mv = new Vect(mx, my, mz);
    
//    console.log(child_pos);
//    console.log(desc_no);
//    console.log(mv);

    // Deep matrix algebra magic, called get_quad_moment
    var tmpm = [];
    var vct = new Vect(0,0,0);
    for (var q = 0; q < children.length; q++) {
	ch = children[q];
	var cmpos = ch[1].cpos();
	var cmass = ch[1].mass();
	var dr = mv.subv(cmpos);
	var drdr = dr.outvp(dr);
	var drsq = dr.dotvp(dr);
	var idrsq = [new Vect(1.,0.,0.), new Vect(0.,1.,0.), new Vect(0.,0.,1.)];
	idrsq = vct.mulms(idrsq, drsq);
	tmpm[q] = vct.mulms(drdr, 3.);
	tmpm[q] = vct.subm(tmpm[q], idrsq);
	tmpm[q] = vct.mulms(tmpm[q], cmass);
	if (ch[0] != 1) tmpm[q] = vct.addm(tmpm[q], ch[2]);
	}

    var rs = [[],[],[]];
    for (q = 0; q < children.length; q++) {
	rs[0].push(tmpm[q][0]);
	rs[1].push(tmpm[q][1]);
	rs[2].push(tmpm[q][2]);
	}

    var qa = [[0.,0.,0.],[0.,0.,0.],[0.,0.,0.]];
    for (j = 0; j <= 2; j++) {
	for (q = 0; q < children.length; q++) {
	    qa[j][0] += rs[j][q].x;
	    qa[j][1] += rs[j][q].y;
	    qa[j][2] += rs[j][q].z;
	    }
	}

    var quad = [new Vect(qa[0][0], qa[0][1], qa[0][2]),
		new Vect(qa[1][0], qa[1][1], qa[1][2]),
		new Vect(qa[2][0], qa[2][1], qa[2][2])
		];
    // End of get_quad_moment

    var new_desc = [desc_no, new Cmass(total_mass, mv),
		    quad,
		    new Box(new Vect(x0,y0,z0), new Vect(dx,dy,dz)),
		    child_pos];

    desc[0] = new_desc;

    return desc;

}

function get_force(curr_level, inter) {

    r++;
    var dr, dsq, cell_box, cell_size;
    var flags = [];
    var next_level = [], next_inds = [], this_level = [];

    for (var i = 0; i < curr_level.length; i++) {
	dr = Tree[curr_level[i][0]][1].cpos().subv(points[curr_level[i][1]][0]);
	dsq = dr.dotvp(dr);
	cell_box = Tree[curr_level[i][0]][3].size();
	cell_size = Math.max(cell_box.x, Math.max(cell_box.y, cell_box.z));
	if (cell_size >= THETA*Math.sqrt(dsq)) { // well_separated?
	    next_inds.push(curr_level[i]);
	    }
	else {
	    this_level.push(curr_level[i]);
	    }
	}

    // calculate forces

    inter += this_level.length;
    
    var forces = [];
    for (i = 0; i < this_level.length; i++) {
	var point = points[this_level[i][1]][1];
	// warning - sparce array!
	if (forces[point] == undefined) forces[point] = new Vect(0.,0.,0.);
	var t = Tree[this_level[i][0]];
//	forces[point] = 
	forces[point].addv(force(t[0], t[1], t[2], points[this_level[i][1]][0]));
	}

    for (i in forces) {
	if (blk_acc[i] == undefined) console.log(i);
//	blk_acc[i] = blk_acc[i].subv(forces[i]);
	blk_acc[i].subv(forces[i]);
	}

    if (next_inds.length == 0) return inter;

//console.log("next_inds");
//console.log(next_inds);

    var indices = [];
    for (i = 0; i < next_inds.length; i++) {
	var kids = Tree[next_inds[i][0]][4];
	var cell_ind = next_inds[i][2];
	indices[i] = [];
	for (j = 0; j < kids.length; j++) {
	    indices[i][j] = kids[j] + cell_ind;
	    }
	}

//console.log("indices");
//console.log(indices);

    var lens = [];
    var vals = [];
    for (i = 0; i < indices.length; i++) {
	lens[i] = indices[i].length;
	for (j = 0; j < indices[i].length; j++) {
	    vals.push(indices[i][j]);
	    }
	}
    
    nested_kids = [];
    i = 0;
    // vals patition
    for (j = 0; j < lens.length; j++) {
	nested_kids[j] = [];
	for (k = 0; k < lens[j]; k++) {
	    nested_kids[j][k] = vals[i++];
	    }
	}

//console.log("nested_kids");
//console.log(nested_kids);

    for (i = 0; i < nested_kids.length; i++) {
	for (j = 0; j < nested_kids[i].length; j++) {
	    next_level.push([nested_kids[i][j], next_inds[i][1], indices[i][j]]);
	    }
	}

//console.log("next_level");
//console.log(next_level);

if (r == 1) return inter;

    return get_force(next_level, inter);

}

function force(d, cm, quad, ppos) {

    var acc;
    var M = cm.mass();
    var cm_pos = cm.cpos();
    var dr = cm_pos.subv(ppos);
    if (dr.x == 0. && dr.y == 0. && dr.z == 0.) return dr;

    var drsq = dr.dotvp(dr);
    var drabs = Math.sqrt(drsq);
    var mrcubed = M / (drsq * drabs);
    acc = new Vect(dr.x * mrcubed, dr.y * mrcubed, dr.z * mrcubed);
    if (d == 1) return acc;

    var dr5inv = 1. / (drsq * drsq * drabs);
    var vct = new Vect(0,0,0);
    var quad_dr = vct.mulmv(quad,dr);
    var dr_quad_dr = dr.dotvp(quad_dr);
    var phi_quad = -2.5 * dr_quad_dr * dr5inv / drsq;
    var ai = dr.mulvs(phi_quad);
//    acc = 
    acc.subv(ai);
    quad_dr = quad_dr.mulvs(dr5inv);
//    acc = 
    acc.subv(quad_dr);

    return acc;

}

-------------------------------------

2020-06-24T11:09:17.678Z: user: vladas
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;

var N = 524288;
var BLOCKS = 8;
var THETA = 2.;

var interactions = 0; /* possible parvar */

var block_size = Math.floor(N / BLOCKS);

//// following are commented out comments
//#pragma parvar Tree
//#pragma parvar particles
//#pragma parvar parts
//#pragma parvar points
//#pragma parvar blk_acc
//#pragma parvar acc
//#pragma parvar interactions
//#pragma noautoparvar
//#pragma wait
//#pragma parallel
for (block = 0; block < BLOCKS; block++) {

/*
Vect.prototype.mulvs = function(s) {
    return new Vect(
      this.x * s,
      this.y * s,
      this.z * s
    );
};
*/

Vect.prototype.mulvs = function(s) {
      this.x *= s,
      this.y *= s,
      this.z *= s
    return this;
};

/*
Vect.prototype.addv = function(other) {
    return new Vect(
      this.x + other.x,
      this.y + other.y,
      this.z + other.z
    );
};
*/

Vect.prototype.addv = function(other) {
      this.x += other.x,
      this.y += other.y,
      this.z += other.z
    return this;
};

/*
Vect.prototype.subv = function(other) {
    return new Vect(
      this.x - other.x,
      this.y - other.y,
      this.z - other.z
    );
};
*/

Vect.prototype.subv = function(other) {
      this.x -= other.x,
      this.y -= other.y,
      this.z -= other.z
    return this;
};

Vect.prototype.dotvp = function(other) {
    return (
      this.x * other.x +
      this.y * other.y +
      this.z * other.z
    );
};

Vect.prototype.outvp = function(other) {
    return ([
      new Vect(this.x * other.x, this.x * other.y, this.x * other.z),
      new Vect(this.y * other.x, this.y * other.y, this.y * other.z),
      new Vect(this.z * other.x, this.z * other.y, this.z * other.z)
      ]
    );
};

Vect.prototype.mulms = function(vectarr, s) {
    return ([
      vectarr[0].mulvs(s),
      vectarr[1].mulvs(s),
      vectarr[2].mulvs(s)
      ]
    );
};

Vect.prototype.mulmv = function(vectarr, other) {
    return new Vect(
      vectarr[0].dotvp(other),
      vectarr[1].dotvp(other),
      vectarr[2].dotvp(other)
      );
};

Vect.prototype.subm = function(vectarr, otherarr) {
    return ([
      vectarr[0].subv(otherarr[0]),
      vectarr[1].subv(otherarr[1]),
      vectarr[2].subv(otherarr[2])
      ]
    );
};

Vect.prototype.addm = function(vectarr, otherarr) {
    return ([
      vectarr[0].addv(otherarr[0]),
      vectarr[1].addv(otherarr[1]),
      vectarr[2].addv(otherarr[2])
      ]
    );
};

Vect.prototype.normalized = function() {
    var mag = Math.sqrt(this.dotvp(this));
    return new Vect(
      this.x / mag,
      this.y / mag,
      this.z / mag
    );
};


Box.prototype.size = function() {
    return this.sz;
};

Cmass.prototype.mass = function() {
    return this.m;
};

Cmass.prototype.cpos = function() {
    return this.coords;
};

var particles = [];
var points = [];
var mass = 1.0;
var Tree = [];
var acc = [];
var interactions;
THETA=THETA;

var i;

var block_start = block * block_size;
var block_end = block_start + block_size - 1;
if (block_end >= N) block_end = N - 1;

console.log(block_start, block_end);

for (i = 0; i < N; i++) {
    particles[i] =  [Math.random()*10-5.0,Math.random()*10-5.0,
		Math.random()*10-5.0,Math.random()*10-5.0,
		Math.random()*10-5.0,Math.random()*10-5.0,mass];
    acc[i] = new Vect(0.,0.,0.);
    }

/*
particles = [
    [1.8,-2.3,-2.7,-3.6,0.3,-1.2,1.0],
    [2.9,-0.6,0.9,4.0,-4.2,-1.7,1.0],
    [0.6,-2.2,-2.2,-4.5,2.5,3.8,1.0],
    [0.9,-2.9,-4.5,-3.3,0.2,2.6,1.0],
    [3.2,-4.7,4.9,-1.2,-4.7,1.6,1.0],
    [-1.1,-0.1,4.4,-1.7,-1.6,1.6,1.0],
    [1.7,-2.2,0.9,2.8,-4.4,-0.4,1.0],
    [0.4,1.1,0.4,2.0,-4.2,2.9,1.0],
    [0.6,-1.9,-4.5,-3.7,3.8,2.0,1.0],
    [-3.9,3.0,0.4,-4.6,3.6,-1.3,1.0],
    [4.5,-2.4,3.0,4.2,3.6,4.1,1.0],
    [-2.4,-2.8,2.8,-3.7,-0.6,-3.2,1.0],
    [2.3,4.9,0.7,-0.2,0.7,-1.9,1.0],
    [-4.7,-0.6,2.0,4.4,-0.2,2.2,1.0],
    [4.0,-4.7,1.2,3.0,-2.2,3.8,1.0],
    [3.3,1.8,3.4,2.0,2.1,3.5,1.0]
    ];
*/


    for (i = 0; i < N; i++) {
	points[i] = [new Vect(particles[i][0], particles[i][1], particles[i][2]), i];
	}

    var parts = [];
    for (var i = block_start; i <= block_end; i++) {
	parts.push(particles[i]);
	}
    Tree = make_main_tree(parts);

// console.log(Tree);
    finish_time = new Date().getTime();
    elapse_time = (finish_time - start_time) / 1000;
    console.log("Elapse time: " + elapse_time + " sec");


    var init_level = [];
    for (var i = 0; i < block_end - block_start + 1; i++) {
	init_level[i] = [0, block_start + i, 0];
	}

    var blk_acc = [];
    for (i = block_start; i <= block_end; i++) {
	blk_acc[i] = new Vect(0.,0.,0.);
	}
    var inter = 0;
    var r = 0;
    inter = get_force(init_level, inter);

    interactions += inter;
//    for (i = block_start; i <= block_end; i++) {
//	acc[i].addv(blk_acc[i]);
//	}

    }

//console.log(acc);

//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec");

// Constructors

function Vect(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
}

function Box(coords, sz) {
    this.coords = coords;
    this.sz = sz;
}

function Cmass(m, coords) {
    this.m = m;
    this.coords = coords;
}

function make_main_tree(parts) {

    var x0 = 1000000.; y0 = x0; z0 = x0;
    var dx = -1000000.; dy = dx; dz = dx;

    var pa = [];
    for (var pi = 0; pi < parts.length; pi++) {
	pa = parts[pi];
	if (pa[0] < x0) x0 = pa[0];
	if (pa[1] < y0) y0 = pa[1];
	if (pa[2] < z0) z0 = pa[2];
	if (pa[0] > dx) dx = pa[0];
	if (pa[1] > dy) dy = pa[1];
	if (pa[2] > dz) dz = pa[2];
	}
    dx -= x0;
    dy -= y0;
    dz -= z0;
    
    return make_tree(parts, [[x0, y0, z0], [dx, dy, dz]]);

}

function make_tree(part, cell_box) {

    var desc = [0];
    
    var x0 = cell_box[0][0];
    var y0 = cell_box[0][1];
    var z0 = cell_box[0][2];
    var dx = cell_box[1][0];
    var dy = cell_box[1][1];
    var dz = cell_box[1][2];
    var hdx = dx / 2.;
    var hdy = dy / 2.;
    var hdz = dz / 2.;

    var zpart = [[],[]];
    var ypart = [[],[],[],[]];
    var xpart = [[],[],[],[],[],[],[],[]];

    if (part.length == 1) {
	return [[1, 
		   new Cmass(part[0][6], new Vect(part[0][0], part[0][1], part[0][2])),
		   [new Vect(0.,0.,0.), new Vect(0.,0.,0.), new Vect(0.,0.,0.)],
		   new Box(new Vect(cell_box[0][0],cell_box[0][1],cell_box[0][2]), 
			   new Vect(cell_box[1][0],cell_box[1][1],cell_box[1][2])),
		   [-1]
		   ]];
	}
    

// Split particles into 3D octants

    // z axis
    var pa = [];
    for (var hi = 0; hi < part.length; hi++) {
	pa = part[hi];
	if (pa[2] >= z0+hdz)
	    zpart[1].push(pa);
	else
	    zpart[0].push(pa);
	}

    // y axis
    for (var hj = 0; hj < 2; hj++) {
	for (var hz = 0; hz < zpart[hj].length; hz++) {
	    pa = zpart[hj][hz];
	    if (pa[0] >= x0+hdx)
		ypart[hj*2+1].push(pa);
	    else
		ypart[hj*2].push(pa);
	    }
	}
	
    // x axis
    for (var hj = 0; hj < 4; hj++) {
	for (var hz = 0; hz < ypart[hj].length; hz++) {
	    pa = ypart[hj][hz];
	    if (pa[1] >= y0+hdy)
		xpart[hj*2+1].push(pa);
	    else
		xpart[hj*2].push(pa);
	    }
	}

    var xhalf = x0 + hdx;
    var yhalf = y0 + hdy;
    var zhalf = z0 + hdz;
    var corners = [[x0, y0, z0], [x0, yhalf, z0], [xhalf, y0, z0],
		   [xhalf, yhalf, z0], [x0, y0, zhalf], [x0, yhalf, zhalf],
		   [xhalf, y0, zhalf], [xhalf, yhalf, zhalf]];

    var l;
    var children = [];
    for (var h = 0; h < xpart.length; h++) {
	if (xpart[h].length > 0) {
	    l = desc.length;
	    desc = desc.concat(make_tree(xpart[h], [corners[h], [hdx, hdy, hdz]]));
	    children.push(desc[l]);
	    }
	}

    var child_pos = [];
    var desc_nos = [];
    var desc_no = 1;
    var total_mass = 0.;
    var ch = [];
    var mx = 0., my = 0., mz = 0.;
    for (h = 0; h < children.length; h++) {
	ch = children[h];
	desc_nos[h] = ch[0];
	child_pos[h] = desc_no;
	desc_no += desc_nos[h];
	total_mass += ch[1].mass();
	mx += ch[1].mass() * ch[1].cpos().x;
	my += ch[1].mass() * ch[1].cpos().y;
	mz += ch[1].mass() * ch[1].cpos().z;
	}
	
    mx = mx / total_mass;
    my = my / total_mass;
    mz = mz / total_mass;
    var mv = new Vect(mx, my, mz);
    
//    console.log(child_pos);
//    console.log(desc_no);
//    console.log(mv);

    // Deep matrix algebra magic, called get_quad_moment
    var tmpm = [];
    var vct = new Vect(0,0,0);
    for (var q = 0; q < children.length; q++) {
	ch = children[q];
	var cmpos = ch[1].cpos();
	var cmass = ch[1].mass();
	var dr = mv.subv(cmpos);
	var drdr = dr.outvp(dr);
	var drsq = dr.dotvp(dr);
	var idrsq = [new Vect(1.,0.,0.), new Vect(0.,1.,0.), new Vect(0.,0.,1.)];
	idrsq = vct.mulms(idrsq, drsq);
	tmpm[q] = vct.mulms(drdr, 3.);
	tmpm[q] = vct.subm(tmpm[q], idrsq);
	tmpm[q] = vct.mulms(tmpm[q], cmass);
	if (ch[0] != 1) tmpm[q] = vct.addm(tmpm[q], ch[2]);
	}

    var rs = [[],[],[]];
    for (q = 0; q < children.length; q++) {
	rs[0].push(tmpm[q][0]);
	rs[1].push(tmpm[q][1]);
	rs[2].push(tmpm[q][2]);
	}

    var qa = [[0.,0.,0.],[0.,0.,0.],[0.,0.,0.]];
    for (j = 0; j <= 2; j++) {
	for (q = 0; q < children.length; q++) {
	    qa[j][0] += rs[j][q].x;
	    qa[j][1] += rs[j][q].y;
	    qa[j][2] += rs[j][q].z;
	    }
	}

    var quad = [new Vect(qa[0][0], qa[0][1], qa[0][2]),
		new Vect(qa[1][0], qa[1][1], qa[1][2]),
		new Vect(qa[2][0], qa[2][1], qa[2][2])
		];
    // End of get_quad_moment

    var new_desc = [desc_no, new Cmass(total_mass, mv),
		    quad,
		    new Box(new Vect(x0,y0,z0), new Vect(dx,dy,dz)),
		    child_pos];

    desc[0] = new_desc;

    return desc;

}

function get_force(curr_level, inter) {

    r++;
    var dr, dsq, cell_box, cell_size;
    var flags = [];
    var next_level = [], next_inds = [], this_level = [];

    for (var i = 0; i < curr_level.length; i++) {
	dr = Tree[curr_level[i][0]][1].cpos().subv(points[curr_level[i][1]][0]);
	dsq = dr.dotvp(dr);
	cell_box = Tree[curr_level[i][0]][3].size();
	cell_size = Math.max(cell_box.x, Math.max(cell_box.y, cell_box.z));
	if (cell_size >= THETA*Math.sqrt(dsq)) { // well_separated?
	    next_inds.push(curr_level[i]);
	    }
	else {
	    this_level.push(curr_level[i]);
	    }
	}

    // calculate forces

    inter += this_level.length;
    
    var forces = [];
    for (i = 0; i < this_level.length; i++) {
	var point = points[this_level[i][1]][1];
	// warning - sparce array!
	if (forces[point] == undefined) forces[point] = new Vect(0.,0.,0.);
	var t = Tree[this_level[i][0]];
//	forces[point] = 
	forces[point].addv(force(t[0], t[1], t[2], points[this_level[i][1]][0]));
	}

    for (i in forces) {
	if (blk_acc[i] == undefined) console.log(i);
//	blk_acc[i] = blk_acc[i].subv(forces[i]);
	blk_acc[i].subv(forces[i]);
	}

    if (next_inds.length == 0) return inter;

//console.log("next_inds");
//console.log(next_inds);

    var indices = [];
    for (i = 0; i < next_inds.length; i++) {
	var kids = Tree[next_inds[i][0]][4];
	var cell_ind = next_inds[i][2];
	indices[i] = [];
	for (j = 0; j < kids.length; j++) {
	    indices[i][j] = kids[j] + cell_ind;
	    }
	}

//console.log("indices");
//console.log(indices);

    var lens = [];
    var vals = [];
    for (i = 0; i < indices.length; i++) {
	lens[i] = indices[i].length;
	for (j = 0; j < indices[i].length; j++) {
	    vals.push(indices[i][j]);
	    }
	}
    
    nested_kids = [];
    i = 0;
    // vals patition
    for (j = 0; j < lens.length; j++) {
	nested_kids[j] = [];
	for (k = 0; k < lens[j]; k++) {
	    nested_kids[j][k] = vals[i++];
	    }
	}

//console.log("nested_kids");
//console.log(nested_kids);

    for (i = 0; i < nested_kids.length; i++) {
	for (j = 0; j < nested_kids[i].length; j++) {
	    next_level.push([nested_kids[i][j], next_inds[i][1], indices[i][j]]);
	    }
	}

//console.log("next_level");
//console.log(next_level);

if (r == 1) return inter;

    return get_force(next_level, inter);

}

function force(d, cm, quad, ppos) {

    var acc;
    var M = cm.mass();
    var cm_pos = cm.cpos();
    var dr = cm_pos.subv(ppos);
    if (dr.x == 0. && dr.y == 0. && dr.z == 0.) return dr;

    var drsq = dr.dotvp(dr);
    var drabs = Math.sqrt(drsq);
    var mrcubed = M / (drsq * drabs);
    acc = new Vect(dr.x * mrcubed, dr.y * mrcubed, dr.z * mrcubed);
    if (d == 1) return acc;

    var dr5inv = 1. / (drsq * drsq * drabs);
    var vct = new Vect(0,0,0);
    var quad_dr = vct.mulmv(quad,dr);
    var dr_quad_dr = dr.dotvp(quad_dr);
    var phi_quad = -2.5 * dr_quad_dr * dr5inv / drsq;
    var ai = dr.mulvs(phi_quad);
//    acc = 
    acc.subv(ai);
    quad_dr = quad_dr.mulvs(dr5inv);
//    acc = 
    acc.subv(quad_dr);

    return acc;

}

-------------------------------------

2020-06-24T11:10:38.095Z: user: vladas
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;

var N = 524288;
var BLOCKS = 8;
var THETA = 2.;

var interactions = 0; /* possible parvar */

var block_size = Math.floor(N / BLOCKS);

//// following are commented out comments
//#pragma parvar Tree
//#pragma parvar particles
//#pragma parvar parts
//#pragma parvar points
//#pragma parvar blk_acc
//#pragma parvar acc
//#pragma parvar interactions
//#pragma noautoparvar
//#pragma wait
//#pragma parallel
for (block = 0; block < BLOCKS; block++) {

/*
Vect.prototype.mulvs = function(s) {
    return new Vect(
      this.x * s,
      this.y * s,
      this.z * s
    );
};
*/

Vect.prototype.mulvs = function(s) {
      this.x *= s,
      this.y *= s,
      this.z *= s
    return this;
};

/*
Vect.prototype.addv = function(other) {
    return new Vect(
      this.x + other.x,
      this.y + other.y,
      this.z + other.z
    );
};
*/

Vect.prototype.addv = function(other) {
      this.x += other.x,
      this.y += other.y,
      this.z += other.z
    return this;
};

/*
Vect.prototype.subv = function(other) {
    return new Vect(
      this.x - other.x,
      this.y - other.y,
      this.z - other.z
    );
};
*/

Vect.prototype.subv = function(other) {
      this.x -= other.x,
      this.y -= other.y,
      this.z -= other.z
    return this;
};

Vect.prototype.dotvp = function(other) {
    return (
      this.x * other.x +
      this.y * other.y +
      this.z * other.z
    );
};

Vect.prototype.outvp = function(other) {
    return ([
      new Vect(this.x * other.x, this.x * other.y, this.x * other.z),
      new Vect(this.y * other.x, this.y * other.y, this.y * other.z),
      new Vect(this.z * other.x, this.z * other.y, this.z * other.z)
      ]
    );
};

Vect.prototype.mulms = function(vectarr, s) {
    return ([
      vectarr[0].mulvs(s),
      vectarr[1].mulvs(s),
      vectarr[2].mulvs(s)
      ]
    );
};

Vect.prototype.mulmv = function(vectarr, other) {
    return new Vect(
      vectarr[0].dotvp(other),
      vectarr[1].dotvp(other),
      vectarr[2].dotvp(other)
      );
};

Vect.prototype.subm = function(vectarr, otherarr) {
    return ([
      vectarr[0].subv(otherarr[0]),
      vectarr[1].subv(otherarr[1]),
      vectarr[2].subv(otherarr[2])
      ]
    );
};

Vect.prototype.addm = function(vectarr, otherarr) {
    return ([
      vectarr[0].addv(otherarr[0]),
      vectarr[1].addv(otherarr[1]),
      vectarr[2].addv(otherarr[2])
      ]
    );
};

Vect.prototype.normalized = function() {
    var mag = Math.sqrt(this.dotvp(this));
    return new Vect(
      this.x / mag,
      this.y / mag,
      this.z / mag
    );
};


Box.prototype.size = function() {
    return this.sz;
};

Cmass.prototype.mass = function() {
    return this.m;
};

Cmass.prototype.cpos = function() {
    return this.coords;
};

var particles = [];
var points = [];
var mass = 1.0;
var Tree = [];
var acc = [];
var interactions;
THETA=THETA;

var i;

var block_start = block * block_size;
var block_end = block_start + block_size - 1;
if (block_end >= N) block_end = N - 1;

console.log(block_start, block_end);

for (i = 0; i < N; i++) {
    particles[i] =  [Math.random()*10-5.0,Math.random()*10-5.0,
		Math.random()*10-5.0,Math.random()*10-5.0,
		Math.random()*10-5.0,Math.random()*10-5.0,mass];
    acc[i] = new Vect(0.,0.,0.);
    }

/*
particles = [
    [1.8,-2.3,-2.7,-3.6,0.3,-1.2,1.0],
    [2.9,-0.6,0.9,4.0,-4.2,-1.7,1.0],
    [0.6,-2.2,-2.2,-4.5,2.5,3.8,1.0],
    [0.9,-2.9,-4.5,-3.3,0.2,2.6,1.0],
    [3.2,-4.7,4.9,-1.2,-4.7,1.6,1.0],
    [-1.1,-0.1,4.4,-1.7,-1.6,1.6,1.0],
    [1.7,-2.2,0.9,2.8,-4.4,-0.4,1.0],
    [0.4,1.1,0.4,2.0,-4.2,2.9,1.0],
    [0.6,-1.9,-4.5,-3.7,3.8,2.0,1.0],
    [-3.9,3.0,0.4,-4.6,3.6,-1.3,1.0],
    [4.5,-2.4,3.0,4.2,3.6,4.1,1.0],
    [-2.4,-2.8,2.8,-3.7,-0.6,-3.2,1.0],
    [2.3,4.9,0.7,-0.2,0.7,-1.9,1.0],
    [-4.7,-0.6,2.0,4.4,-0.2,2.2,1.0],
    [4.0,-4.7,1.2,3.0,-2.2,3.8,1.0],
    [3.3,1.8,3.4,2.0,2.1,3.5,1.0]
    ];
*/


    for (i = 0; i < N; i++) {
	points[i] = [new Vect(particles[i][0], particles[i][1], particles[i][2]), i];
	}

    var parts = [];
    for (var i = block_start; i <= block_end; i++) {
	parts.push(particles[i]);
	}
    Tree = make_main_tree(parts);

// console.log(Tree);
    finish_time = new Date().getTime();
    elapse_time = (finish_time - start_time) / 1000;
    console.log("Elapse time: " + elapse_time + " sec");


    var init_level = [];
    for (var i = 0; i < block_end - block_start + 1; i++) {
	init_level[i] = [0, block_start + i, 0];
	}

    var blk_acc = [];
    for (i = block_start; i <= block_end; i++) {
	blk_acc[i] = new Vect(0.,0.,0.);
	}
    var inter = 0;
    var r = 0;
    inter = get_force(init_level, inter);

    interactions += inter;
//    for (i = block_start; i <= block_end; i++) {
//	acc[i].addv(blk_acc[i]);
//	}

    }

//console.log(acc);

//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Total elapse time: " + elapse_time + " sec");

// Constructors

function Vect(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
}

function Box(coords, sz) {
    this.coords = coords;
    this.sz = sz;
}

function Cmass(m, coords) {
    this.m = m;
    this.coords = coords;
}

function make_main_tree(parts) {

    var x0 = 1000000.; y0 = x0; z0 = x0;
    var dx = -1000000.; dy = dx; dz = dx;

    var pa = [];
    for (var pi = 0; pi < parts.length; pi++) {
	pa = parts[pi];
	if (pa[0] < x0) x0 = pa[0];
	if (pa[1] < y0) y0 = pa[1];
	if (pa[2] < z0) z0 = pa[2];
	if (pa[0] > dx) dx = pa[0];
	if (pa[1] > dy) dy = pa[1];
	if (pa[2] > dz) dz = pa[2];
	}
    dx -= x0;
    dy -= y0;
    dz -= z0;
    
    return make_tree(parts, [[x0, y0, z0], [dx, dy, dz]]);

}

function make_tree(part, cell_box) {

    var desc = [0];
    
    var x0 = cell_box[0][0];
    var y0 = cell_box[0][1];
    var z0 = cell_box[0][2];
    var dx = cell_box[1][0];
    var dy = cell_box[1][1];
    var dz = cell_box[1][2];
    var hdx = dx / 2.;
    var hdy = dy / 2.;
    var hdz = dz / 2.;

    var zpart = [[],[]];
    var ypart = [[],[],[],[]];
    var xpart = [[],[],[],[],[],[],[],[]];

    if (part.length == 1) {
	return [[1, 
		   new Cmass(part[0][6], new Vect(part[0][0], part[0][1], part[0][2])),
		   [new Vect(0.,0.,0.), new Vect(0.,0.,0.), new Vect(0.,0.,0.)],
		   new Box(new Vect(cell_box[0][0],cell_box[0][1],cell_box[0][2]), 
			   new Vect(cell_box[1][0],cell_box[1][1],cell_box[1][2])),
		   [-1]
		   ]];
	}
    

// Split particles into 3D octants

    // z axis
    var pa = [];
    for (var hi = 0; hi < part.length; hi++) {
	pa = part[hi];
	if (pa[2] >= z0+hdz)
	    zpart[1].push(pa);
	else
	    zpart[0].push(pa);
	}

    // y axis
    for (var hj = 0; hj < 2; hj++) {
	for (var hz = 0; hz < zpart[hj].length; hz++) {
	    pa = zpart[hj][hz];
	    if (pa[0] >= x0+hdx)
		ypart[hj*2+1].push(pa);
	    else
		ypart[hj*2].push(pa);
	    }
	}
	
    // x axis
    for (var hj = 0; hj < 4; hj++) {
	for (var hz = 0; hz < ypart[hj].length; hz++) {
	    pa = ypart[hj][hz];
	    if (pa[1] >= y0+hdy)
		xpart[hj*2+1].push(pa);
	    else
		xpart[hj*2].push(pa);
	    }
	}

    var xhalf = x0 + hdx;
    var yhalf = y0 + hdy;
    var zhalf = z0 + hdz;
    var corners = [[x0, y0, z0], [x0, yhalf, z0], [xhalf, y0, z0],
		   [xhalf, yhalf, z0], [x0, y0, zhalf], [x0, yhalf, zhalf],
		   [xhalf, y0, zhalf], [xhalf, yhalf, zhalf]];

    var l;
    var children = [];
    for (var h = 0; h < xpart.length; h++) {
	if (xpart[h].length > 0) {
	    l = desc.length;
	    desc = desc.concat(make_tree(xpart[h], [corners[h], [hdx, hdy, hdz]]));
	    children.push(desc[l]);
	    }
	}

    var child_pos = [];
    var desc_nos = [];
    var desc_no = 1;
    var total_mass = 0.;
    var ch = [];
    var mx = 0., my = 0., mz = 0.;
    for (h = 0; h < children.length; h++) {
	ch = children[h];
	desc_nos[h] = ch[0];
	child_pos[h] = desc_no;
	desc_no += desc_nos[h];
	total_mass += ch[1].mass();
	mx += ch[1].mass() * ch[1].cpos().x;
	my += ch[1].mass() * ch[1].cpos().y;
	mz += ch[1].mass() * ch[1].cpos().z;
	}
	
    mx = mx / total_mass;
    my = my / total_mass;
    mz = mz / total_mass;
    var mv = new Vect(mx, my, mz);
    
//    console.log(child_pos);
//    console.log(desc_no);
//    console.log(mv);

    // Deep matrix algebra magic, called get_quad_moment
    var tmpm = [];
    var vct = new Vect(0,0,0);
    for (var q = 0; q < children.length; q++) {
	ch = children[q];
	var cmpos = ch[1].cpos();
	var cmass = ch[1].mass();
	var dr = mv.subv(cmpos);
	var drdr = dr.outvp(dr);
	var drsq = dr.dotvp(dr);
	var idrsq = [new Vect(1.,0.,0.), new Vect(0.,1.,0.), new Vect(0.,0.,1.)];
	idrsq = vct.mulms(idrsq, drsq);
	tmpm[q] = vct.mulms(drdr, 3.);
	tmpm[q] = vct.subm(tmpm[q], idrsq);
	tmpm[q] = vct.mulms(tmpm[q], cmass);
	if (ch[0] != 1) tmpm[q] = vct.addm(tmpm[q], ch[2]);
	}

    var rs = [[],[],[]];
    for (q = 0; q < children.length; q++) {
	rs[0].push(tmpm[q][0]);
	rs[1].push(tmpm[q][1]);
	rs[2].push(tmpm[q][2]);
	}

    var qa = [[0.,0.,0.],[0.,0.,0.],[0.,0.,0.]];
    for (j = 0; j <= 2; j++) {
	for (q = 0; q < children.length; q++) {
	    qa[j][0] += rs[j][q].x;
	    qa[j][1] += rs[j][q].y;
	    qa[j][2] += rs[j][q].z;
	    }
	}

    var quad = [new Vect(qa[0][0], qa[0][1], qa[0][2]),
		new Vect(qa[1][0], qa[1][1], qa[1][2]),
		new Vect(qa[2][0], qa[2][1], qa[2][2])
		];
    // End of get_quad_moment

    var new_desc = [desc_no, new Cmass(total_mass, mv),
		    quad,
		    new Box(new Vect(x0,y0,z0), new Vect(dx,dy,dz)),
		    child_pos];

    desc[0] = new_desc;

    return desc;

}

function get_force(curr_level, inter) {

    r++;
    var dr, dsq, cell_box, cell_size;
    var flags = [];
    var next_level = [], next_inds = [], this_level = [];

    for (var i = 0; i < curr_level.length; i++) {
	dr = Tree[curr_level[i][0]][1].cpos().subv(points[curr_level[i][1]][0]);
	dsq = dr.dotvp(dr);
	cell_box = Tree[curr_level[i][0]][3].size();
	cell_size = Math.max(cell_box.x, Math.max(cell_box.y, cell_box.z));
	if (cell_size >= THETA*Math.sqrt(dsq)) { // well_separated?
	    next_inds.push(curr_level[i]);
	    }
	else {
	    this_level.push(curr_level[i]);
	    }
	}

    // calculate forces

    inter += this_level.length;
    
    var forces = [];
    for (i = 0; i < this_level.length; i++) {
	var point = points[this_level[i][1]][1];
	// warning - sparce array!
	if (forces[point] == undefined) forces[point] = new Vect(0.,0.,0.);
	var t = Tree[this_level[i][0]];
//	forces[point] = 
	forces[point].addv(force(t[0], t[1], t[2], points[this_level[i][1]][0]));
	}

    for (i in forces) {
	if (blk_acc[i] == undefined) console.log(i);
//	blk_acc[i] = blk_acc[i].subv(forces[i]);
	blk_acc[i].subv(forces[i]);
	}

    if (next_inds.length == 0) return inter;

//console.log("next_inds");
//console.log(next_inds);

    var indices = [];
    for (i = 0; i < next_inds.length; i++) {
	var kids = Tree[next_inds[i][0]][4];
	var cell_ind = next_inds[i][2];
	indices[i] = [];
	for (j = 0; j < kids.length; j++) {
	    indices[i][j] = kids[j] + cell_ind;
	    }
	}

//console.log("indices");
//console.log(indices);

    var lens = [];
    var vals = [];
    for (i = 0; i < indices.length; i++) {
	lens[i] = indices[i].length;
	for (j = 0; j < indices[i].length; j++) {
	    vals.push(indices[i][j]);
	    }
	}
    
    nested_kids = [];
    i = 0;
    // vals patition
    for (j = 0; j < lens.length; j++) {
	nested_kids[j] = [];
	for (k = 0; k < lens[j]; k++) {
	    nested_kids[j][k] = vals[i++];
	    }
	}

//console.log("nested_kids");
//console.log(nested_kids);

    for (i = 0; i < nested_kids.length; i++) {
	for (j = 0; j < nested_kids[i].length; j++) {
	    next_level.push([nested_kids[i][j], next_inds[i][1], indices[i][j]]);
	    }
	}

//console.log("next_level");
//console.log(next_level);

if (r == 1) return inter;

    return get_force(next_level, inter);

}

function force(d, cm, quad, ppos) {

    var acc;
    var M = cm.mass();
    var cm_pos = cm.cpos();
    var dr = cm_pos.subv(ppos);
    if (dr.x == 0. && dr.y == 0. && dr.z == 0.) return dr;

    var drsq = dr.dotvp(dr);
    var drabs = Math.sqrt(drsq);
    var mrcubed = M / (drsq * drabs);
    acc = new Vect(dr.x * mrcubed, dr.y * mrcubed, dr.z * mrcubed);
    if (d == 1) return acc;

    var dr5inv = 1. / (drsq * drsq * drabs);
    var vct = new Vect(0,0,0);
    var quad_dr = vct.mulmv(quad,dr);
    var dr_quad_dr = dr.dotvp(quad_dr);
    var phi_quad = -2.5 * dr_quad_dr * dr5inv / drsq;
    var ai = dr.mulvs(phi_quad);
//    acc = 
    acc.subv(ai);
    quad_dr = quad_dr.mulvs(dr5inv);
//    acc = 
    acc.subv(quad_dr);

    return acc;

}

-------------------------------------

2020-06-24T11:12:44.483Z: user: vladas
// use --max-old-space-size=2048 with node binary
// Embarrassingly parallel NAS benchmark

//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;

var OPUS = 8;

// var n = 268435456;  // 2^28  - Class A
var n = 1073741824; // 2^30  - Class B
var q = [0,0,0,0,0,0,0,0,0,0];
var sx = 0; sy = 0;

//#pragma parvar q
//#pragma parvar sx
//#pragma parvar sy
//#pragma wait
//#pragma parallel
for (k = 1; k <= 8; k++) {
    var chunk_len = Math.floor(n / OPUS);
    var slice_start = (k-1) * chunk_len;
    var slice_end = slice_start + chunk_len - 1;
    if (slice_end >= n) slice_end = n - 1;

    var x1, x2, sxk = 0, syk = 0;
    var t1, t2, t3, t4;
    var l;
    var qk = [0,0,0,0,0,0,0,0,0,0];

    for (var i = slice_start; i < slice_end; i++) {
	x1 = 2 * Math.random() - 1;
	x2 = 2 * Math.random() - 1;
	t1 = x1 * x1 + x2 * x2;
	if (t1 <= 1.0) {
	    t2 = Math.sqrt(-2.0 * Math.log(t1) / t1);
	    t3 = x1 * t2;
	    t4 = x2 * t2;
	    l = Math.floor(Math.max(Math.abs(t3), Math.abs(t4)));
	    qk[l] = qk[l] + 1;
	    sxk += t3;
	    syk += t4;
	    }
	}

    for (i = 0; i < 10; i++) q[i] = q[i] + qk[i];
    sx = sx + sxk;
    sy = sy + syk;
    }

//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");

var timchk = 0;
var sxtchk = 0;
var syschk = 0;
var qchk = [];

if (n == 268435456) {
    timchk = 70.0;
    sxchk = -4.295875165629892e3;
    sychk = -1.580732573678431e4;
    qchk = [98257395, 93827014, 17611549, 1110028, 26536, 245, 0, 0, 0, 0];
    }
if (n == 1073741824) {
    timchk = 267.5;
    sxchk = 4.033815542441498e4;
    sychk = -2.660669192809235e4;
    qchk = [393058470, 375280898, 70460742, 4438852, 105691, 948, 5, 0, 0, 0];
    }


console.log("Problem size: n = " + n);
console.log("Total execution time:     " + elapse_time);
console.log("Reference execution time: " + timchk);

console.log("\n");
console.log("Computed sx:     " + sx);
console.log("Reference value: " + sxchk);
console.log("\n");
console.log("Computed sy:     " + sy);
console.log("Reference value: " + sychk);
console.log("\n");
console.log("Q values: ");
console.log(q);
console.log("Reference Q values: ");
console.log(qchk);



-------------------------------------

2020-06-24T11:13:54.655Z: user: vladas
// use --max-old-space-size=2048 with node binary
// Embarrassingly parallel NAS benchmark

//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;

var OPUS = 8;

// var n = 268435456;  // 2^28  - Class A
var n = 1073741824; // 2^30  - Class B
var q = [0,0,0,0,0,0,0,0,0,0];
var sx = 0; sy = 0;

//#pragma parvar q
//#pragma parvar sx
//#pragma parvar sy
//#pragma wait
//#pragma parallel
for (k = 1; k <= 8; k++) {
    var chunk_len = Math.floor(n / OPUS);
    var slice_start = (k-1) * chunk_len;
    var slice_end = slice_start + chunk_len - 1;
    if (slice_end >= n) slice_end = n - 1;

    var x1, x2, sxk = 0, syk = 0;
    var t1, t2, t3, t4;
    var l;
    var qk = [0,0,0,0,0,0,0,0,0,0];

    for (var i = slice_start; i < slice_end; i++) {
	x1 = 2 * Math.random() - 1;
	x2 = 2 * Math.random() - 1;
	t1 = x1 * x1 + x2 * x2;
	if (t1 <= 1.0) {
	    t2 = Math.sqrt(-2.0 * Math.log(t1) / t1);
	    t3 = x1 * t2;
	    t4 = x2 * t2;
	    l = Math.floor(Math.max(Math.abs(t3), Math.abs(t4)));
	    qk[l] = qk[l] + 1;
	    sxk += t3;
	    syk += t4;
	    }
	}

    for (i = 0; i < 10; i++) q[i] = q[i] + qk[i];
    sx = sx + sxk;
    sy = sy + syk;
    }

//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");

var timchk = 0;
var sxtchk = 0;
var syschk = 0;
var qchk = [];

if (n == 268435456) {
    timchk = 70.0;
    sxchk = -4.295875165629892e3;
    sychk = -1.580732573678431e4;
    qchk = [98257395, 93827014, 17611549, 1110028, 26536, 245, 0, 0, 0, 0];
    }
if (n == 1073741824) {
    timchk = 267.5;
    sxchk = 4.033815542441498e4;
    sychk = -2.660669192809235e4;
    qchk = [393058470, 375280898, 70460742, 4438852, 105691, 948, 5, 0, 0, 0];
    }


console.log("Problem size: n = " + n);
console.log("Total execution time:     " + elapse_time);
console.log("Reference execution time: " + timchk);

console.log("\n");
console.log("Computed sx:     " + sx);
console.log("Reference value: " + sxchk);
console.log("\n");
console.log("Computed sy:     " + sy);
console.log("Reference value: " + sychk);
console.log("\n");
console.log("Q values: ");
console.log(q);
console.log("Reference Q values: ");
console.log(qchk);



-------------------------------------

2020-06-24T11:15:25.550Z: user: vladas
// use --max-old-space-size=2048 with node binary
// Embarrassingly parallel NAS benchmark

//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;

var OPUS = 8;

// var n = 268435456;  // 2^28  - Class A
var n = 1073741824; // 2^30  - Class B
var q = [0,0,0,0,0,0,0,0,0,0];
var sx = 0; sy = 0;

//#pragma parvar q
//#pragma parvar sx
//#pragma parvar sy
//#pragma wait
//#pragma parallel
for (k = 1; k <= 8; k++) {
    var chunk_len = Math.floor(n / OPUS);
    var slice_start = (k-1) * chunk_len;
    var slice_end = slice_start + chunk_len - 1;
    if (slice_end >= n) slice_end = n - 1;

    var x1, x2, sxk = 0, syk = 0;
    var t1, t2, t3, t4;
    var l;
    var qk = [0,0,0,0,0,0,0,0,0,0];

    for (var i = slice_start; i < slice_end; i++) {
	x1 = 2 * Math.random() - 1;
	x2 = 2 * Math.random() - 1;
	t1 = x1 * x1 + x2 * x2;
	if (t1 <= 1.0) {
	    t2 = Math.sqrt(-2.0 * Math.log(t1) / t1);
	    t3 = x1 * t2;
	    t4 = x2 * t2;
	    l = Math.floor(Math.max(Math.abs(t3), Math.abs(t4)));
	    qk[l] = qk[l] + 1;
	    sxk += t3;
	    syk += t4;
	    }
	}

    for (i = 0; i < 10; i++) q[i] = q[i] + qk[i];
    sx = sx + sxk;
    sy = sy + syk;
    }

//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");

var timchk = 0;
var sxtchk = 0;
var syschk = 0;
var qchk = [];

if (n == 268435456) {
    timchk = 70.0;
    sxchk = -4.295875165629892e3;
    sychk = -1.580732573678431e4;
    qchk = [98257395, 93827014, 17611549, 1110028, 26536, 245, 0, 0, 0, 0];
    }
if (n == 1073741824) {
    timchk = 267.5;
    sxchk = 4.033815542441498e4;
    sychk = -2.660669192809235e4;
    qchk = [393058470, 375280898, 70460742, 4438852, 105691, 948, 5, 0, 0, 0];
    }


console.log("Problem size: n = " + n);
console.log("Total execution time:     " + elapse_time);
console.log("Reference execution time: " + timchk);

console.log("\n");
console.log("Computed sx:     " + sx);
console.log("Reference value: " + sxchk);
console.log("\n");
console.log("Computed sy:     " + sy);
console.log("Reference value: " + sychk);
console.log("\n");
console.log("Q values: ");
console.log(q);
console.log("Reference Q values: ");
console.log(qchk);



-------------------------------------

2020-06-24T11:17:51.468Z: user: vladas
// use --max-old-space-size=2048 with node binary
// Embarrassingly parallel NAS benchmark

//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;

var OPUS = 8;

// var n = 268435456;  // 2^28  - Class A
var n = 1073741824; // 2^30  - Class B
var q = [0,0,0,0,0,0,0,0,0,0];
var sx = 0; sy = 0;

//#pragma parvar q
//#pragma parvar sx
//#pragma parvar sy
//#pragma wait
//#pragma parallel
for (k = 0; k < 8; k++) {
    var chunk_len = Math.floor(n / OPUS);
    var slice_start = k * chunk_len;
    var slice_end = slice_start + chunk_len - 1;
    if (slice_end >= n) slice_end = n - 1;

    var x1, x2, sxk = 0, syk = 0;
    var t1, t2, t3, t4;
    var l;
    var qk = [0,0,0,0,0,0,0,0,0,0];

    for (var i = slice_start; i < slice_end; i++) {
	x1 = 2 * Math.random() - 1;
	x2 = 2 * Math.random() - 1;
	t1 = x1 * x1 + x2 * x2;
	if (t1 <= 1.0) {
	    t2 = Math.sqrt(-2.0 * Math.log(t1) / t1);
	    t3 = x1 * t2;
	    t4 = x2 * t2;
	    l = Math.floor(Math.max(Math.abs(t3), Math.abs(t4)));
	    qk[l] = qk[l] + 1;
	    sxk += t3;
	    syk += t4;
	    }
	}

    for (i = 0; i < 10; i++) q[i] = q[i] + qk[i];
    sx = sx + sxk;
    sy = sy + syk;
    }

//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");

var timchk = 0;
var sxtchk = 0;
var syschk = 0;
var qchk = [];

if (n == 268435456) {
    timchk = 70.0;
    sxchk = -4.295875165629892e3;
    sychk = -1.580732573678431e4;
    qchk = [98257395, 93827014, 17611549, 1110028, 26536, 245, 0, 0, 0, 0];
    }
if (n == 1073741824) {
    timchk = 267.5;
    sxchk = 4.033815542441498e4;
    sychk = -2.660669192809235e4;
    qchk = [393058470, 375280898, 70460742, 4438852, 105691, 948, 5, 0, 0, 0];
    }


console.log("Problem size: n = " + n);
console.log("Total execution time:     " + elapse_time);
console.log("Reference execution time: " + timchk);

console.log("\n");
console.log("Computed sx:     " + sx);
console.log("Reference value: " + sxchk);
console.log("\n");
console.log("Computed sy:     " + sy);
console.log("Reference value: " + sychk);
console.log("\n");
console.log("Q values: ");
console.log(q);
console.log("Reference Q values: ");
console.log(qchk);



-------------------------------------

2020-06-24T11:25:26.911Z: user: vladas
// use --max-old-space-size=2048 with node binary
// Embarrassingly parallel NAS benchmark

//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;

var OPUS = 8;

// var n = 268435456;  // 2^28  - Class A
var n = 1073741824; // 2^30  - Class B
var q = [0,0,0,0,0,0,0,0,0,0];
var sx = 0; sy = 0;

//#pragma parvar q
//#pragma parvar sx
//#pragma parvar sy
//#pragma wait
//#pragma parallel
for (k = 1; k <= 8; k++) {
    var chunk_len = Math.floor(n / OPUS);
    var slice_start = (k-1) * chunk_len;
    var slice_end = slice_start + chunk_len - 1;
    if (slice_end >= n) slice_end = n - 1;

    var x1, x2, sxk = 0, syk = 0;
    var t1, t2, t3, t4;
    var l;
    var qk = [0,0,0,0,0,0,0,0,0,0];

    for (var i = slice_start; i < slice_end; i++) {
	x1 = 2 * Math.random() - 1;
	x2 = 2 * Math.random() - 1;
	t1 = x1 * x1 + x2 * x2;
	if (t1 <= 1.0) {
	    t2 = Math.sqrt(-2.0 * Math.log(t1) / t1);
	    t3 = x1 * t2;
	    t4 = x2 * t2;
	    l = Math.floor(Math.max(Math.abs(t3), Math.abs(t4)));
	    qk[l] = qk[l] + 1;
	    sxk += t3;
	    syk += t4;
	    }
	}

    for (i = 0; i < 10; i++) q[i] = q[i] + qk[i];
    sx = sx + sxk;
    sy = sy + syk;
    }

//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");

var timchk = 0;
var sxtchk = 0;
var syschk = 0;
var qchk = [];

if (n == 268435456) {
    timchk = 70.0;
    sxchk = -4.295875165629892e3;
    sychk = -1.580732573678431e4;
    qchk = [98257395, 93827014, 17611549, 1110028, 26536, 245, 0, 0, 0, 0];
    }
if (n == 1073741824) {
    timchk = 267.5;
    sxchk = 4.033815542441498e4;
    sychk = -2.660669192809235e4;
    qchk = [393058470, 375280898, 70460742, 4438852, 105691, 948, 5, 0, 0, 0];
    }


console.log("Problem size: n = " + n);
console.log("Total execution time:     " + elapse_time);
console.log("Reference execution time: " + timchk);

console.log("\n");
console.log("Computed sx:     " + sx);
console.log("Reference value: " + sxchk);
console.log("\n");
console.log("Computed sy:     " + sy);
console.log("Reference value: " + sychk);
console.log("\n");
console.log("Q values: ");
console.log(q);
console.log("Reference Q values: ");
console.log(qchk);



-------------------------------------

2020-06-24T11:26:25.561Z: user: vladas
// use --max-old-space-size=2048 with node binary
// Embarrassingly parallel NAS benchmark

//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;

var OPUS = 8;

// var n = 268435456;  // 2^28  - Class A
var n = 1073741824; // 2^30  - Class B
var q = [0,0,0,0,0,0,0,0,0,0];
var sx = 0; sy = 0;

//#pragma parvar q
//#pragma parvar sx
//#pragma parvar sy
//#pragma wait
//#pragma parallel
for (k = 1; k <= 8; k++) {
    var chunk_len = Math.floor(n / OPUS);
    var slice_start = (k-1) * chunk_len;
    var slice_end = slice_start + chunk_len - 1;
    if (slice_end >= n) slice_end = n - 1;

    var x1, x2, sxk = 0, syk = 0;
    var t1, t2, t3, t4;
    var l;
    var qk = [0,0,0,0,0,0,0,0,0,0];

    for (var i = slice_start; i < slice_end; i++) {
	x1 = 2 * Math.random() - 1;
	x2 = 2 * Math.random() - 1;
	t1 = x1 * x1 + x2 * x2;
	if (t1 <= 1.0) {
	    t2 = Math.sqrt(-2.0 * Math.log(t1) / t1);
	    t3 = x1 * t2;
	    t4 = x2 * t2;
	    l = Math.floor(Math.max(Math.abs(t3), Math.abs(t4)));
	    qk[l] = qk[l] + 1;
	    sxk += t3;
	    syk += t4;
	    }
	}

    for (i = 0; i < 10; i++) q[i] = q[i] + qk[i];
    sx = sx + sxk;
    sy = sy + syk;
    }

//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");

var timchk = 0;
var sxtchk = 0;
var syschk = 0;
var qchk = [];

if (n == 268435456) {
    timchk = 70.0;
    sxchk = -4.295875165629892e3;
    sychk = -1.580732573678431e4;
    qchk = [98257395, 93827014, 17611549, 1110028, 26536, 245, 0, 0, 0, 0];
    }
if (n == 1073741824) {
    timchk = 267.5;
    sxchk = 4.033815542441498e4;
    sychk = -2.660669192809235e4;
    qchk = [393058470, 375280898, 70460742, 4438852, 105691, 948, 5, 0, 0, 0];
    }


console.log("Problem size: n = " + n);
console.log("Total execution time:     " + elapse_time);
console.log("Reference execution time: " + timchk);

console.log("\n");
console.log("Computed sx:     " + sx);
console.log("Reference value: " + sxchk);
console.log("\n");
console.log("Computed sy:     " + sy);
console.log("Reference value: " + sychk);
console.log("\n");
console.log("Q values: ");
console.log(q);
console.log("Reference Q values: ");
console.log(qchk);



-------------------------------------

2020-06-24T11:27:11.318Z: user: vladas
// use --max-old-space-size=2048 with node binary
// Embarrassingly parallel NAS benchmark

//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;

var OPUS = 8;

// var n = 268435456;  // 2^28  - Class A
var n = 1073741824; // 2^30  - Class B
var q = [0,0,0,0,0,0,0,0,0,0];
var sx = 0; sy = 0;

//#pragma parvar q
//#pragma parvar sx
//#pragma parvar sy
//#pragma wait
//#pragma parallel
for (k = 1; k <= 8; k++) {
    var chunk_len = Math.floor(n / OPUS);
    var slice_start = (k-1) * chunk_len;
    var slice_end = slice_start + chunk_len - 1;
    if (slice_end >= n) slice_end = n - 1;

    var x1, x2, sxk = 0, syk = 0;
    var t1, t2, t3, t4;
    var l;
    var qk = [0,0,0,0,0,0,0,0,0,0];

    for (var i = slice_start; i < slice_end; i++) {
	x1 = 2 * Math.random() - 1;
	x2 = 2 * Math.random() - 1;
	t1 = x1 * x1 + x2 * x2;
	if (t1 <= 1.0) {
	    t2 = Math.sqrt(-2.0 * Math.log(t1) / t1);
	    t3 = x1 * t2;
	    t4 = x2 * t2;
	    l = Math.floor(Math.max(Math.abs(t3), Math.abs(t4)));
	    qk[l] = qk[l] + 1;
	    sxk += t3;
	    syk += t4;
	    }
	}

    for (i = 0; i < 10; i++) q[i] = q[i] + qk[i];
    sx = sx + sxk;
    sy = sy + syk;
    }

//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");

var timchk = 0;
var sxtchk = 0;
var syschk = 0;
var qchk = [];

if (n == 268435456) {
    timchk = 70.0;
    sxchk = -4.295875165629892e3;
    sychk = -1.580732573678431e4;
    qchk = [98257395, 93827014, 17611549, 1110028, 26536, 245, 0, 0, 0, 0];
    }
if (n == 1073741824) {
    timchk = 267.5;
    sxchk = 4.033815542441498e4;
    sychk = -2.660669192809235e4;
    qchk = [393058470, 375280898, 70460742, 4438852, 105691, 948, 5, 0, 0, 0];
    }


console.log("Problem size: n = " + n);
console.log("Total execution time:     " + elapse_time);
console.log("Reference execution time: " + timchk);

console.log("\n");
console.log("Computed sx:     " + sx);
console.log("Reference value: " + sxchk);
console.log("\n");
console.log("Computed sy:     " + sy);
console.log("Reference value: " + sychk);
console.log("\n");
console.log("Q values: ");
console.log(q);
console.log("Reference Q values: ");
console.log(qchk);



-------------------------------------

2020-06-24T11:28:58.578Z: user: vladas
// use --max-old-space-size=2048 with node binary
// Embarrassingly parallel NAS benchmark

//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;
console.log("Program started");

var OPUS = 8;

// var n = 268435456;  // 2^28  - Class A
var n = 1073741824; // 2^30  - Class B
var q = [0,0,0,0,0,0,0,0,0,0];
var sx = 0; sy = 0;

//#pragma parvar q
//#pragma parvar sx
//#pragma parvar sy
//#pragma wait
//#pragma parallel
for (k = 1; k <= OPUS; k++) {
    var chunk_len = Math.floor(n / OPUS);
    var slice_start = (k-1) * chunk_len;
    var slice_end = slice_start + chunk_len - 1;
    if (slice_end >= n) slice_end = n - 1;

    var x1, x2, sxk = 0, syk = 0;
    var t1, t2, t3, t4;
    var l;
    var qk = [0,0,0,0,0,0,0,0,0,0];

    for (var i = slice_start; i < slice_end; i++) {
	x1 = 2 * Math.random() - 1;
	x2 = 2 * Math.random() - 1;
	t1 = x1 * x1 + x2 * x2;
	if (t1 <= 1.0) {
	    t2 = Math.sqrt(-2.0 * Math.log(t1) / t1);
	    t3 = x1 * t2;
	    t4 = x2 * t2;
	    l = Math.floor(Math.max(Math.abs(t3), Math.abs(t4)));
	    qk[l] = qk[l] + 1;
	    sxk += t3;
	    syk += t4;
	    }
	}

    for (i = 0; i < 10; i++) q[i] = q[i] + qk[i];
    sx = sx + sxk;
    sy = sy + syk;
    }

//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");

var timchk = 0;
var sxtchk = 0;
var syschk = 0;
var qchk = [];

if (n == 268435456) {
    timchk = 70.0;
    sxchk = -4.295875165629892e3;
    sychk = -1.580732573678431e4;
    qchk = [98257395, 93827014, 17611549, 1110028, 26536, 245, 0, 0, 0, 0];
    }
if (n == 1073741824) {
    timchk = 267.5;
    sxchk = 4.033815542441498e4;
    sychk = -2.660669192809235e4;
    qchk = [393058470, 375280898, 70460742, 4438852, 105691, 948, 5, 0, 0, 0];
    }


console.log("Problem size: n = " + n);
console.log("Total execution time:     " + elapse_time);
console.log("Reference execution time: " + timchk);

console.log("\n");
console.log("Computed sx:     " + sx);
console.log("Reference value: " + sxchk);
console.log("\n");
console.log("Computed sy:     " + sy);
console.log("Reference value: " + sychk);
console.log("\n");
console.log("Q values: ");
console.log(q);
console.log("Reference Q values: ");
console.log(qchk);



-------------------------------------

2020-06-24T18:46:28.494Z: user: vladas
// use --max-old-space-size=2048 with node binary
// Embarrassingly parallel NAS benchmark

//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;
console.log("Program started");

var OPUS = 8;

var n = 268435456;  // 2^28  - Class A
//var n = 1073741824; // 2^30  - Class B
var q = [0,0,0,0,0,0,0,0,0,0];
var sx = 0; sy = 0;

//#pragma parvar q
//#pragma parvar sx
//#pragma parvar sy
//#pragma wait
//#pragma parallel
for (k = 1; k <= OPUS; k++) {
    var chunk_len = Math.floor(n / OPUS);
    var slice_start = (k-1) * chunk_len;
    var slice_end = slice_start + chunk_len - 1;
    if (slice_end >= n) slice_end = n - 1;

    var x1, x2, sxk = 0, syk = 0;
    var t1, t2, t3, t4;
    var l;
    var qk = [0,0,0,0,0,0,0,0,0,0];

    for (var i = slice_start; i < slice_end; i++) {
	x1 = 2 * Math.random() - 1;
	x2 = 2 * Math.random() - 1;
	t1 = x1 * x1 + x2 * x2;
	if (t1 <= 1.0) {
	    t2 = Math.sqrt(-2.0 * Math.log(t1) / t1);
	    t3 = x1 * t2;
	    t4 = x2 * t2;
	    l = Math.floor(Math.max(Math.abs(t3), Math.abs(t4)));
	    qk[l] = qk[l] + 1;
	    sxk += t3;
	    syk += t4;
	    }
	}

    for (i = 0; i < 10; i++) q[i] = q[i] + qk[i];
    sx = sx + sxk;
    sy = sy + syk;
    }

//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");

var timchk = 0;
var sxtchk = 0;
var syschk = 0;
var qchk = [];

if (n == 268435456) {
    timchk = 70.0;
    sxchk = -4.295875165629892e3;
    sychk = -1.580732573678431e4;
    qchk = [98257395, 93827014, 17611549, 1110028, 26536, 245, 0, 0, 0, 0];
    }
if (n == 1073741824) {
    timchk = 267.5;
    sxchk = 4.033815542441498e4;
    sychk = -2.660669192809235e4;
    qchk = [393058470, 375280898, 70460742, 4438852, 105691, 948, 5, 0, 0, 0];
    }


console.log("Problem size: n = " + n);
console.log("Total execution time:     " + elapse_time);
console.log("Reference execution time: " + timchk);

console.log("\n");
console.log("Computed sx:     " + sx);
console.log("Reference value: " + sxchk);
console.log("\n");
console.log("Computed sy:     " + sy);
console.log("Reference value: " + sychk);
console.log("\n");
console.log("Q values: ");
console.log(q);
console.log("Reference Q values: ");
console.log(qchk);



-------------------------------------

2020-06-24T18:47:18.208Z: user: vladas
// use --max-old-space-size=2048 with node binary
// Embarrassingly parallel NAS benchmark

//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;
console.log("Program started");

var OPUS = 8;

var n = 268435456;  // 2^28  - Class A
//var n = 1073741824; // 2^30  - Class B
var q = [0,0,0,0,0,0,0,0,0,0];
var sx = 0; sy = 0;

//#pragma parvar q
//#pragma parvar sx
//#pragma parvar sy
//#pragma wait
//#pragma parallel
for (k = 1; k <= OPUS; k++) {
    var chunk_len = Math.floor(n / OPUS);
    var slice_start = (k-1) * chunk_len;
    var slice_end = slice_start + chunk_len - 1;
    if (slice_end >= n) slice_end = n - 1;

    var x1, x2, sxk = 0, syk = 0;
    var t1, t2, t3, t4;
    var l;
    var qk = [0,0,0,0,0,0,0,0,0,0];

    for (var i = slice_start; i < slice_end; i++) {
	x1 = 2 * Math.random() - 1;
	x2 = 2 * Math.random() - 1;
	t1 = x1 * x1 + x2 * x2;
	if (t1 <= 1.0) {
	    t2 = Math.sqrt(-2.0 * Math.log(t1) / t1);
	    t3 = x1 * t2;
	    t4 = x2 * t2;
	    l = Math.floor(Math.max(Math.abs(t3), Math.abs(t4)));
	    qk[l] = qk[l] + 1;
	    sxk += t3;
	    syk += t4;
	    }
	}

    for (i = 0; i < 10; i++) q[i] = q[i] + qk[i];
    sx = sx + sxk;
    sy = sy + syk;
    }

//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");

var timchk = 0;
var sxtchk = 0;
var syschk = 0;
var qchk = [];

if (n == 268435456) {
    timchk = 70.0;
    sxchk = -4.295875165629892e3;
    sychk = -1.580732573678431e4;
    qchk = [98257395, 93827014, 17611549, 1110028, 26536, 245, 0, 0, 0, 0];
    }
if (n == 1073741824) {
    timchk = 267.5;
    sxchk = 4.033815542441498e4;
    sychk = -2.660669192809235e4;
    qchk = [393058470, 375280898, 70460742, 4438852, 105691, 948, 5, 0, 0, 0];
    }


console.log("Problem size: n = " + n);
console.log("Total execution time:     " + elapse_time);
console.log("Reference execution time: " + timchk);

console.log("\n");
console.log("Computed sx:     " + sx);
console.log("Reference value: " + sxchk);
console.log("\n");
console.log("Computed sy:     " + sy);
console.log("Reference value: " + sychk);
console.log("\n");
console.log("Q values: ");
console.log(q);
console.log("Reference Q values: ");
console.log(qchk);



-------------------------------------

2020-06-24T18:47:40.778Z: user: vladas
// use --max-old-space-size=2048 with node binary
// Embarrassingly parallel NAS benchmark

//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;
console.log("Program started");

var OPUS = 8;

var n = 268435456;  // 2^28  - Class A
//var n = 1073741824; // 2^30  - Class B
var q = [0,0,0,0,0,0,0,0,0,0];
var sx = 0; sy = 0;

//#pragma parvar q
//#pragma parvar sx
//#pragma parvar sy
//#pragma wait
//#pragma parallel
for (k = 1; k <= OPUS; k++) {
    var chunk_len = Math.floor(n / OPUS);
    var slice_start = (k-1) * chunk_len;
    var slice_end = slice_start + chunk_len - 1;
    if (slice_end >= n) slice_end = n - 1;

    var x1, x2, sxk = 0, syk = 0;
    var t1, t2, t3, t4;
    var l;
    var qk = [0,0,0,0,0,0,0,0,0,0];

    for (var i = slice_start; i < slice_end; i++) {
	x1 = 2 * Math.random() - 1;
	x2 = 2 * Math.random() - 1;
	t1 = x1 * x1 + x2 * x2;
	if (t1 <= 1.0) {
	    t2 = Math.sqrt(-2.0 * Math.log(t1) / t1);
	    t3 = x1 * t2;
	    t4 = x2 * t2;
	    l = Math.floor(Math.max(Math.abs(t3), Math.abs(t4)));
	    qk[l] = qk[l] + 1;
	    sxk += t3;
	    syk += t4;
	    }
	}

    for (i = 0; i < 10; i++) q[i] = q[i] + qk[i];
    sx = sx + sxk;
    sy = sy + syk;
    }

//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");

var timchk = 0;
var sxtchk = 0;
var syschk = 0;
var qchk = [];

if (n == 268435456) {
    timchk = 70.0;
    sxchk = -4.295875165629892e3;
    sychk = -1.580732573678431e4;
    qchk = [98257395, 93827014, 17611549, 1110028, 26536, 245, 0, 0, 0, 0];
    }
if (n == 1073741824) {
    timchk = 267.5;
    sxchk = 4.033815542441498e4;
    sychk = -2.660669192809235e4;
    qchk = [393058470, 375280898, 70460742, 4438852, 105691, 948, 5, 0, 0, 0];
    }


console.log("Problem size: n = " + n);
console.log("Total execution time:     " + elapse_time);
console.log("Reference execution time: " + timchk);

console.log("\n");
console.log("Computed sx:     " + sx);
console.log("Reference value: " + sxchk);
console.log("\n");
console.log("Computed sy:     " + sy);
console.log("Reference value: " + sychk);
console.log("\n");
console.log("Q values: ");
console.log(q);
console.log("Reference Q values: ");
console.log(qchk);



-------------------------------------

2020-06-24T18:48:25.610Z: user: vladas
// use --max-old-space-size=2048 with node binary
// Embarrassingly parallel NAS benchmark

//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;
console.log("Program started");

var OPUS = 6;

var n = 268435456;  // 2^28  - Class A
//var n = 1073741824; // 2^30  - Class B
var q = [0,0,0,0,0,0,0,0,0,0];
var sx = 0; sy = 0;

//#pragma parvar q
//#pragma parvar sx
//#pragma parvar sy
//#pragma wait
//#pragma parallel
for (k = 1; k <= OPUS; k++) {
    var chunk_len = Math.floor(n / OPUS);
    var slice_start = (k-1) * chunk_len;
    var slice_end = slice_start + chunk_len - 1;
    if (slice_end >= n) slice_end = n - 1;

    var x1, x2, sxk = 0, syk = 0;
    var t1, t2, t3, t4;
    var l;
    var qk = [0,0,0,0,0,0,0,0,0,0];

    for (var i = slice_start; i < slice_end; i++) {
	x1 = 2 * Math.random() - 1;
	x2 = 2 * Math.random() - 1;
	t1 = x1 * x1 + x2 * x2;
	if (t1 <= 1.0) {
	    t2 = Math.sqrt(-2.0 * Math.log(t1) / t1);
	    t3 = x1 * t2;
	    t4 = x2 * t2;
	    l = Math.floor(Math.max(Math.abs(t3), Math.abs(t4)));
	    qk[l] = qk[l] + 1;
	    sxk += t3;
	    syk += t4;
	    }
	}

    for (i = 0; i < 10; i++) q[i] = q[i] + qk[i];
    sx = sx + sxk;
    sy = sy + syk;
    }

//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");

var timchk = 0;
var sxtchk = 0;
var syschk = 0;
var qchk = [];

if (n == 268435456) {
    timchk = 70.0;
    sxchk = -4.295875165629892e3;
    sychk = -1.580732573678431e4;
    qchk = [98257395, 93827014, 17611549, 1110028, 26536, 245, 0, 0, 0, 0];
    }
if (n == 1073741824) {
    timchk = 267.5;
    sxchk = 4.033815542441498e4;
    sychk = -2.660669192809235e4;
    qchk = [393058470, 375280898, 70460742, 4438852, 105691, 948, 5, 0, 0, 0];
    }


console.log("Problem size: n = " + n);
console.log("Total execution time:     " + elapse_time);
console.log("Reference execution time: " + timchk);

console.log("\n");
console.log("Computed sx:     " + sx);
console.log("Reference value: " + sxchk);
console.log("\n");
console.log("Computed sy:     " + sy);
console.log("Reference value: " + sychk);
console.log("\n");
console.log("Q values: ");
console.log(q);
console.log("Reference Q values: ");
console.log(qchk);



-------------------------------------

2020-06-24T18:49:36.500Z: user: vladas
// use --max-old-space-size=2048 with node binary
// Embarrassingly parallel NAS benchmark

//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;
console.log("Program started");

var OPUS = 6;

//var n = 268435456;  // 2^28  - Class A
var n = 1073741824; // 2^30  - Class B
var q = [0,0,0,0,0,0,0,0,0,0];
var sx = 0; sy = 0;

//#pragma parvar q
//#pragma parvar sx
//#pragma parvar sy
//#pragma wait
//#pragma parallel
for (k = 1; k <= OPUS; k++) {
    var chunk_len = Math.floor(n / OPUS);
    var slice_start = (k-1) * chunk_len;
    var slice_end = slice_start + chunk_len - 1;
    if (slice_end >= n) slice_end = n - 1;

    var x1, x2, sxk = 0, syk = 0;
    var t1, t2, t3, t4;
    var l;
    var qk = [0,0,0,0,0,0,0,0,0,0];

    for (var i = slice_start; i < slice_end; i++) {
	x1 = 2 * Math.random() - 1;
	x2 = 2 * Math.random() - 1;
	t1 = x1 * x1 + x2 * x2;
	if (t1 <= 1.0) {
	    t2 = Math.sqrt(-2.0 * Math.log(t1) / t1);
	    t3 = x1 * t2;
	    t4 = x2 * t2;
	    l = Math.floor(Math.max(Math.abs(t3), Math.abs(t4)));
	    qk[l] = qk[l] + 1;
	    sxk += t3;
	    syk += t4;
	    }
	}

    for (i = 0; i < 10; i++) q[i] = q[i] + qk[i];
    sx = sx + sxk;
    sy = sy + syk;
    }

//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");

var timchk = 0;
var sxtchk = 0;
var syschk = 0;
var qchk = [];

if (n == 268435456) {
    timchk = 70.0;
    sxchk = -4.295875165629892e3;
    sychk = -1.580732573678431e4;
    qchk = [98257395, 93827014, 17611549, 1110028, 26536, 245, 0, 0, 0, 0];
    }
if (n == 1073741824) {
    timchk = 267.5;
    sxchk = 4.033815542441498e4;
    sychk = -2.660669192809235e4;
    qchk = [393058470, 375280898, 70460742, 4438852, 105691, 948, 5, 0, 0, 0];
    }


console.log("Problem size: n = " + n);
console.log("Total execution time:     " + elapse_time);
console.log("Reference execution time: " + timchk);

console.log("\n");
console.log("Computed sx:     " + sx);
console.log("Reference value: " + sxchk);
console.log("\n");
console.log("Computed sy:     " + sy);
console.log("Reference value: " + sychk);
console.log("\n");
console.log("Q values: ");
console.log(q);
console.log("Reference Q values: ");
console.log(qchk);



-------------------------------------

2020-06-24T18:54:01.488Z: user: vladas
// use --max-old-space-size=2048 with node binary
// Embarrassingly parallel NAS benchmark

//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;

var OPUS = 4;

// var n = 268435456;  // 2^28  - Class A
var n = 1073741824; // 2^30  - Class B

var x1, x2, sx = 0, sy = 0;
var t1, t2, t3, t4;
var l;
var q = [0,0,0,0,0,0,0,0,0,0];

for (var i = 0; i < n; i++) {
    x1 = 2 * Math.random() - 1;
    x2 = 2 * Math.random() - 1;
    t1 = x1 * x1 + x2 * x2;
    if (t1 <= 1.0) {
	t2 = Math.sqrt(-2.0 * Math.log(t1) / t1);
	t3 = x1 * t2;
	t4 = x2 * t2;
	l = Math.floor(Math.max(Math.abs(t3), Math.abs(t4)));
	q[l] = q[l] + 1;
	sx += t3;
	sy += t4;
	}
    }


finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");


var timchk = 0;
var sxtchk = 0;
var syschk = 0;
var qchk = [];

if (n == 268435456) {
    timchk = 70.0;
    sxchk = -4.295875165629892e3;
    sychk = -1.580732573678431e4;
    qchk = [98257395, 93827014, 17611549, 1110028, 26536, 245, 0, 0, 0, 0];
    }
if (n == 1073741824) {
    timchk = 267.5;
    sxchk = 4.033815542441498e4;
    sychk = -2.660669192809235e4;
    qchk = [393058470, 375280898, 70460742, 4438852, 105691, 948, 5, 0, 0, 0];
    }


console.log("Problem size: n = " + n);
console.log("Total execution time:     " + elapse_time);
console.log("Reference execution time: " + timchk);

console.log("\n");
console.log("Computed sx:     " + sx);
console.log("Reference value: " + sxchk);
console.log("\n");
console.log("Computed sy:     " + sy);
console.log("Reference value: " + sychk);
console.log("\n");
console.log("Q values: ");
console.log(q);
console.log("Reference Q values: ");
console.log(qchk);



-------------------------------------

2020-06-24T19:01:40.377Z: user: vladas
// use --max-old-space-size=2048 with node binary
// Embarrassingly parallel NAS benchmark

//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;

var OPUS = 1;

var n = 268435456;  // 2^28  - Class A
//var n = 1073741824; // 2^30  - Class B

var x1, x2, sx = 0, sy = 0;
var t1, t2, t3, t4;
var l;
var q = [0,0,0,0,0,0,0,0,0,0];

for (var i = 0; i < n; i++) {
    x1 = 2 * Math.random() - 1;
    x2 = 2 * Math.random() - 1;
    t1 = x1 * x1 + x2 * x2;
    if (t1 <= 1.0) {
	t2 = Math.sqrt(-2.0 * Math.log(t1) / t1);
	t3 = x1 * t2;
	t4 = x2 * t2;
	l = Math.floor(Math.max(Math.abs(t3), Math.abs(t4)));
	q[l] = q[l] + 1;
	sx += t3;
	sy += t4;
	}
    }


finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");


var timchk = 0;
var sxtchk = 0;
var syschk = 0;
var qchk = [];

if (n == 268435456) {
    timchk = 70.0;
    sxchk = -4.295875165629892e3;
    sychk = -1.580732573678431e4;
    qchk = [98257395, 93827014, 17611549, 1110028, 26536, 245, 0, 0, 0, 0];
    }
if (n == 1073741824) {
    timchk = 267.5;
    sxchk = 4.033815542441498e4;
    sychk = -2.660669192809235e4;
    qchk = [393058470, 375280898, 70460742, 4438852, 105691, 948, 5, 0, 0, 0];
    }


console.log("Problem size: n = " + n);
console.log("Total execution time:     " + elapse_time);
console.log("Reference execution time: " + timchk);

console.log("\n");
console.log("Computed sx:     " + sx);
console.log("Reference value: " + sxchk);
console.log("\n");
console.log("Computed sy:     " + sy);
console.log("Reference value: " + sychk);
console.log("\n");
console.log("Q values: ");
console.log(q);
console.log("Reference Q values: ");
console.log(qchk);



-------------------------------------

2020-07-08T19:02:45.669Z: user: vladas
//#pragma sequential

dfltParams = {
    NORM : 1,
    IDEF : 1,
    MXMN : -1,
    DEL : 1.e-5,
    NIU : 0.1,
    EPS : 0.001,
    DZV : 0.2
    };

var NORM, // these must be explicitly defined to receive further values.
    IDEF,
    MXMN,
    DEL,
    NIU,
    EPS,
    DZV,
    NP1,
    MP1;

var rp = true;
params = {};
var dz = [0.,0.,0.];
var g = [], g_save = [];
var g5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]]; // prevent array from a jam by JSON.stringify
var h = [];
var hm = [];
var hm1 = [];
var sm = [], sn = [];
var sn5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var sp = [];
var x = [];
var x5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]]; 
var y = [];
var y5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var m = [];
var z = [];
var b = [];
var h1 = [];
var xg, fg;
var xg5 = [0,0,0,0,0,0,0,0,0];
var fg5 = [0,0,0,0,0,0,0,0,0];
var iter;
var kbh;
var pstr;
var effDEL;
var funcalls = 0, funcallsp;

var res = fs.readFileSync("linit.prm.json");
try {params = JSON.parse(res.toString(), null);}
catch(err){console.log(err.message);}

for (var p in dfltParams) {
    if (!params[p]) params[p] = dfltParams[p];
}

for (var p in params) {
    eval(p +'= params["'+p+'"]');  // I know it's ugly
}

var np1 = NP1;
var mp1 = MP1;
var np11 = np1+1, mp11 = mp1+1 ,i;
var kbh=0;

for (i=1; i<=mp1; i++) g[i]=0.;
g[1]=1.;

readex(true);

pstr = "NORM="+NORM+" IDEF="+IDEF+" MXMN="+MXMN+" DEL="+DEL+" NIU="+NIU+"\n EPS="+EPS+" DZV="+DZV+" MP1="+MP1+" NP1="+NP1;
console.log(pstr);
if (rp) fs.writeFileSync('linit.rpt.jsc', pstr+'\n');

var alfa, alf1;
var lamnor, niuf;
var xgnorm, xgnorm_min;
var xgnorm5 = [0,0,0,0,0,,0,0,0];
var  xg_min;
var ind=0, ind5=[0,0,0,0,0,0,0,0,0];
var i, j, k, k_max, k_min, n, ind_gt_3;
var i_n, i_n5 = [0,0,0,0,0,0,0,0,0];
var it_entr;
var DELsave, DELs;
var coef=[];

var start_time = new Date().getTime();
console.log(start_time);
if (rp) fs.appendFileSync('linit.rpt.jsc', start_time + "\n");
var finish_time;
var elapse_time;

var n=np1-1;
for (i=1;i<=n;i++) hm[1][i] = -1.*MXMN*hm[1][i];

if (NORM == 0) lamnor = Hnorm();
if (EPS == 0) Epsdef();

//#pragma wait
//#pragma cache hm
//#pragma cache sp
//#pragma cache sm
////#pragma cachefuncs
//#pragma sequential
//\\g = g;
//\\g_save = g_save;

iter = 1;
ind=0;
DELsave = DEL;
var EPS5=[EPS,EPS,EPS,EPS,EPS,EPS,EPS,EPS,EPS];
var xgnorm5 = [0,0,0,0,0,0,0,0,0];
var g5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var sn5 = [[0],[0],[0],[0],[0],[0],[0],[0],[0]];
var eps = [];
h = [[0],[0],[0]];

cpvec(g, g_save);

if (rp)
    fs.appendFileSync('linit.rpt.jsc', "\nIter(k)      F(g)     (X,g)    //X//g   Ind Nr.       Eps      Alfa  It_entry\n");
console.log("\nIter(k)      F(g)     (X,g)    //X//g   Ind Nr.       Eps      Alfa  It_entry\n");

//#pragma dive
//#pragma sequential
while (iter<=5000 && ind != 3) {

//\\    EPS5 = EPS5; // for lexical analyzer to find EPS5 variable
//\\    eps = eps;
    cpvec(EPS5, eps);

    DEL = DELsave;
    ind=2;

    if (iter == 1) k_max = 1;
    else k_max = 5;

//#pragma wait
//#pragma parallel
//#pragma noautoparvar
//#pragma parvar g5
//#pragma parvar sn5
//#pragma parvar x5
//#pragma parvar y5
//#pragma parvar xg5
//#pragma parvar fg5
//#pragma parvar ind5
//#pragma parvar i_n5
//#pragma parvar xgnorm5
//#pragma parvar EPS5
    for (k=1;k<=k_max;k++) {

        if (!k_min) k_min = 1;
        EPS = eps[k_min]; 

	    effDEL = DEL;
	    it_entr = 0;

//\\        iter = iter;
//\\	    sn = sn;
//\\	    sm = sm;
//\\	    sp = sp;
//\\	    g_save = g_save;
//\\	    DZV = DZV;
//\\	    coef = coef;
	    m = [];
	    x = [];
	    fg=0.;

	    cpvec(g_save, g);

	    while (ind == 2) {

   	        i_n = Minxg(k, sm, sp);

	        for (var ii=1;ii<=n;ii++) {
		        for (j=1;j<=mp1;j++) hm1[j] = hm[j][ii];
		        h[2][ii] = Skabg(x,hm1,1,mp1);
		        }

	        ind=1;
	        DELs = DEL;

	        while (ind == 1) {

                ind = Analys(Mnxgco(), DZV);
		        xgnorm = Skabg(x,x,2,mp1);
		
		        it_entr = it_entr + 1;
		        if (it_entr%500 == 0) {
		            DEL = DEL * 2.0;
		            if (DEL > 0.3) DEL = 0.3;
		            effDEL = DEL;
	    
//		            if (rp)
//			        fs.appendFileSync('linit.rpt.jsc',""+it_entr + "  " + DEL + "\n");
		            console.log(""+it_entr + "  " + DEL);
		            }
		        } // while (ind == 1)
	    
    		DEL=DELs;
	        }  // while (ind == 2)

	        __set_Par_Var_Value('xgnorm5['+k+']', xgnorm, __job, true);

	        if (ind == 3) {
    
		        __set_Par_Var_Value('ind5['+k+']', ind, __job, true);
		        __set_Par_Var_Value('sn5['+k+']', sn, __job, true);
		        }

	        for (i=1; i<=mp1; i++) hm1[i] = hm[i][np1];

	        dz[1] = Hb(hm1,g,mp1);
	        dz[2] = Skabg(hm1,y,1,mp1);
	        alfa = Mxmnxg();
	        if (alfa != 0.) {
		        alf1 = 1.-alfa*y[1];
		        for (i=1; i<=mp1 ; i++) g[i] = alf1*g[i] + alfa*y[i];

	            __set_Par_Var_Value('g5['+k+']', g, __job, true);

	            xg = Hb(x,g,mp1);
	            if (rp)
    		        fs.appendFileSync('linit.rpt.jsc',strf(iter,4)+"("+k+") "+strf(fg,10)+" "+strf(xg,10)+" "+strf(xgnorm,10)+" "+strf(i_n,10)+" "+strf(EPS,10)+" "+strf(alfa,10)+" "+strf(it_entr,6)+"\n");
    	        console.log(strf(iter,4)+"("+k+") "+strf(fg,10)+" "+strf(xg,10)+" "+strf(xgnorm,10)+" "+strf(i_n,10)+" "+strf(EPS,10)+" "+strf(alfa,10)+" "+strf(it_entr,6));

	            niuf = 2.* Math.abs(fg-xg)/ Math.abs(fg+xg);
	            if (niuf < NIU / 2. ) {
		        EPS = EPS*1.25;
		        }

	        __set_Par_Var_Value('EPS5['+k+']', EPS, __job, true);
	        }
	    else {
	        console.log("Problem has no solution");
	        exit(1);
	        }
	    ind = 2;
	    } // end for

//#pragma wait
//#pragma sequential
//\\    eps = eps;
    var xgnorm_min = xgnorm5[1];
    cpvec(EPS5, eps);

    k_min = 1;
    var ki=1;
    for (ki=1; ki<=k_max; ki++) {
	    if (xgnorm5[ki] < xgnorm_min) {
	        xgnorm_min = xgnorm5[ki];
	        k_min = ki;
	        }
	    if (ind5[ki] == 3) {ind=3; k_min=ki; break;}
	    }

	g_save = __get_Par_Var_Value('g5['+k_min+']', false, __job);
	var jitter = (iter % 2 == 0)? 0.99995 : 1.00005;
	for (var ii=1;ii<=np1;ii++) { g_save[ii] = g_save[ii] * jitter; }
    xgnorm = xgnorm5[k_min];
    EPS = EPS5[k_min];    

    fs.appendFileSync('linit.rpt.jsc',"\nk_min="+k_min+"\n");
    console.log("\nk_min="+k_min+"\n");

    if (ind != 3) ind = ind5[k_min];
	else sn = __get_Par_Var_Value('sn5['+k_min+']', false, __job);

    iter=iter+1;
    }

//#pragma sequential
//#wait
if (ind != 3 ) {
    if (rp) fs.appendFileSync('linit.rpt.jsc'," No solution after more than 200 iterations !\n");
    console.log (" No solution after more than 500 iterations !\n");
    }

for (var i=1; i<=np1; i++) hm[1][i] = -1*MXMN*hm[1][i];

finish_time = new Date().getTime();
console.log(finish_time);
if (rp) fs.appendFileSync('linit.rpt.jsc', finish_time + "\n");
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec");
if (rp) fs.appendFileSync('linit.rpt.jsc', "Elapse time: " + elapse_time + " sec\n");

for (i=1;i<=np1-1;i++) {
    if (rp) fs.appendFileSync('linit.rpt.jsc',sn[i]+ "  ");
    if (i%3 == 0) {
        if (rp) fs.appendFileSync('linit.rpt.jsc', "\n");
        }
   }
if (rp) {
    fs.appendFileSync('linit.rpt.jsc', "\nXG="+xg+"   "+"FG="+fg+"\n");
    console.log("\nXG="+xg+"   "+"FG="+fg+"\n");
   }
console.log(" End of solution \n");

// Functions

function max(a,b) {
    return a > b ? a : b; 
}

function min(a,b) {
    return a < b ? a : b; 
}

function readex(fromfile) {

    var i, j;
    var data = {};
    var mp1 = MP1, np1 = NP1;

    if (fromfile) {
	    var res = fs.readFileSync("linit.data.json");
	    data = JSON.parse(res, null);
	    hm = data.hm;
	    sm = data.sm;
	    sp = data.sp;
	    }
}

function cpvec(av, bv) {

    if (!av) return;
    for (var ii=0; ii<av.length; ii++ ) bv[ii] = av[ii];

}

function strf(num, len) {

    var bl = "";
    for (var i=1; i<=len; i++) bl+=" ";
    var ns = num.toString() + bl;
    return ns.substr(0,len);
}


function Minxg(k, sm, sp) {

    var hmg;
    var i, j, i_n;
    coef = [0, 1.18, -1.18, 1.18, -1.18, 1.18, -1.18, 1.18, -1.18, 1.18];

    for (i=1; i<=n ;i++) {
	    for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
	    h[1][i] = Hb(hm1,g,mp1);
	    hmg = Skabg(hm1,hm1,2,mp1);

	    if ( h[1][i] > coef[k]*EPS*hmg ) sn[i] = sm[i];
	    else sn[i] = sp[i];
        }

    for (i=1; i<=mp1; i++) {
	    x[i] = hm[i][np1];
	    for (j=1; j<=n; j++) x[i] = x[i] + hm[i][j]*sn[j];
	    }

    fg = Hb(x,g,mp1);

    i_n=0;

    for (i=1; i<=n; i++) {
	    for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
	    hmg = Skabg(hm1,hm1,2,mp1);
	    m[i]=0;
	    if (Math.abs(h[1][i]) <= (1.04+k*0.2)*EPS*hmg) { // was 0.8+k*0.2
    	    m[i] = 1;
    	    i_n++;
    	    }
	    }

    return(i_n);

}

function Analys(ind1, DZV) {

    var d=0., niuf=0., s=0., xgnorm=0.;
    var i, j, kt, ind = 0;

    xg = Hb(x,g,mp1);
    if (fg + xg != 0. ) {
	    niuf = 2.* Math.abs((fg-xg))/ Math.abs((fg+xg));
	    if (niuf > NIU ) {
    	    ind = 2;
    	    EPS = EPS*0.75;
    	    }
	    }

    if (ind != 2) {
	    kt = 0;
	    if (Math.abs((x[1]-xg)) > DEL ) kt = 1;
	    for (i=2; i<=mp1; i++) {
    	    if (Math.abs(x[i]) > DEL ) kt = 1;
    	    }
	    if ( kt == 0) ind = 3;
	    if ( ind != 3) {
    	    xgnorm = Skabg(x,x,2,mp1);
    	    y[1] = (x[1]-xg)/xgnorm;
    	    for (i=2; i<=mp1; i++) y[i] = x[i]/xgnorm;
    	    for (i=1; i<=n; i++) {
		        for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
		        h[2][i] = Skabg(hm1,y,1,mp1);
		        }
    	    d = 0.;
    	    for (i=1; i<=n; i++) {
		        if ( m[i] != 0 ) {
		            if (h[2][i] > 0.) s = sn[i] - sm[i];
		            else s = sn[i] - sp[i];
		            d = d + h[2][i]*s;
		            }
		        }
    	    d = d/xgnorm;
    	    if (d >= DZV) ind = 1;
    	    }
	    }

    if (ind1 == 0) return(0);
    return(ind);

}

function Mnxgco() {


    var dels = 0., del = 0., temp = 0.;
    var fdels = 0., fdels_old = 0., fdels_diff = 0.;

    var dz1, dz2, i, j;
    var iter_out = 0, iter_in = 0;

    do {
	    dz1 = 0;
	    dz2 = 0;

	    for (i=1; i<=n; i++) if (m[i]>0) m[i] = 2;

	    iter_in = 0;

	    do {

    	    if (dz1 == 0 && dz2 == 1 ) dz1 = 1;
    	    dz2 = 0;
    	    for (i=1; i<=n; i++) {
		        if ( m[i] == 2) {
		            for (j=1; j<=mp1; j++) hm1[j] = hm[j][i];
		            temp = Skabg(hm1,hm1,2,mp1);
		            del = Skabg(x,hm1,1,mp1)/(-temp*temp);
		            if (del < 0. ) dels=max(del,(sm[i]-sn[i]));
		            else dels=min(del,(sp[i]-sn[i]));
		            for (j=1; j<=mp1; j++) x[j] += dels*hm1[j];
		            sn[i] += dels;
		            if (sn[i]==sp[i] || sn[i]==sm[i]) {
			            m[i] = 1;
			            dz2 = 1;
			            }
		            }
		        }
    	    iter_in = iter_in + 1;
    	    fdels = Math.abs(dels);
    	    if (fdels < effDEL*effDEL) {
    		    return(1);
    		    }
    	    fdels_diff = (fdels_old == 0.) ? 1000. : Math.abs(fdels - fdels_old);
    	    fdels_old = fdels;
    	    } while (dz2 == 1);

	    iter_out=iter_out+1;
	    if (fdels_diff < effDEL*effDEL || iter_out%3000 == 0) {
	        effDEL = effDEL * 2.0;
	        }
	    } while(dz1==1 && dz2 == 0 && iter_out <= 7000);

    for (i=1; i<=n; i++)
        if (m[i] !=0 && sn[i]<sp[i] && sn[i] > sm[i]) m[i] = 2;

    return(1);
}


function Mxmnxg() {

    var bm = [0.,0.,1.], bp=[0.,1.,0.];
    var b = [0.,0.,1.]; 
    var z=[0.,0.,0.]; 
    h1=[0.,0.,0.];
    var i, j, itr = 0;

    Zdef(b, z);

    if (z[2] > 0.) {
	    return 0.;
	    }

    while(itr<=20) {

	    b[1] = (bp[1]+bm[1])/2.;
	    b[2] = (bp[2]+bm[2])/2.;
	    itr = itr + 1;
	    Zdef(b, z);

	    if (z[2] <= 0.) {
    	    bm[1] = b[1];
    	    bm[2] = b[2];
    	    }
	    else {
    	    bp[1] = b[1];
    	    bp[2] = b[2];
    	    }
	    }

    return(b[2]/b[1]);

}

function Zdef(b, z) {

    var sn1 = 0.;
    var i, j;

    for (i=1; i<=2; i++) {
	    z[i]=dz[i];
	    for (j=1; j<=n; j++) {
    	    h1[1]=h[1][j];
    	    h1[2]=h[2][j];
    	    if ( Hb(h1,b,2) > 0. ) sn1 = sm[j];
    	    else sn1 = sp[j];
    	    z[i] = z[i] + sn1*h[i][j];
    	    }
	    }

}

function Hnorm() {

    var lam = 0., xnor = 0.;
    var i, j;

    for (i=1; i<=n; i++) hm1[i] = hm[1][i];
    lam = Hb(hm1,hm1,n);
    lam = Math.sqrt(lam);
    for (i=1; i<=n; i++) hm[1][i]= hm[1][i]/lam;

    for (j=2; j<=mp1; j++) {
	    for (i=1; i<=n; i++) hm1[i] = hm[j][i];
	    xnor = Hb(hm1,hm1,n);
	    xnor = Math.sqrt(xnor);
	    for (i=1; i<=n; i++) hm[j][i]= hm[j][i]/xnor;
	    }

    return (lam);
}


function Epsdef () {

    var deps = [];
    var hmg = 0., ruf = 0.;
    var i, j, ip1;

    for (i=1;i<=n;i++) {
	    for (j=1;j<=mp1;j++) hm1[j] = hm[j][i];
	    hmg = Skabg(hm1,hm1,2,mp1);
	    deps[i] = Math.abs(h[1][i])/hmg;
	    }

    for (i=1;i<=n;i++) {
	    ip1=i+1;
	    for(j=ip1;j<=n;j++) {
    	    if (deps[i]<deps[j]) {
		        ruf = deps[j];
		        deps[j] = deps[i];
		        deps[i] = ruf;
		        }
    	    }
	    }

    EPS = (deps[IDEF] + deps[IDEF+1]) / 2.;

}

function Hb(hh, bb, nn) {

    var hb = 0.;
    var i;

    for (i=1; i<=nn; i++) hb += hh[i]*bb[i];

    return(hb);

}

function Skabg(a, b, i_nn, nn) {

    var ag = 0., skbg = 0.;
    var i;

    for (i=1; i<=nn; i++) ag = ag + a[i]*g[i];

    if (i_nn==1) {
	    skbg = (a[1]-ag)*b[1];
	    for (i=2;i<=nn;i++) {
    	    skbg = skbg + a[i]*b[i];
    	    }
	    return(skbg);
	    }
    else {
	    skbg = (a[1]-ag)*(a[1]-ag);
	    for (i=2;i<=nn;i++) {
    	    skbg = skbg + a[i]*a[i];
    	    }
	    }

    return(Math.sqrt(skbg));

}

-------------------------------------

2020-07-09T13:47:39.043Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};




/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

  var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 100000; i++) {
    for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
    }

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }

  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
  }

  for (var blockLength = 2; blockLength <= N; blockLength *= 2) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = new ComplexNumber({
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
    });

    for (var blockStart = 0; blockStart < N; blockStart += blockLength) {
      var phase = new ComplexNumber({ re: 1, im: 0 });

      for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
        var component = output[signalId + blockLength / 2].multiply(phase);

        var upd1 = output[signalId].add(component);
        var upd2 = output[signalId].subtract(component);

        output[signalId] = upd1;
        output[signalId + blockLength / 2] = upd2;

        phase = phase.multiply(phaseStep);
      }
    }
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-01T09:19:52.791Z: user: anonymous
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= 8; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('z', z, __job, true);

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

        apos = 0;
	    var smatvec_time = new Date().getTime();
	    // q = A*p
	    //#pragma parallel
	    //#pragma noautoparvar
	    //#pragma parvar p
	    //#pragma parvar q
	    //#pragma wait
	    for (opu = 1; opu <= OPUS; opu++) {
            var chunk_len = Math.floor(n / OPUS);
            var slice_start = (opu-1) * chunk_len;
            var slice_end = slice_start + chunk_len - 1;
            if (slice_end >= n) slice_end = n - 1;
	        var q = [];
            var p = __get_Par_Var_Value('p', false, __job);
            var k = 0;
	        apos = 0;
	        for (i = 0; i <= slice_end; i++) {
	            if (i >= slice_start) {
	                q[k] = 0;
	                for (j = apos; j <= apos + arow[i] - 1; j++) {
		                q[k] += a[j] * p[aidx[j]];
		                }
		            k++;
	                }
	            apos += arow[i];
	            }
            __set_Par_Var_Value('q', q, __job, true, slice_start);
	        }
        //#pragma sequential
        //#pragma parvar p
        //#pragma parvar q
        //#pragma parvar r
        //#pragma parvar z
        //#pragma parvar x
        //#pragma noautoparvar
        //#pragma wait
	    var fmatvec_time = new Date().getTime();
	    var matvec_time = (fmatvec_time - smatvec_time) / 1000;
        p = __get_Par_Var_Value('p', false, __job);
        q = __get_Par_Var_Value('q', false, __job);
        r = __get_Par_Var_Value('r', false, __job);
        z = __get_Par_Var_Value('z', false, __job);
	    alpha = rho / dotp(p, q);
	    for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	    rho0 = rho;
	    for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	    rho = dotp(r, r);
	    beta = rho / rho0;
	    for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
        __set_Par_Var_Value('z', z, __job, true);
        __set_Par_Var_Value('r', r, __job, true);
        __set_Par_Var_Value('p', p, __job, true);

	    itcg++;
    	}
    iter=iter;
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 4000) {
    timchk = 4.00;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-08-01T09:21:40.540Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 11;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= 8; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('z', z, __job, true);

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

        apos = 0;
	    var smatvec_time = new Date().getTime();
	    // q = A*p
	    //#pragma parallel
	    //#pragma noautoparvar
	    //#pragma parvar p
	    //#pragma parvar q
	    //#pragma wait
	    for (opu = 1; opu <= OPUS; opu++) {
            var chunk_len = Math.floor(n / OPUS);
            var slice_start = (opu-1) * chunk_len;
            var slice_end = slice_start + chunk_len - 1;
            if (slice_end >= n) slice_end = n - 1;
	        var q = [];
            var p = __get_Par_Var_Value('p', false, __job);
            var k = 0;
	        apos = 0;
	        for (i = 0; i <= slice_end; i++) {
	            if (i >= slice_start) {
	                q[k] = 0;
	                for (j = apos; j <= apos + arow[i] - 1; j++) {
		                q[k] += a[j] * p[aidx[j]];
		                }
		            k++;
	                }
	            apos += arow[i];
	            }
            __set_Par_Var_Value('q', q, __job, true, slice_start);
	        }
        //#pragma sequential
        //#pragma parvar p
        //#pragma parvar q
        //#pragma parvar r
        //#pragma parvar z
        //#pragma parvar x
        //#pragma noautoparvar
        //#pragma wait
	    var fmatvec_time = new Date().getTime();
	    var matvec_time = (fmatvec_time - smatvec_time) / 1000;
        p = __get_Par_Var_Value('p', false, __job);
        q = __get_Par_Var_Value('q', false, __job);
        r = __get_Par_Var_Value('r', false, __job);
        z = __get_Par_Var_Value('z', false, __job);
	    alpha = rho / dotp(p, q);
	    for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	    rho0 = rho;
	    for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	    rho = dotp(r, r);
	    beta = rho / rho0;
	    for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
        __set_Par_Var_Value('z', z, __job, true);
        __set_Par_Var_Value('r', r, __job, true);
        __set_Par_Var_Value('p', p, __job, true);

	    itcg++;
    	}
    iter=iter;
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 4000) {
    timchk = 4.00;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-08-01T09:29:03.702Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= 8; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('z', z, __job, true);

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

        apos = 0;
	    var smatvec_time = new Date().getTime();
	    // q = A*p
	    //#pragma parallel
	    //#pragma noautoparvar
	    //#pragma parvar p
	    //#pragma parvar q
	    //#pragma wait
	    for (opu = 1; opu <= OPUS; opu++) {
            var chunk_len = Math.floor(n / OPUS);
            var slice_start = (opu-1) * chunk_len;
            var slice_end = slice_start + chunk_len - 1;
            if (slice_end >= n) slice_end = n - 1;
	        var q = [];
            var p = __get_Par_Var_Value('p', false, __job);
            var k = 0;
	        apos = 0;
	        for (i = 0; i <= slice_end; i++) {
	            if (i >= slice_start) {
	                q[k] = 0;
	                for (j = apos; j <= apos + arow[i] - 1; j++) {
		                q[k] += a[j] * p[aidx[j]];
		                }
		            k++;
	                }
	            apos += arow[i];
	            }
            __set_Par_Var_Value('q', q, __job, true, slice_start);
	        }
        //#pragma sequential
        //#pragma parvar p
        //#pragma parvar q
        //#pragma parvar r
        //#pragma parvar z
        //#pragma parvar x
        //#pragma noautoparvar
        //#pragma wait
	    var fmatvec_time = new Date().getTime();
	    var matvec_time = (fmatvec_time - smatvec_time) / 1000;
        p = __get_Par_Var_Value('p', false, __job);
        q = __get_Par_Var_Value('q', false, __job);
        r = __get_Par_Var_Value('r', false, __job);
        z = __get_Par_Var_Value('z', false, __job);
	    alpha = rho / dotp(p, q);
	    for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	    rho0 = rho;
	    for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	    rho = dotp(r, r);
	    beta = rho / rho0;
	    for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
        __set_Par_Var_Value('z', z, __job, true);
        __set_Par_Var_Value('r', r, __job, true);
        __set_Par_Var_Value('p', p, __job, true);

	    itcg++;
    	}
    iter=iter;
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 4000) {
    timchk = 4.00;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-08-01T09:33:36.304Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= 8; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('z', z, __job, true);

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

        apos = 0;
	    var smatvec_time = new Date().getTime();
	    // q = A*p
	    //#pragma parallel
	    //#pragma noautoparvar
	    //#pragma parvar p
	    //#pragma parvar q
	    //#pragma wait
	    for (opu = 1; opu <= OPUS; opu++) {
            var chunk_len = Math.floor(n / OPUS);
            var slice_start = (opu-1) * chunk_len;
            var slice_end = slice_start + chunk_len - 1;
            if (slice_end >= n) slice_end = n - 1;
	        var q = [];
            var p = __get_Par_Var_Value('p', false, __job);
            var k = 0;
	        apos = 0;
	        for (i = 0; i <= slice_end; i++) {
	            if (i >= slice_start) {
	                q[k] = 0;
	                for (j = apos; j <= apos + arow[i] - 1; j++) {
		                q[k] += a[j] * p[aidx[j]];
		                }
		            k++;
	                }
	            apos += arow[i];
	            }
            __set_Par_Var_Value('q', q, __job, true, slice_start);
	        }
        //#pragma sequential
        //#pragma parvar p
        //#pragma parvar q
        //#pragma parvar r
        //#pragma parvar z
        //#pragma parvar x
        //#pragma noautoparvar
        //#pragma wait
	    var fmatvec_time = new Date().getTime();
	    var matvec_time = (fmatvec_time - smatvec_time) / 1000;
        p = __get_Par_Var_Value('p', false, __job);
        q = __get_Par_Var_Value('q', false, __job);
        r = __get_Par_Var_Value('r', false, __job);
        z = __get_Par_Var_Value('z', false, __job);
	    alpha = rho / dotp(p, q);
	    for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	    rho0 = rho;
	    for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	    rho = dotp(r, r);
	    beta = rho / rho0;
	    for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
        __set_Par_Var_Value('z', z, __job, true);
        __set_Par_Var_Value('r', r, __job, true);
        __set_Par_Var_Value('p', p, __job, true);

	    itcg++;
    	}
    iter=iter;
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 4000) {
    timchk = 4.00;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-08-01T09:34:46.386Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= 8; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('z', z, __job, true);

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

        apos = 0;
	    var smatvec_time = new Date().getTime();
	    // q = A*p
	    //#pragma parallel
	    //#pragma noautoparvar
	    //#pragma parvar p
	    //#pragma parvar q
	    //#pragma wait
	    for (opu = 1; opu <= OPUS; opu++) {
            var chunk_len = Math.floor(n / OPUS);
            var slice_start = (opu-1) * chunk_len;
            var slice_end = slice_start + chunk_len - 1;
            if (slice_end >= n) slice_end = n - 1;
	        var q = [];
            var p = __get_Par_Var_Value('p', false, __job);
            var k = 0;
	        apos = 0;
	        for (i = 0; i <= slice_end; i++) {
	            if (i >= slice_start) {
	                q[k] = 0;
	                for (j = apos; j <= apos + arow[i] - 1; j++) {
		                q[k] += a[j] * p[aidx[j]];
		                }
		            k++;
	                }
	            apos += arow[i];
	            }
            __set_Par_Var_Value('q', q, __job, true, slice_start);
	        }
        //#pragma sequential
        //#pragma parvar p
        //#pragma parvar q
        //#pragma parvar r
        //#pragma parvar z
        //#pragma parvar x
        //#pragma noautoparvar
        //#pragma wait
	    var fmatvec_time = new Date().getTime();
	    var matvec_time = (fmatvec_time - smatvec_time) / 1000;
        p = __get_Par_Var_Value('p', false, __job);
        q = __get_Par_Var_Value('q', false, __job);
        r = __get_Par_Var_Value('r', false, __job);
        z = __get_Par_Var_Value('z', false, __job);
	    alpha = rho / dotp(p, q);
	    for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	    rho0 = rho;
	    for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	    rho = dotp(r, r);
	    beta = rho / rho0;
	    for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
        __set_Par_Var_Value('z', z, __job, true);
        __set_Par_Var_Value('r', r, __job, true);
        __set_Par_Var_Value('p', p, __job, true);

	    itcg++;
    	}
    iter=iter;
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 4000) {
    timchk = 4.00;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-08-01T09:38:49.929Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= 8; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('z', z, __job, true);

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

        apos = 0;
	    var smatvec_time = new Date().getTime();
	    // q = A*p
	    //#pragma parallel
	    //#pragma noautoparvar
	    //#pragma parvar p
	    //#pragma parvar q
	    //#pragma wait
	    for (opu = 1; opu <= OPUS; opu++) {
            var chunk_len = Math.floor(n / OPUS);
            var slice_start = (opu-1) * chunk_len;
            var slice_end = slice_start + chunk_len - 1;
            if (slice_end >= n) slice_end = n - 1;
	        var q = [];
            var p = __get_Par_Var_Value('p', false, __job);
            var k = 0;
	        apos = 0;
	        for (i = 0; i <= slice_end; i++) {
	            if (i >= slice_start) {
	                q[k] = 0;
	                for (j = apos; j <= apos + arow[i] - 1; j++) {
		                q[k] += a[j] * p[aidx[j]];
		                }
		            k++;
	                }
	            apos += arow[i];
	            }
            __set_Par_Var_Value('q', q, __job, true, slice_start);
	        }
        //#pragma sequential
        //#pragma parvar p
        //#pragma parvar q
        //#pragma parvar r
        //#pragma parvar z
        //#pragma parvar x
        //#pragma noautoparvar
        //#pragma wait
	    var fmatvec_time = new Date().getTime();
	    var matvec_time = (fmatvec_time - smatvec_time) / 1000;
        p = __get_Par_Var_Value('p', false, __job);
        q = __get_Par_Var_Value('q', false, __job);
        r = __get_Par_Var_Value('r', false, __job);
        z = __get_Par_Var_Value('z', false, __job);
	    alpha = rho / dotp(p, q);
	    for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	    rho0 = rho;
	    for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	    rho = dotp(r, r);
	    beta = rho / rho0;
	    for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
        __set_Par_Var_Value('z', z, __job, true);
        __set_Par_Var_Value('r', r, __job, true);
        __set_Par_Var_Value('p', p, __job, true);

	    itcg++;
    	}
    iter=iter;
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 4000) {
    timchk = 4.00;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-08-01T09:40:09.459Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 14000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= 8; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('z', z, __job, true);

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

        apos = 0;
	    var smatvec_time = new Date().getTime();
	    // q = A*p
	    //#pragma parallel
	    //#pragma noautoparvar
	    //#pragma parvar p
	    //#pragma parvar q
	    //#pragma wait
	    for (opu = 1; opu <= OPUS; opu++) {
            var chunk_len = Math.floor(n / OPUS);
            var slice_start = (opu-1) * chunk_len;
            var slice_end = slice_start + chunk_len - 1;
            if (slice_end >= n) slice_end = n - 1;
	        var q = [];
            var p = __get_Par_Var_Value('p', false, __job);
            var k = 0;
	        apos = 0;
	        for (i = 0; i <= slice_end; i++) {
	            if (i >= slice_start) {
	                q[k] = 0;
	                for (j = apos; j <= apos + arow[i] - 1; j++) {
		                q[k] += a[j] * p[aidx[j]];
		                }
		            k++;
	                }
	            apos += arow[i];
	            }
            __set_Par_Var_Value('q', q, __job, true, slice_start);
	        }
        //#pragma sequential
        //#pragma parvar p
        //#pragma parvar q
        //#pragma parvar r
        //#pragma parvar z
        //#pragma parvar x
        //#pragma noautoparvar
        //#pragma wait
	    var fmatvec_time = new Date().getTime();
	    var matvec_time = (fmatvec_time - smatvec_time) / 1000;
        p = __get_Par_Var_Value('p', false, __job);
        q = __get_Par_Var_Value('q', false, __job);
        r = __get_Par_Var_Value('r', false, __job);
        z = __get_Par_Var_Value('z', false, __job);
	    alpha = rho / dotp(p, q);
	    for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	    rho0 = rho;
	    for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	    rho = dotp(r, r);
	    beta = rho / rho0;
	    for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
        __set_Par_Var_Value('z', z, __job, true);
        __set_Par_Var_Value('r', r, __job, true);
        __set_Par_Var_Value('p', p, __job, true);

	    itcg++;
    	}
    iter=iter;
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 4000) {
    timchk = 4.00;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-08-01T09:41:50.994Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= 8; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('z', z, __job, true);

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

        apos = 0;
	    var smatvec_time = new Date().getTime();
	    // q = A*p
	    //#pragma parallel
	    //#pragma noautoparvar
	    //#pragma parvar p
	    //#pragma parvar q
	    //#pragma wait
	    for (opu = 1; opu <= OPUS; opu++) {
            var chunk_len = Math.floor(n / OPUS);
            var slice_start = (opu-1) * chunk_len;
            var slice_end = slice_start + chunk_len - 1;
            if (slice_end >= n) slice_end = n - 1;
	        var q = [];
            var p = __get_Par_Var_Value('p', false, __job);
            var k = 0;
	        apos = 0;
	        for (i = 0; i <= slice_end; i++) {
	            if (i >= slice_start) {
	                q[k] = 0;
	                for (j = apos; j <= apos + arow[i] - 1; j++) {
		                q[k] += a[j] * p[aidx[j]];
		                }
		            k++;
	                }
	            apos += arow[i];
	            }
            __set_Par_Var_Value('q', q, __job, true, slice_start);
	        }
        //#pragma sequential
        //#pragma parvar p
        //#pragma parvar q
        //#pragma parvar r
        //#pragma parvar z
        //#pragma parvar x
        //#pragma noautoparvar
        //#pragma wait
	    var fmatvec_time = new Date().getTime();
	    var matvec_time = (fmatvec_time - smatvec_time) / 1000;
        p = __get_Par_Var_Value('p', false, __job);
        q = __get_Par_Var_Value('q', false, __job);
        r = __get_Par_Var_Value('r', false, __job);
        z = __get_Par_Var_Value('z', false, __job);
	    alpha = rho / dotp(p, q);
	    for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	    rho0 = rho;
	    for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	    rho = dotp(r, r);
	    beta = rho / rho0;
	    for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
        __set_Par_Var_Value('z', z, __job, true);
        __set_Par_Var_Value('r', r, __job, true);
        __set_Par_Var_Value('p', p, __job, true);

	    itcg++;
    	}
    iter=iter;
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 4000) {
    timchk = 4.00;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-08-01T09:50:12.870Z: user: vladas
// use --max-old-space-size=2048 with node binary
// NAS tri-vector sparce matrix format

////#pragma parvar a    // to avoid transferring 'a' to the server
////#pragma parvar aidx  //  --//--
////#pragma parvar arow  //  --//--
//#pragma sequential
var start_time = new Date().getTime();
var finish_time;
var elapse_time;


var OPUS = 4;

var a = [];
var aidx = [];
var arow = [];
var apos;

var n = 4000;
var non_zeros = 7;
var niter = 15;
var nitcg = 25;
var rcond = 0.1;
var nzc;

var x = [];
var zeta = 0.;
var zeta1 = 0.
var zeta2 = 0.
var zetapr = 0.
var resid = 0.
var maxval = 0.

var z = [];
var r = [];
var p = [];
var q = [];
var rho = 0.;
var rho0 = 0.;
var alpha = 0.;
var beta = 0.;

var iter;
var itcg;

var aij;
var i;

makea();
//#pragma wait
// Heat up OPU caches
//#pragma cache a
//#pragma cache aidx
//#pragma cache arow
//#pragma noautoparvar
//#pragma parallel
for (i = 1; i <= 8; i++) {
    a = a;
    aidx = aidx;
    arow = arow;
    console.log("Cashed OPU #"+i);
    }
//#pragma wait
//#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
var x =[];
for (i = 0; i < n; i++) x[i] = 1.;
//main loop
iter = 1;
//#pragma dive
//#pragma wait
//#pragma parvar x
//#pragma parvar r
//#pragma parvar z
while (iter <= niter) {
    var x = [];
    var p =[];
    x = __get_Par_Var_Value('x', false, __job);
    var z = [];
    var r = [];
    for (i = 0; i < n; i++) z[i] = 0.;
    rho = dotp(x, x);
    for (i = 0; i < n; i++) r[i] = x[i];
    for (i = 0; i < n; i++) p[i] = x[i];
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('z', z, __job, true);

    itcg = 1;
    //#pragma dive
    //#pragma wait
    while (itcg <= nitcg) {

        apos = 0;
	    var smatvec_time = new Date().getTime();
	    // q = A*p
	    //#pragma parallel
	    //#pragma noautoparvar
	    //#pragma parvar p
	    //#pragma parvar q
	    //#pragma wait
	    for (opu = 1; opu <= OPUS; opu++) {
            var chunk_len = Math.floor(n / OPUS);
            var slice_start = (opu-1) * chunk_len;
            var slice_end = slice_start + chunk_len - 1;
            if (slice_end >= n) slice_end = n - 1;
	        var q = [];
            var p = __get_Par_Var_Value('p', false, __job);
            var k = 0;
	        apos = 0;
	        for (i = 0; i <= slice_end; i++) {
	            if (i >= slice_start) {
	                q[k] = 0;
	                for (j = apos; j <= apos + arow[i] - 1; j++) {
		                q[k] += a[j] * p[aidx[j]];
		                }
		            k++;
	                }
	            apos += arow[i];
	            }
            __set_Par_Var_Value('q', q, __job, true, slice_start);
	        }
        //#pragma sequential
        //#pragma parvar p
        //#pragma parvar q
        //#pragma parvar r
        //#pragma parvar z
        //#pragma parvar x
        //#pragma noautoparvar
        //#pragma wait
	    var fmatvec_time = new Date().getTime();
	    var matvec_time = (fmatvec_time - smatvec_time) / 1000;
        p = __get_Par_Var_Value('p', false, __job);
        q = __get_Par_Var_Value('q', false, __job);
        r = __get_Par_Var_Value('r', false, __job);
        z = __get_Par_Var_Value('z', false, __job);
	    alpha = rho / dotp(p, q);
	    for (i = 0; i < n; i++) z[i] = z[i] + alpha * p[i];
	    rho0 = rho;
	    for (i = 0; i < n; i++) r[i] = r[i] - alpha * q[i];
	    rho = dotp(r, r);
	    beta = rho / rho0;
	    for (i = 0; i < n; i++) p[i] = r[i] + beta * p[i];
        __set_Par_Var_Value('z', z, __job, true);
        __set_Par_Var_Value('r', r, __job, true);
        __set_Par_Var_Value('p', p, __job, true);

	    itcg++;
    	}
    iter=iter;
    // r = A*z
	//#pragma parallel
	//#pragma noautoparvar
	//#pragma parvar r
	//#pragma parvar z
	//#pragma wait
	for (opu = 1; opu <= OPUS; opu++) {
	    var r = [];
        var z = __get_Par_Var_Value('z', false, __job);
        apos = 0;
        for (i = 0; i < n; i++) {
	        r[i] = 0;
	        for (var j = apos; j <= apos + arow[i] - 1; j++) {
	            r[i] = r[i] + a[j] * z[aidx[j]];
	            }
	        apos += arow[i];
	    }
        __set_Par_Var_Value('r', r, __job, true);
	}
    //#pragma wait
    //#pragma sequential
    //#pragma parvar x
    //#pragma parvar r
    //#pragma parvar z
    r = __get_Par_Var_Value('r', false, __job);
    z = __get_Par_Var_Value('z', false, __job);
    x = __get_Par_Var_Value('x', false, __job);

    for (i = 0; i < n; i++) r[i] = x[i] - r[i];
    resid = Math.sqrt(dotp(r, r));
    zeta1 = zeta;
    zeta2 = zeta1;
    maxval = 0.;
    for (i = 0; i < n; i++) {
	var az = Math.abs(z[i]);
	if (az > maxval) maxval = az;
	}
    zeta = 1. / maxval;
    zetapr = zeta - (zeta-zeta1)*(zeta-zeta1)/(zeta-2.0*zeta1+zeta2);
    for (i = 0; i < n; i++) x[i] = z[i] * zeta;
    __set_Par_Var_Value('r', r, __job, true);
    __set_Par_Var_Value('x', x, __job, true);

    iter++;
    console.log("iter="+iter);
    }

////#pragma wait
////#pragma sequential
finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Elapse time: " + elapse_time + " sec\n");
console.log("MATVEC time: " + matvec_time + " sec\n");

var matops = 2*nzc;
var opscg = 5*n + matops + nitcg*(matops + 10*n + 2);
var ops = niter * (opscg + n + 1);
var flops = 1.0e-6 * ops / elapse_time;

var timchk = 0;
var zetchk = 0;
var reschk = 0;

if (n == 1400) {
    timchk = 1.0538;
    zetchk = 0.10188582986104;
    reschk = 0.6241e-5;
    }
if (n == 4000) {
    timchk = 4.00;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }
if (n == 14000) {
    timchk = 21.77;
    zetchk = 0.101249586035172;
    reschk = 3.5094e-4;
    }

console.log("Total number of operations: " + ops);
console.log("Total execution time: " + elapse_time);
console.log("Performance in mflops: " + flops);
console.log("Ratio: this machine/ymp(1cpu): " + timchk/elapse_time);
console.log("\n");
console.log("Computed zeta:   " + zetapr);
console.log("Reference value: " + zetchk);
console.log("\n");
console.log("Computed residual: " + resid);
console.log("Reference value:   " + reschk);


function makea() {

    var r = [];  // sparce array for non-zero random columns
    var sa = []; // native sparce version of matrix a
    var size;
    
    for (i = 0; i < n; i++) {
	sa[i] = [];
	}
	
    for (i = 0; i < n; i++) {
	r = [];
	for (j = 1; j <= non_zeros; j++) {
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	while(r.reduce(function(t){++t}) < non_zeros) {  // while there was dublicates
	    r[Math.floor(Math.random()*n)] = Math.random();
	    }
	r[i] = 0.5;
	
	size = Math.pow(rcond, i/n);
	
	for (j in r) {
	    for (k in r) {
		if (!sa[j][k]) sa[j][k] = 0.
		sa[j][k] += r[j]*r[k]*size;
		}
	    }
	}

    for (i = 0; i < n; i++) {
	if (!sa[i][i]) sa[i][i] = 0.
        sa[i][i] += rcond;
        }

finish_time = new Date().getTime();
elapse_time = (finish_time - start_time) / 1000;
console.log("Base matrix creation time: " + elapse_time + " sec");
start_time = finish_time;
//    console.log(sa);

    // make compressed sparse matrix 'a' like in nesl example's SPARSE function
    nzc = 0;
    var k;
    for (i = 0; i < n; i++) {
	k = 0;
	for (j in sa[i]) {
	    a.push(Math.round(sa[i][j]*1000)/1000);
	    aidx.push(j*1);
	    k++;
	    }
	sa[i].length = 0;
	arow.push(k);
	nzc += k;
	}

    console.log("Final nonzero count: " + nzc);
//    console.log(a);

}

function dotp(v1, v2) {

    var res = 0.;

    for (var ii = 0; ii < n; ii++) res += v1[ii] * v2[ii];

    return res;
}

-------------------------------------

2020-08-01T10:36:33.016Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential




/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */


get_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 100000; i++) {
//    for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//    }

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }

  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
  }

  for (var blockLength = 2; blockLength <= N; blockLength *= 2) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = new ComplexNumber({
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
    });

    for (var blockStart = 0; blockStart < N; blockStart += blockLength) {
      var phase = new ComplexNumber({ re: 1, im: 0 });

      for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
        var component = output[signalId + blockLength / 2].multiply(phase);

        var upd1 = output[signalId].add(component);
        var upd2 = output[signalId].subtract(component);

        output[signalId] = upd1;
        output[signalId + blockLength / 2] = upd2;

        phase = phase.multiply(phaseStep);
      }
    }
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function get_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-01T10:37:22.232Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential




/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */


get_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 100000; i++) {
    for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
    }

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }

  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
  }

  for (var blockLength = 2; blockLength <= N; blockLength *= 2) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = new ComplexNumber({
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
    });

    for (var blockStart = 0; blockStart < N; blockStart += blockLength) {
      var phase = new ComplexNumber({ re: 1, im: 0 });

      for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
        var component = output[signalId + blockLength / 2].multiply(phase);

        var upd1 = output[signalId].add(component);
        var upd2 = output[signalId].subtract(component);

        output[signalId] = upd1;
        output[signalId + blockLength / 2] = upd2;

        phase = phase.multiply(phaseStep);
      }
    }
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function get_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-01T10:39:55.905Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential




/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */


get_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 50000; i++) {
    for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
    }

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }

  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
  }

  for (var blockLength = 2; blockLength <= N; blockLength *= 2) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = new ComplexNumber({
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
    });

    for (var blockStart = 0; blockStart < N; blockStart += blockLength) {
      var phase = new ComplexNumber({ re: 1, im: 0 });

      for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
        var component = output[signalId + blockLength / 2].multiply(phase);

        var upd1 = output[signalId].add(component);
        var upd2 = output[signalId].subtract(component);

        output[signalId] = upd1;
        output[signalId + blockLength / 2] = upd2;

        phase = phase.multiply(phaseStep);
      }
    }
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function get_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-01T10:39:56.078Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential




/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */


get_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 50000; i++) {
    for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
    }

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }

  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
  }

  for (var blockLength = 2; blockLength <= N; blockLength *= 2) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = new ComplexNumber({
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
    });

    for (var blockStart = 0; blockStart < N; blockStart += blockLength) {
      var phase = new ComplexNumber({ re: 1, im: 0 });

      for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
        var component = output[signalId + blockLength / 2].multiply(phase);

        var upd1 = output[signalId].add(component);
        var upd2 = output[signalId].subtract(component);

        output[signalId] = upd1;
        output[signalId + blockLength / 2] = upd2;

        phase = phase.multiply(phaseStep);
      }
    }
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function get_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-01T11:29:48.355Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */


get_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 50000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }

  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
  }

  for (var blockLength = 2; blockLength <= N; blockLength *= 2) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = new ComplexNumber({
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
    });

    for (var blockStart = 0; blockStart < N; blockStart += blockLength) {
      var phase = new ComplexNumber({ re: 1, im: 0 });

      for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
        var component = output[signalId + blockLength / 2].multiply(phase);

        var upd1 = output[signalId].add(component);
        var upd2 = output[signalId].subtract(component);

        output[signalId] = upd1;
        output[signalId + blockLength / 2] = upd2;

        phase = phase.multiply(phaseStep);
      }
    }
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function get_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-01T11:35:56.261Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */


get_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 50000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }

  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
  }

  for (var blockLength = 2; blockLength <= N; blockLength *= 2) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = new ComplexNumber({
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
    });

    for (var blockStart = 0; blockStart < N; blockStart += blockLength) {
      var phase = new ComplexNumber({ re: 1, im: 0 });

      for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
        var component = output[signalId + blockLength / 2].multiply(phase);

        var upd1 = output[signalId].add(component);
        var upd2 = output[signalId].subtract(component);

        output[signalId] = upd1;
        output[signalId + blockLength / 2] = upd2;

        phase = phase.multiply(phaseStep);
      }
    }
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function get_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:20:57.894Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  //#pragma wait
  //#pragma parallel
  //#pragma cache inputData
  //#pragma noautoparvar
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  
  //#pragma wait
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }

  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
  }
  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  //#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
      };
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:22:52.540Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  //#pragma wait
  //#pragma parallel
  //#pragma cache inputData
  //#pragma noautoparvar
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  
  //#pragma wait
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }

  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
  }
  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  //#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
      };
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:23:53.219Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  //#pragma wait
  //#pragma parallel
  //#pragma cache inputData
  //#pragma noautoparvar
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  
  //#pragma wait
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }

  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
  }
  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  //#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
      };
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:27:11.504Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  //#pragma wait
  //#pragma parallel
  //#pragma cache inputData
  //#pragma noautoparvar
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  
  //#pragma wait
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }

  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
  }
  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  //#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
      };
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:29:17.443Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  //#pragma wait
  //#pragma parallel
  //#pragma cache inputData
  //#pragma noautoparvar
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  
  //#pragma wait
  //#pragma sequential
  //#pragma parvar output
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }

  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
  }
  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  //#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
      };
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:29:27.389Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  //#pragma wait
  //#pragma parallel
  //#pragma cache inputData
  //#pragma noautoparvar
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  
  //#pragma wait
  //#pragma sequential
  //#pragma parvar output
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }

  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
  }
  //__set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  //#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
      };
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:30:30.101Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  //#pragma wait
  //#pragma parallel
  //#pragma cache inputData
  //#pragma noautoparvar
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  
  //#pragma wait
  //#pragma sequential
  //#pragma parvar output
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }

  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
  }
  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  //#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
      };
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:31:27.160Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }

  //#pragma wait
  //#pragma parallel
  //#pragma cache inputData
  //#pragma noautoparvar
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  
  //#pragma wait
  //#pragma sequential
  //#pragma parvar output
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");


  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
  }
  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  //#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
      };
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:31:56.089Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }

  //#pragma wait
  //#pragma parallel
  //#pragma cache inputData
  //#pragma noautoparvar
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  
  //#pragma wait
  //#pragma sequential
  //#pragma parvar output
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");


  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
//    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
  }
  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  //#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
      };
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:32:08.940Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }

  //#pragma wait
  //#pragma parallel
  //#pragma cache inputData
  //#pragma noautoparvar
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  
  //#pragma wait
  //#pragma sequential
  //#pragma parvar output
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");


  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
  }
  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  //#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
      };
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:33:58.465Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }

  //#pragma wait
  //#pragma parallel
  //#pragma cache inputData
  //#pragma noautoparvar
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  
  //#pragma wait
  //#pragma sequential
  //#pragma parvar output
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");

  var output = [];
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
  }
  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  //#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
      };
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:34:41.494Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }

  //#pragma wait
  //#pragma parallel
  //#pragma cache inputData
  //#pragma noautoparvar
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  
  //#pragma wait
  //#pragma sequential
  //#pragma parvar output
  //#pragma parvar inputData
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");

  var output = [];
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
  }
  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  //#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
      };
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:35:46.470Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }

  //#pragma wait
  //#pragma parallel
  //#pragma cache inputData
  //#pragma noautoparvar
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  
  //#pragma wait
  //#pragma sequential
  //#pragma parvar output
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");

  var output = [];
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, 3)];
  }
  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  //#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
      };
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:37:42.480Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }

  //#pragma wait
  //#pragma parallel
  //#pragma cache inputData
  //#pragma noautoparvar
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  
  //#pragma wait
  //#pragma sequential
  //#pragma parvar output
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");

  var output = [];
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    try {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }
    catch (e) {console.log(e);}
        
    }
  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  //#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
      };
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:38:04.671Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }

  //#pragma wait
  //#pragma parallel
  //#pragma cache inputData
  //#pragma noautoparvar
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  
  //#pragma wait
  //#pragma sequential
  //#pragma parvar output
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");

  var output = [];
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    try {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }
    catch (e) {console.log(e.error);}
        
    }
  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  //#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
      };
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:38:16.035Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }

  //#pragma wait
  //#pragma parallel
  //#pragma cache inputData
  //#pragma noautoparvar
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  
  //#pragma wait
  //#pragma sequential
  //#pragma parvar output
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");

  var output = [];
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    try {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }
    catch (e) {console.log(e.message);}
        
    }
  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  //#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
      };
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:47:55.683Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  
  //#pragma wait
  //#pragma sequential
  //#pragma parvar output
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");

  var output = [];
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    try {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }
    catch (e) {console.log(e.message);}
        
    }
  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  //#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
      };
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:49:07.515Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  
  //#pragma wait
  //#pragma sequential
  //#pragma parvar output
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
  inputData = inputData;
  var output = [];
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    try {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }
    catch (e) {console.log(e.message);}
        
    }
  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  //#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
      };
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:49:48.189Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
  var output = [];
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    try {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }
    catch (e) {console.log(e.message);}
        
    }
  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  //#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
      };
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:52:36.179Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    try {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }
    catch (e) {console.log(e.message);}
        
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  //#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
      };
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:53:45.887Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    try {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }
    catch (e) {console.log(e.message);}
        
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  //#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
      };
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:54:07.245Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    try {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }
    catch (e) {console.log(e.message);}
        
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  ////#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
      };
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:55:10.037Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    try {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }
    catch (e) {console.log(e.message);}
        
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  ////#pragma parvar inputData
  while ( blockLength <= N ) {
 console.log('b');
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
      };
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:55:24.879Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    try {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }
    catch (e) {console.log(e.message);}
        
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  ////#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
 console.log('b');
    var phaseStep = {
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
      };
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:55:37.756Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    try {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }
    catch (e) {console.log(e.message);}
        
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  ////#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
      };
 console.log('b');
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:55:57.956Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    try {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }
    catch (e) {console.log(e.message);}
        
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  ////#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength)
      };
 console.log('b');
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:56:56.432Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  ////#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
try {
    var phaseStep = {
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength)
      };
    }
    catch (e) {console.log(e.message);}

 console.log('b');
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T20:58:57.944Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  ////#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
try {
    var phaseStep = new ComplexNumber({
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength)
      });
    }
    catch (e) {console.log(e.message);}

 console.log('b');
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:00:45.831Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  ////#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
try {
    var phaseStep = {};
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);
    }
    catch (e) {console.log(e.message);}

 console.log('b');
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:02:06.015Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  ////#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
try {
    var phaseStep = {};
    console.log(Math);
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);
    }
    catch (e) {console.log(e.message);}

 console.log('b');
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:06:33.434Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  ////#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
try {
    var phaseStep = {};
    console.log(global.Math);
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);
    }
    catch (e) {console.log(e.message);}

 console.log('b');
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:07:04.114Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  ////#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
try {
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);
    }
    catch (e) {console.log(e.message);}

 console.log('b');
    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:08:06.966Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  ////#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
try {
    var phaseStep = {};
//    var Math = global.Math;
//    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
//    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);
    }
    catch (e) {console.log(e.message);}

 console.log('b');
    var nopu = Math.floor(N / blockLength);
 console.log('c');
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:09:02.906Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  ////#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
//try {
    var phaseStep = {};
//    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);
//    }
//    catch (e) {console.log(e.message);}

 console.log('b');
    var nopu = Math.floor(N / blockLength);
 console.log('c');
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:09:23.605Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  ////#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
//try {
    var phaseStep = {};
//    var Math = global.Math;
//    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
//    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);
//    }
//    catch (e) {console.log(e.message);}

 console.log('b');
    var nopu = Math.floor(N / blockLength);
 console.log('c');
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:10:23.870Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  ////#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
try {
    var phaseStep = {};
//    var Math = global.Math;
//    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);
    }
    catch (e) {console.log(e.message);}

 console.log('b');
    var nopu = Math.floor(N / blockLength);
 console.log('c');
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:10:46.885Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  ////#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
try {
    var phaseStep = {};
//    var Math = global.Math;
    phaseStep.re = 2 * Math.PI / blockLength;
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);
    }
    catch (e) {console.log(e.message);}

 console.log('b');
    var nopu = Math.floor(N / blockLength);
 console.log('c');
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:12:07.167Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  ////#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
try {
    var phaseStep = {};
//    var Math = global.Math;
//    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
//    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);
    }
    catch (e) {console.log(e.message);}

 console.log('b');
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);
    var nopu = Math.floor(N / blockLength);
 console.log('c');
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:12:39.542Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  ////#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
try {
    var phaseStep = {};
//    var Math = global.Math;
//    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
//    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);
    }
    catch (e) {console.log(e.message);}

 console.log('b');
    var nopu = Math.floor(N / blockLength);
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);
 console.log('c');
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:12:54.363Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  ////#pragma parvar inputData
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
try {
    var phaseStep = {};
//    var Math = global.Math;
//    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
//    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);
    }
    catch (e) {console.log(e.message);}

 console.log('b');
    var nopu = Math.floor(N / blockLength);
 console.log('c');
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:16:20.551Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

 console.log('b');
    var nopu = Math.floor(N / blockLength);
 console.log('c');
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:17:17.919Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
 console.log("a");
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

//  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:19:04.018Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

  output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:20:48.458Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

try {
  output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);
} catch(e) {console.log(e.message);}

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:21:15.245Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

try {
//  output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);
} catch(e) {console.log(e.message);}

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:21:38.172Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

try {
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);
} catch(e) {console.log(e.message);}

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:23:15.522Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

//#pragma wait
//#pragma sequential

try {
//  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);
} catch(e) {console.log(e.message);}

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:23:39.694Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

////#pragma wait
//#pragma sequential

try {
//  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);
} catch(e) {console.log(e.message);}

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:24:43.893Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  ////#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

////#pragma wait
//#pragma sequential

try {
//  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);
} catch(e) {console.log(e.message);}

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:25:15.284Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
  var output = [];
  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

////#pragma wait
//#pragma sequential

try {
//  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);
} catch(e) {console.log(e.message);}

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:26:21.193Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
  var output = [];
  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);
  var output = [];

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }

////#pragma wait
//#pragma sequential

try {
//  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);
} catch(e) {console.log(e.message);}

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:27:25.308Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
  var output = [];
  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
try {
//  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);
} catch(e) {console.log(e.message);}

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:27:49.997Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
  var output = [];
  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
try {
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);
} catch(e) {console.log(e.message);}

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:28:38.756Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
  var output = [];
  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job);   
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:34:16.685Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
  var output = [];
  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:34:40.359Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:35:37.040Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:37:22.408Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  ////#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
      console.log(output.length);
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:38:36.919Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
      console.log(output.length);
  var output = [];
  __set_Par_Var_Value('output', output, __job, true);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:39:01.655Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
  var output = [];
  __set_Par_Var_Value('output', output, __job, true);
      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:39:32.795Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
  __set_Par_Var_Value('output', output, __job, true);
      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:39:52.814Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:40:01.229Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:41:20.449Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
for (var j = 0; j < output.length; j++)
  console.log(output[j]);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-04T21:42:14.610Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 50000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
for (var j = 0; j < output.length; j++)
  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T10:38:52.472Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 50000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T10:49:04.987Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
//#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */


set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 10000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }

  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
  }

  for (var blockLength = 2; blockLength <= N; blockLength *= 2) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = new ComplexNumber({
      re: Math.cos(2 * Math.PI / blockLength),
      im: imaginarySign * Math.sin(2 * Math.PI / blockLength),
    });

    for (var blockStart = 0; blockStart < N; blockStart += blockLength) {
      var phase = new ComplexNumber({ re: 1, im: 0 });

      for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
        var component = output[signalId + blockLength / 2].multiply(phase);

        var upd1 = output[signalId].add(component);
        var upd2 = output[signalId].subtract(component);

        output[signalId] = upd1;
        output[signalId + blockLength / 2] = upd2;

        phase = phase.multiply(phaseStep);
      }
    }
  }

  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//  console.log(output);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T10:49:34.873Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 10000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
//      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T10:49:59.234Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 10000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
//      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T11:06:28.220Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 10000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
//      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T11:51:29.212Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
//      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice__start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T11:54:52.003Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 10000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
//      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:03:21.636Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
//      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
for (var j = 0; j < output.length; j++)
  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:03:28.316Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
//      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
for (var j = 0; j < output.length; j++)
  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:03:55.310Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
//      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
for (var j = 0; j < output.length; j++)
  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:04:20.451Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
//      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          output[signalId] = upd1;
          output[signalId + blockLength / 2] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:06:22.513Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
//      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(n / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
   // for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
for (var j = 0; j < output.length; j++)
  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:09:17.404Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
//      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
   // for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
for (var j = 0; j < output.length; j++)
  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:11:16.903Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
//      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
//          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
   // for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
for (var j = 0; j < output.length; j++)
  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:13:33.149Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
//      console.log(output.length);
      var outputblock = [];
      console.log(N);
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
   // for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
for (var j = 0; j < output.length; j++)
  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:14:47.620Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
//      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
console.log(signalId + blockLength / 2);
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
   // for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
for (var j = 0; j < output.length; j++)
  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:17:46.170Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
//      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
console.log(output[signalId + blockLength / 2]);
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
   // for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
for (var j = 0; j < output.length; j++)
  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:18:02.297Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
//      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
console.log(output[signalId + blockLength / 2].re);
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
   // for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
for (var j = 0; j < output.length; j++)
  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:21:03.547Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
//      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
//console.log(output[signalId + blockLength / 2].re);
          var component = new ComplexNumber(output[signalId + blockLength / 2]);
          component = component.multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
   // for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
for (var j = 0; j < output.length; j++)
  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:22:10.092Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
//      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
//console.log(output[signalId + blockLength / 2].re);
          var component = new ComplexNumber(output[signalId + blockLength / 2]);
          console.log(component);
          component = component.multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
   // for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
for (var j = 0; j < output.length; j++)
  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:22:21.647Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
//      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
//console.log(output[signalId + blockLength / 2].re);
          var component = new ComplexNumber(output[signalId + blockLength / 2]);
          console.log(component.re);
          component = component.multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
   // for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
for (var j = 0; j < output.length; j++)
  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:23:25.677Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      output = __get_Par_Var_Value('output', false, __job); 
//      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
//console.log(output[signalId + blockLength / 2].re);
          var component = new ComplexNumber(output[signalId + blockLength / 2]);
          console.log(component.multiply);
          component = component.multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
   // for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
for (var j = 0; j < output.length; j++)
  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:24:40.727Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      output = __get_Par_Var_Value('output', false, __job); 
//      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
//console.log(output[signalId + blockLength / 2].re);
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
   // for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
for (var j = 0; j < output.length; j++)
  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:26:15.551Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', false, __job); 
//      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
//console.log(output[signalId + blockLength / 2].re);
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
   // for (var j = slice_start; j <= slice_end; j++) outputblock[j-slice_start] = output[j];
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
for (var j = 0; j < output.length; j++)
  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:28:31.470Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', false, __job); 
//      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:28:42.954Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', false, __job); 
//      console.log(output.length);
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:29:22.252Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', false, __job); 
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:29:33.659Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
//    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', false, __job); 
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:29:54.467Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
//    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', false, __job); 
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:30:16.306Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
//    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', false, __job); 
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

//  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:30:22.484Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
//    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', false, __job); 
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

//  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:35:33.321Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
//    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', false, __job); 
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:35:39.932Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
//    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', false, __job); 
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:36:05.408Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 10000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
//    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', false, __job); 
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:36:40.312Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 10000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
//    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', false, __job); 
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:37:14.360Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 10000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
//    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', false, __job); 
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:37:54.531Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 10000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
//    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', false, __job); 
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:39:31.600Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 10000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
//    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', false, __job); 
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:40:02.506Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 10000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
//    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', false, __job); 
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:49:09.662Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 10000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', false, __job); 
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:50:58.698Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 10000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', false, __job); 
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:52:57.749Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 10000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', false, __job); 
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T13:54:55.419Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 10000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', false, __job); 
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T14:00:06.041Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', false, __job); 
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T14:00:10.883Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', false, __job); 
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T14:00:20.379Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

//  for (var i = 1; i < 10000; i++) {
//   for (var j = 0; j < 10; j++) {
//	inputData.push(inputData[j]);
//	}
//	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', false, __job); 
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T17:33:40.988Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 10000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', false, __job); 
console.log('after get');
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
    }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T17:37:47.194Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 10000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', false, __job); 
console.log('after get');
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
  console.log('after set');
  }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T17:47:25.435Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 10000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', true, __job); 
console.log('after get');
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, false, slice_start);
  console.log('after set');
  }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T17:47:50.393Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 10000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', true, __job); 
console.log('after get');
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, false, slice_start);
  console.log('after set');
  }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T17:49:15.297Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 10000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', true, __job); 
console.log('after get');
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, false, slice_start);
  console.log('after set');
  }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T17:50:54.528Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 10000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', true, __job); 
console.log('after get');
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
  console.log('after set');
  }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T17:51:56.073Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 10000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', true, __job); 
console.log('after get');
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
  console.log('after set');
  }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T17:52:58.167Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 5000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', true, __job); 
console.log('after get');
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
  console.log('after set');
  }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T17:53:33.644Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 2000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', true, __job); 
console.log('after get');
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
  console.log('after set');
  }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T18:04:54.894Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 2000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', true, __job); 
console.log('after get');
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
  console.log('after set');
  }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T18:06:20.591Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 10000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', true, __job); 
console.log('after get');
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
  console.log('after set');
  }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T18:08:37.727Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 10000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', true, __job); 
console.log('after get');
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
  console.log('after set');
  }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T18:09:29.674Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 10000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', true, __job); 
console.log('after get');
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
  console.log('after set');
  }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

2020-08-05T18:10:00.902Z: user: vladas
// Fast Fourier Transform calculation

//#pragma sequential
//#pragma parvar inputData
////#pragma parvar output



/**
 * Returns the radix-2 fast fourier transform of the given array.
 * Optionally computes the radix-2 inverse fast fourier transform.
 *
 * @param {ComplexNumber[]} inputData
 * @param {boolean} [inverse]
 * @return {ComplexNumber[]}
 */

var OPUS = 4;  // Must be power of 2

set_prototypes();

var inputData = [
      new ComplexNumber({ re: -83656.9359385182, im: 98724.08038374918 }),
      new ComplexNumber({ re: -47537.415125808424, im: 88441.58381765135 }),
      new ComplexNumber({ re: -24849.657029355192, im: -72621.79007878687 }),
      new ComplexNumber({ re: 31451.27290052717, im: -21113.301128347346 }),
      new ComplexNumber({ re: 13973.90836288876, im: -73378.36721594246 }),
      new ComplexNumber({ re: 14981.520420492234, im: 63279.524958963884 }),
      new ComplexNumber({ re: -9892.575367044381, im: -81748.44671677813 }),
      new ComplexNumber({ re: -35933.00356823792, im: -46153.47157161784 }),
      new ComplexNumber({ re: -22425.008561855735, im: -86284.24507370662 }),
      new ComplexNumber({ re: -39327.43830818355, im: 30611.949874562706 }),
    ];

  for (var i = 1; i < 10000; i++) {
   for (var j = 0; j < 10; j++) {
	inputData.push(inputData[j]);
	}
	}

  var inverse = false;
  var output = [];
  var bitsCount = bitLength(inputData.length - 1);
  var N = 1 << bitsCount;

  while (inputData.length < N) {
    inputData.push(new ComplexNumber());
  }
  for (var dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {
    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];
    }

  //#pragma wait
  //#pragma cache inputData
  //#pragma noautoparvar
  //#pragma parallel
  for (var i=1; i<8; i++) {
      inputData = inputData;
      console.log("Cached OPU #"+i);
  }
  //#pragma wait
  //#pragma parvar output
  //#pragma sequential
  var start_time = new Date().getTime();
  var finish_time;
  var elapse_time;
//  console.log("Program started");
//  var output = [];
//  __set_Par_Var_Value('output', output, __job, true);
//      console.log(output.length);

  var blockLength = 2;
  //#pragma dive
  //#pragma wait
  //#pragma parvar output
  while ( blockLength <= N ) {
    var imaginarySign = inverse ? -1 : 1;
    var phaseStep = {};
    var Math = global.Math;
    phaseStep.re = Math.cos(2 * Math.PI / blockLength);
    phaseStep.im = imaginarySign * Math.sin(2 * Math.PI / blockLength);

    var nopu = Math.floor(N / blockLength);
    if (nopu > OPUS) nopu = OPUS;
//    console.log('nopu='+nopu);
    console.log('blockLength='+blockLength);
    //#pragma parallel
    //#pragma wait
    //#pragma noautoparvar
    //#pragma parvar output
    //#pragma parvar outputblock
    for (var opu = 1; opu <= nopu; opu++) {
      set_prototypes();
      phaseStep = phaseStep;
      output = __get_Par_Var_Value('output', true, __job); 
console.log('after get');
      var outputblock = [];
      var chunk_len = Math.floor(N / nopu);
      var slice_start = (opu-1) * chunk_len;
      var slice_end = slice_start + chunk_len - 1;
      if (slice_end >= N) slice_end = N - 1;
      for (var blockStart = slice_start; blockStart <= slice_end; blockStart += blockLength) {
        var phase = new ComplexNumber({ re: 1, im: 0 });

        for (var signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {
          var component = new ComplexNumber(output[signalId + blockLength / 2]).multiply(phase);

          var upd1 = new ComplexNumber(output[signalId]).add(component);
          var upd2 = new ComplexNumber(output[signalId]).subtract(component);

          outputblock[signalId-slice_start] = upd1;
          outputblock[signalId + blockLength / 2 - slice_start] = upd2;

          phase = phase.multiply(new ComplexNumber(phaseStep));
        }
      }
    __set_Par_Var_Value('output', outputblock, __job, true, slice_start);
  console.log('after set');
  }
  //#pragma sequential
  //#pragma wait
  blockLength *= 2;
  }
  var output = __get_Par_Var_Value('output', false, __job);   
  if (inverse) {
    for (var signalId = 0; signalId < N; signalId += 1) {
      output[signalId] /= N;
    }
  }

  console.log(output.length);
//for (var j = 0; j < output.length; j++)
//  console.log(output[j].re + ":::" + output[j].im);

  finish_time = new Date().getTime();
  elapse_time = (finish_time - start_time) / 1000;
  console.log("Elapse time: " + elapse_time + " sec\n");


function ComplexNumber(number) {
  /**
   * z = re + im * i
   * z = radius * e^(i * phase)
   *
   * @param {number} [re]
   * @param {number} [im]
   */
    if (!number) {
	this.re = 0;
	this.im = 0;
	}
    else {
	this.re = number.re;
	this.im = number.im;
	}
}

function set_prototypes() {

ComplexNumber.prototype.add = function(addend) {

  /**
   * @param {ComplexNumber|number} addend
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexAddend = this.toComplexNumber(addend);

    return new ComplexNumber({
      re: this.re + complexAddend.re,
      im: this.im + complexAddend.im,
    });
};

ComplexNumber.prototype.subtract = function(subtrahend) {

  /**
   * @param {ComplexNumber|number} subtrahend
   * @return {ComplexNumber}
   */
   
    // Make sure we're dealing with complex number.
    var complexSubtrahend = this.toComplexNumber(subtrahend);

    return new ComplexNumber({
      re: this.re - complexSubtrahend.re,
      im: this.im - complexSubtrahend.im,
    });
};

ComplexNumber.prototype.multiply = function(multiplicand) {
  /**
   * @param {ComplexNumber|number} multiplicand
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexMultiplicand = this.toComplexNumber(multiplicand);

    return new ComplexNumber({
      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,
      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,
    });
};

ComplexNumber.prototype.divide = function(divider) {

  /**
   * @param {ComplexNumber|number} divider
   * @return {ComplexNumber}
   */

    // Make sure we're dealing with complex number.
    var complexDivider = this.toComplexNumber(divider);

    // Get divider conjugate.
    var dividerConjugate = this.conjugate(complexDivider);

    // Multiply dividend by divider's conjugate.
    var finalDivident = this.multiply(dividerConjugate);

    // Calculating final divider using formula (a + bi)(a  bi) = a^2 + b^2
    var finalDivider = (complexDivider.re * complexDivider.re) + (complexDivider.im * complexDivider.im);

    return new ComplexNumber({
      re: finalDivident.re / finalDivider,
      im: finalDivident.im / finalDivider,
    });
};

ComplexNumber.prototype.conjugate = function(number) {

  /**
   * @param {ComplexNumber|number} number
   */

    // Make sure we're dealing with complex number.
    var complexNumber = this.toComplexNumber(number);

    return new ComplexNumber({
      re: complexNumber.re,
      im: -1 * complexNumber.im,
    });
};

ComplexNumber.prototype.getRadius = function() {
  /**
   * @return {number}
   */

    return Math.sqrt((this.re * this.re) + (this.im * this.im));
};

ComplexNumber.prototype.getPhase = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {number}
   */

    if (inRadians == undefined) inRadians = true;

    var phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));

    if (this.re < 0 && this.im > 0) {
      phase = Math.PI - phase;
    } else if (this.re < 0 && this.im < 0) {
      phase = -(Math.PI - phase);
    } else if (this.re > 0 && this.im < 0) {
      phase = -phase;
    } else if (this.re === 0 && this.im > 0) {
      phase = Math.PI / 2;
    } else if (this.re === 0 && this.im < 0) {
      phase = -Math.PI / 2;
    } else if (this.re < 0 && this.im === 0) {
      phase = Math.PI;
    } else if (this.re > 0 && this.im === 0) {
      phase = 0;
    } else if (this.re === 0 && this.im === 0) {
      // More correctly would be to set 'indeterminate'.
      // But just for simplicity reasons let's set zero.
      phase = 0;
    }

    if (!inRadians) {
      phase = radianToDegree(phase);
    }

    return phase;
};

ComplexNumber.prototype.getPolarForm = function(inRadians) {
  /**
   * @param {boolean} [inRadians]
   * @return {{radius: number, phase: number}}
   */
    if (inRadians == undefined) inRadians = true;

    return {
      radius: this.getRadius(),
      phase: this.getPhase(inRadians),
    };
};

ComplexNumber.prototype.toComplexNumber = function(number) {

  /**
   * Convert real numbers to complex number.
   * In case if complex number is provided then lefts it as is.
   *
   * @param {ComplexNumber|number} number
   * @return {ComplexNumber}
   */

    if (number instanceof ComplexNumber) {
      return number;
    }

    return new ComplexNumber({ re: number });
};


}

/**
 * Return the number of bits used in the binary representation of the number.
 *
 * @param {number} number
 * @return {number}
 */
function bitLength(number) {
  var bitsCounter = 0;

  while ((1 << bitsCounter) <= number) {
    bitsCounter += 1;
  }

  return bitsCounter;
}

/**
 * Returns the number which is the flipped binary representation of input.
 *
 * @param {number} input
 * @param {number} bitsCount
 * @return {number}
 */
function reverseBits(input, bitsCount) {
  var reversedBits = 0;

  for (var bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {
    reversedBits *= 2;

    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {
      reversedBits += 1;
    }
  }

  return reversedBits;
}

/**
 * @param {number} radian
 * @return {number}
 */
function radianToDegree(radian) {
  return radian * (180 / Math.PI);
}

-------------------------------------

